<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matem√°ticas - Figuras Planas</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3B82F6">
    <style>
        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        .module-card {
            transition: transform 0.2s ease-in-out;
        }

        .module-card:hover {
            transform: translateY(-2px);
        }

        .tab-button {
            transition: all 0.2s ease-in-out;
        }

        .tab-button.active {
            background-color: #3B82F6;
            color: white;
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 640px) {
            .container {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .module-card {
                padding: 1.5rem;
            }
            
            .tab-button {
                padding: 0.75rem 1rem;
                font-size: 0.875rem;
            }
        }

        /* Touch Target Optimization */
        .touch-target {
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .interactive-element {
            cursor: pointer;
            -webkit-tap-highlight-color: rgba(59, 130, 246, 0.3);
        }

        /* SVG Interactive Elements */
        .draggable-vertex {
            cursor: grab;
            stroke-width: 3;
            r: 8;
        }

        .draggable-vertex:active {
            cursor: grabbing;
        }

        @media (max-width: 768px) {
            .draggable-vertex {
                r: 12;
                stroke-width: 4;
            }
        }

        /* Mobile-specific hover states */
        @media (hover: none) and (pointer: coarse) {
            .module-card:hover {
                transform: none;
            }
            
            .interactive-element:active {
                background-color: rgba(59, 130, 246, 0.1);
                transform: scale(0.98);
            }
        }

        /* Improved button sizing for mobile */
        @media (max-width: 640px) {
            button {
                min-height: 44px;
                padding: 0.75rem 1.5rem;
            }
            
            input[type="number"] {
                min-height: 44px;
                padding: 0.75rem;
                font-size: 1rem;
            }
        }

        /* Test panel mobile optimization */
        @media (max-width: 768px) {
            #testPanel .bg-white {
                margin: 1rem;
                max-height: calc(100vh - 2rem);
            }
            
            #testPanel .space-x-2 {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            #testPanel .space-x-2 > * {
                margin: 0;
            }
        }

        /* SVG responsiveness and performance optimization */
        svg {
            max-width: 100%;
            height: auto;
            /* Enable hardware acceleration */
            will-change: transform;
            transform: translateZ(0);
            /* Optimize rendering */
            shape-rendering: optimizeSpeed;
            text-rendering: optimizeSpeed;
        }

        /* Performance optimizations for mobile */
        @media (max-width: 768px) {
            /* Reduce animations on mobile for better performance */
            .module-card {
                transition: transform 0.1s ease-in-out;
            }
            
            /* Optimize touch targets */
            .draggable-vertex {
                r: 14;
                stroke-width: 5;
            }
            
            /* Reduce shadow complexity on mobile */
            .shadow-lg {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            }
        }

        /* Hardware acceleration for interactive elements */
        .interactive-element,
        .draggable-vertex,
        .module-card {
            will-change: transform;
            transform: translateZ(0);
        }

        /* Optimize animations for 60fps */
        @media (prefers-reduced-motion: no-preference) {
            .view {
                transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            }
        }

        /* Reduce motion for users who prefer it */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Smooth Transitions and Animations */
        .view {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .view:not(.active) {
            opacity: 0;
            transform: translateY(10px);
        }

        .view.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Loading states */
        .loading {
            position: relative;
            overflow: hidden;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: loading-shimmer 1.5s infinite;
        }

        @keyframes loading-shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Button press animations */
        .interactive-element:active {
            transform: scale(0.98);
            transition: transform 0.1s ease-in-out;
        }

        /* Hover effects for desktop */
        @media (hover: hover) and (pointer: fine) {
            .interactive-element:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                transition: all 0.2s ease-in-out;
            }
            
            .tab-button:hover:not(.active) {
                background-color: rgba(59, 130, 246, 0.1);
            }
        }

        /* Success/Error feedback animations */
        .feedback-success {
            background-color: #10B981;
            color: white;
            animation: feedback-pulse 0.6s ease-in-out;
        }

        .feedback-error {
            background-color: #EF4444;
            color: white;
            animation: feedback-shake 0.6s ease-in-out;
        }

        @keyframes feedback-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes feedback-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Content fade-in animation */
        .content-fade-in {
            animation: fade-in 0.5s ease-in-out;
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* SVG element animations */
        .svg-element-highlight {
            animation: highlight-pulse 1s ease-in-out;
        }

        @keyframes highlight-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Progress indicators */
        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #E5E7EB;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #3B82F6;
            transition: width 0.3s ease-in-out;
        }

        /* Notification animations */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background-color: #10B981;
        }

        .notification.error {
            background-color: #EF4444;
        }

        .notification.info {
            background-color: #3B82F6;
        }

        /* Spinner animation for loading states */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        /* Enhanced button animations */
        .interactive-element {
            position: relative;
            overflow: hidden;
        }

        /* Pulse animation for important elements */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Bounce animation for success states */
        @keyframes bounce {
            0%, 20%, 53%, 80%, 100% { transform: translate3d(0,0,0); }
            40%, 43% { transform: translate3d(0, -8px, 0); }
            70% { transform: translate3d(0, -4px, 0); }
            90% { transform: translate3d(0, -2px, 0); }
        }

        .animate-bounce {
            animation: bounce 1s ease-in-out;
        }

        /* Improved layout for small screens */
        @media (max-width: 640px) {
            .grid.md\\:grid-cols-2 {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .grid.md\\:grid-cols-3 {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .flex.items-center {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }
            
            .flex.items-center > button {
                order: 2;
            }
            
            .flex.items-center > h1 {
                order: 1;
                text-align: center;
            }
        }

        /* Offline status indicator */
        .offline-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #F59E0B;
            color: white;
            text-align: center;
            padding: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            z-index: 1000;
            transform: translateY(-100%);
            transition: transform 0.3s ease-in-out;
        }

        .offline .offline-indicator {
            transform: translateY(0);
        }

        .offline .container {
            padding-top: 3rem;
        }

        /* Offline mode adjustments */
        .offline .module-card {
            border: 2px solid #F59E0B;
        }

        .offline .module-card::after {
            content: 'üì± Disponible offline';
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(245, 158, 11, 0.9);
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: 500;
        }
    </style>
</head>

<body class="bg-gray-100 font-sans">
    <!-- Offline Status Indicator -->
    <div class="offline-indicator">
        üì± Modo Offline - Todas las funciones disponibles sin conexi√≥n
    </div>

    <div id="app" class="min-h-screen">
        <!-- Home View -->
        <div id="homeView" class="view active">
            <div class="container mx-auto px-4 py-8">
                <header class="text-center mb-8">
                    <h1 class="text-4xl font-bold text-blue-600 mb-2">Matem√°ticas</h1>
                    <h2 class="text-2xl text-gray-700">Figuras Planas - 6¬∫ Grado</h2>
                </header>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-6xl mx-auto">
                    <!-- Module Cards will be populated by JavaScript -->
                </div>

                <!-- Hidden Test Panel (activated by pressing Ctrl+Shift+T) -->
                <div id="testPanel" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden">
                    <div class="bg-white rounded-lg shadow-xl max-w-4xl mx-auto mt-8 p-6 max-h-96 overflow-y-auto">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-gray-800">Unit Tests</h3>
                            <button id="closeTestPanel"
                                class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
                        </div>
                        <div class="mb-4 flex flex-wrap gap-2">
                            <button id="runCircleTestsBtn"
                                class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run Circle Tests
                            </button>
                            <button id="runPiTestsBtn"
                                class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run Pi Tests
                            </button>
                            <button id="runFigureGameTestsBtn"
                                class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run Figure Game Tests
                            </button>
                            <button id="runPositionTestsBtn"
                                class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run Position Tests
                            </button>
                            <button id="runEvaluationTestsBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run Evaluation Tests
                            </button>
                            <button id="runAllTestsBtn"
                                class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run All Tests
                            </button>
                            <button id="runAutomatedTestsBtn"
                                class="bg-teal-500 hover:bg-teal-600 text-white px-4 py-2 rounded-lg touch-target interactive-element">
                                Run Automated Utils
                            </button>
                        </div>
                        <div id="testResults" class="bg-gray-50 p-4 rounded-lg min-h-32">
                            <p class="text-gray-600">Click a button to execute unit tests.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Module View -->
        <div id="moduleView" class="view">
            <div class="container mx-auto px-4 py-8">
                <!-- Header with back button -->
                <div class="flex flex-col sm:flex-row items-start sm:items-center mb-6 gap-4">
                    <button id="backButton"
                        class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg transition-colors touch-target interactive-element">
                        ‚Üê Regresar
                    </button>
                    <h1 id="moduleTitle" class="text-2xl sm:text-3xl font-bold text-blue-600"></h1>
                </div>

                <!-- Tab Navigation -->
                <div class="flex flex-col sm:flex-row mb-6 bg-white rounded-lg shadow-sm overflow-hidden">
                    <button class="tab-button flex-1 py-3 px-6 text-center font-medium active touch-target interactive-element" data-tab="teoria">
                        Teor√≠a
                    </button>
                    <button class="tab-button flex-1 py-3 px-6 text-center font-medium touch-target interactive-element" data-tab="practica">
                        Pr√°ctica
                    </button>
                    <button class="tab-button flex-1 py-3 px-6 text-center font-medium touch-target interactive-element" data-tab="evaluacion">
                        Evaluaci√≥n
                    </button>
                </div>

                <!-- Content Area -->
                <div id="moduleContent" class="bg-white rounded-lg shadow-lg p-6 min-h-96">
                    <!-- Content will be loaded dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Content object structure for all five modules
        const content = {
            'suma-angulos': {
                title: 'Suma de √Ångulos',
                description: 'Aprende sobre la suma de √°ngulos en tri√°ngulos y cuadril√°teros',
                color: 'bg-red-500',
                teoria: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Suma de √Ångulos Internos</h3>
                        
                        <div class="bg-blue-50 p-6 rounded-lg">
                            <h4 class="text-xl font-medium text-blue-800 mb-3">Tri√°ngulos</h4>
                            <p class="text-gray-700 mb-3">
                                La suma de los √°ngulos internos de cualquier tri√°ngulo siempre es <strong>180¬∞</strong>.
                            </p>
                            <div class="bg-white p-4 rounded border-l-4 border-blue-500">
                                <p class="font-medium">F√≥rmula: Œ± + Œ≤ + Œ≥ = 180¬∞</p>
                            </div>
                        </div>

                        <div class="bg-green-50 p-6 rounded-lg">
                            <h4 class="text-xl font-medium text-green-800 mb-3">Cuadril√°teros</h4>
                            <p class="text-gray-700 mb-3">
                                La suma de los √°ngulos internos de cualquier cuadril√°tero siempre es <strong>360¬∞</strong>.
                            </p>
                            <div class="bg-white p-4 rounded border-l-4 border-green-500">
                                <p class="font-medium">F√≥rmula: Œ± + Œ≤ + Œ≥ + Œ¥ = 360¬∞</p>
                            </div>
                        </div>

                        <div class="bg-yellow-50 p-6 rounded-lg">
                            <h4 class="text-xl font-medium text-yellow-800 mb-3">¬øPor qu√© es importante?</h4>
                            <ul class="list-disc list-inside text-gray-700 space-y-2">
                                <li>Nos ayuda a encontrar √°ngulos desconocidos</li>
                                <li>Es fundamental para entender las propiedades de las figuras</li>
                                <li>Se aplica en construcci√≥n y dise√±o</li>
                            </ul>
                        </div>
                    </div>
                `,
                practica: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Pr√°ctica Interactiva</h3>
                        <p class="text-gray-600">Arrastra los v√©rtices del tri√°ngulo para ver c√≥mo cambian los √°ngulos.</p>
                        
                        <div class="flex justify-center mb-4">
                            <button id="toggleShape" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors touch-target interactive-element">
                                Cambiar a Cuadril√°tero
                            </button>
                        </div>
                        
                        <div class="bg-gray-50 p-6 rounded-lg">
                            <svg id="angleSvg" width="100%" height="400" viewBox="0 0 500 400" class="border border-gray-300 rounded">
                                <!-- Interactive triangle/quadrilateral will be rendered here -->
                            </svg>
                        </div>
                        
                        <div id="angleDisplay" class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                            <!-- Angle values will be displayed here -->
                        </div>
                    </div>
                `,
                evaluacion: function () {
                    return `
                        <div class="space-y-6">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Evaluaci√≥n</h3>
                            <div id="evaluationContent">
                                <p class="text-gray-600 mb-4">Resuelve los siguientes problemas sobre suma de √°ngulos.</p>
                                <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                    <!-- Dynamic questions will be generated here -->
                                </div>
                            </div>
                        </div>
                    `;
                }
            },
            'circunferencia': {
                title: 'Circunferencia y sus Elementos',
                description: 'Explora los elementos de la circunferencia de manera interactiva',
                color: 'bg-green-500',
                teoria: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Elementos de la Circunferencia</h3>
                        
                        <div class="grid md:grid-cols-2 gap-6">
                            <div class="space-y-4">
                                <div class="bg-red-50 p-4 rounded-lg border-l-4 border-red-500">
                                    <h4 class="font-semibold text-red-800">Centro</h4>
                                    <p class="text-gray-700">Punto interior equidistante de todos los puntos de la circunferencia.</p>
                                </div>
                                
                                <div class="bg-green-50 p-4 rounded-lg border-l-4 border-green-500">
                                    <h4 class="font-semibold text-green-800">Radio</h4>
                                    <p class="text-gray-700">Segmento que une el centro con cualquier punto de la circunferencia.</p>
                                </div>
                                
                                <div class="bg-blue-50 p-4 rounded-lg border-l-4 border-blue-500">
                                    <h4 class="font-semibold text-blue-800">Di√°metro</h4>
                                    <p class="text-gray-700">Segmento que pasa por el centro y une dos puntos de la circunferencia. Es el doble del radio.</p>
                                </div>
                            </div>
                            
                            <div class="space-y-4">
                                <div class="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-500">
                                    <h4 class="font-semibold text-yellow-800">Cuerda</h4>
                                    <p class="text-gray-700">Segmento que une dos puntos cualesquiera de la circunferencia.</p>
                                </div>
                                
                                <div class="bg-purple-50 p-4 rounded-lg border-l-4 border-purple-500">
                                    <h4 class="font-semibold text-purple-800">Arco</h4>
                                    <p class="text-gray-700">Porci√≥n de la circunferencia comprendida entre dos puntos.</p>
                                </div>
                                
                                <div class="bg-indigo-50 p-4 rounded-lg border-l-4 border-indigo-500">
                                    <h4 class="font-semibold text-indigo-800">Tangente</h4>
                                    <p class="text-gray-700">Recta que toca la circunferencia en un solo punto.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                practica: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Explora los Elementos</h3>
                        <p class="text-gray-600">Pasa el mouse sobre los diferentes elementos para identificarlos.</p>
                        
                        <div class="bg-gray-50 p-6 rounded-lg">
                            <svg id="circleSvg" width="100%" height="400" viewBox="0 0 500 400" class="border border-gray-300 rounded">
                                <!-- Interactive circle elements will be rendered here -->
                            </svg>
                        </div>
                        
                        <div id="elementLabel" class="text-center p-4 bg-blue-50 rounded-lg">
                            <p class="text-lg font-medium text-blue-800">Pasa el mouse sobre los elementos para identificarlos</p>
                        </div>
                    </div>
                `,
                evaluacion: function () {
                    return `
                        <div class="space-y-6">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Evaluaci√≥n</h3>
                            <div id="evaluationContent">
                                <p class="text-gray-600 mb-4">Identifica los elementos de la circunferencia.</p>
                                <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                    <!-- Dynamic questions will be generated here -->
                                </div>
                            </div>
                        </div>
                    `;
                }
            },
            'numero-pi': {
                title: 'El N√∫mero œÄ',
                description: 'Descubre el n√∫mero œÄ y aprende a calcular la longitud de circunferencias',
                color: 'bg-purple-500',
                teoria: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">El N√∫mero œÄ (Pi)</h3>
                        
                        <div class="bg-purple-50 p-6 rounded-lg">
                            <h4 class="text-xl font-medium text-purple-800 mb-3">¬øQu√© es œÄ?</h4>
                            <p class="text-gray-700 mb-4">
                                œÄ (pi) es la relaci√≥n entre la longitud de una circunferencia y su di√°metro. 
                                Su valor aproximado es <strong>3.14</strong>.
                            </p>
                            <div class="bg-white p-4 rounded border-l-4 border-purple-500">
                                <p class="font-medium">œÄ = Longitud de la circunferencia √∑ Di√°metro</p>
                            </div>
                        </div>

                        <div class="grid md:grid-cols-2 gap-6">
                            <div class="bg-blue-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-blue-800 mb-3">F√≥rmulas</h4>
                                <div class="space-y-3">
                                    <div class="bg-white p-3 rounded border-l-4 border-blue-500">
                                        <p class="font-medium">L = œÄ √ó d</p>
                                        <p class="text-sm text-gray-600">Longitud = pi √ó di√°metro</p>
                                    </div>
                                    <div class="bg-white p-3 rounded border-l-4 border-blue-500">
                                        <p class="font-medium">L = 2 √ó œÄ √ó r</p>
                                        <p class="text-sm text-gray-600">Longitud = 2 √ó pi √ó radio</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-green-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-green-800 mb-3">Ejemplo</h4>
                                <p class="text-gray-700 mb-2">Si el radio es 5 cm:</p>
                                <div class="bg-white p-3 rounded">
                                    <p>L = 2 √ó 3.14 √ó 5</p>
                                    <p>L = 31.4 cm</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                practica: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Visualiza œÄ</h3>
                        
                        <div class="bg-gray-50 p-6 rounded-lg">
                            <div class="flex flex-col sm:flex-row justify-center gap-4 mb-4">
                                <button id="playAnimation" class="bg-purple-500 hover:bg-purple-600 text-white px-6 py-3 rounded-lg transition-colors touch-target interactive-element">
                                    ‚ñ∂ Reproducir Animaci√≥n
                                </button>
                                <button id="resetAnimation" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg transition-colors touch-target interactive-element">
                                    üîÑ Reiniciar
                                </button>
                            </div>
                            
                            <svg id="piAnimationSvg" width="100%" height="300" viewBox="0 0 600 300" class="border border-gray-300 rounded">
                                <!-- Pi animation will be rendered here -->
                            </svg>
                        </div>
                        
                        <div class="bg-white p-6 rounded-lg border">
                            <h4 class="text-lg font-semibold mb-4">Calculadora de Circunferencia</h4>
                            <div class="grid md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Radio (cm)</label>
                                    <input type="number" id="radiusInput" class="w-full p-3 sm:p-2 border border-gray-300 rounded-lg text-base touch-target" placeholder="Ingresa el radio">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Di√°metro (cm)</label>
                                    <input type="number" id="diameterInput" class="w-full p-3 sm:p-2 border border-gray-300 rounded-lg text-base touch-target" placeholder="Ingresa el di√°metro">
                                </div>
                            </div>
                            <div id="circumferenceResult" class="mt-4 p-4 bg-purple-50 rounded-lg">
                                <p class="text-lg font-medium text-purple-800">Longitud de la circunferencia: --</p>
                            </div>
                        </div>
                    </div>
                `,
                evaluacion: function () {
                    return `
                        <div class="space-y-6">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Evaluaci√≥n</h3>
                            <div id="evaluationContent">
                                <p class="text-gray-600 mb-4">Resuelve los problemas de c√°lculo de circunferencia.</p>
                                <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                    <!-- Dynamic questions will be generated here -->
                                </div>
                            </div>
                        </div>
                    `;
                }
            },
            'circulo-figuras': {
                title: 'C√≠rculo y Figuras Circulares',
                description: 'Distingue entre c√≠rculo y circunferencia, y reconoce figuras circulares',
                color: 'bg-yellow-500',
                teoria: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">C√≠rculo vs Circunferencia</h3>
                        
                        <div class="grid md:grid-cols-2 gap-6">
                            <div class="bg-blue-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-blue-800 mb-3">Circunferencia</h4>
                                <p class="text-gray-700 mb-3">
                                    Es la <strong>l√≠nea curva cerrada</strong> que forma el borde del c√≠rculo.
                                </p>
                                <div class="bg-white p-3 rounded">
                                    <p class="text-sm text-gray-600">Solo el contorno, sin interior</p>
                                </div>
                            </div>
                            
                            <div class="bg-green-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-green-800 mb-3">C√≠rculo</h4>
                                <p class="text-gray-700 mb-3">
                                    Es la <strong>superficie completa</strong> limitada por la circunferencia.
                                </p>
                                <div class="bg-white p-3 rounded">
                                    <p class="text-sm text-gray-600">Incluye el interior y el borde</p>
                                </div>
                            </div>
                        </div>

                        <div class="bg-yellow-50 p-6 rounded-lg">
                            <h4 class="text-xl font-medium text-yellow-800 mb-4">Figuras Circulares</h4>
                            <div class="grid md:grid-cols-3 gap-4">
                                <div class="bg-white p-4 rounded border-l-4 border-red-500">
                                    <h5 class="font-semibold text-red-800">Sector Circular</h5>
                                    <p class="text-sm text-gray-700">Porci√≥n del c√≠rculo limitada por dos radios y un arco.</p>
                                </div>
                                <div class="bg-white p-4 rounded border-l-4 border-blue-500">
                                    <h5 class="font-semibold text-blue-800">Segmento Circular</h5>
                                    <p class="text-sm text-gray-700">Porci√≥n del c√≠rculo limitada por una cuerda y un arco.</p>
                                </div>
                                <div class="bg-white p-4 rounded border-l-4 border-green-500">
                                    <h5 class="font-semibold text-green-800">Corona Circular</h5>
                                    <p class="text-sm text-gray-700">Regi√≥n entre dos circunferencias conc√©ntricas.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                practica: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Juego de Identificaci√≥n</h3>
                        <p class="text-gray-600">Identifica la figura circular que se muestra.</p>
                        
                        <div class="bg-gray-50 p-6 rounded-lg">
                            <svg id="figureGameSvg" width="100%" height="300" viewBox="0 0 400 300" class="border border-gray-300 rounded">
                                <!-- Figure identification game will be rendered here -->
                            </svg>
                        </div>
                        
                        <div id="gameOptions" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <!-- Game options will be populated here -->
                        </div>
                        
                        <div id="gameScore" class="text-center p-4 bg-yellow-50 rounded-lg">
                            <p class="text-lg font-medium text-yellow-800">Puntuaci√≥n: 0</p>
                        </div>
                    </div>
                `,
                evaluacion: function () {
                    return `
                        <div class="space-y-6">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Evaluaci√≥n</h3>
                            <div id="evaluationContent">
                                <p class="text-gray-600 mb-4">Identifica las figuras circulares en las siguientes im√°genes.</p>
                                <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                    <!-- Dynamic questions will be generated here -->
                                </div>
                            </div>
                        </div>
                    `;
                }
            },
            'posiciones-rectas': {
                title: 'Posiciones de Rectas',
                description: 'Explora las diferentes posiciones de rectas respecto a circunferencias',
                color: 'bg-indigo-500',
                teoria: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Posiciones de Rectas y Circunferencias</h3>
                        
                        <div class="space-y-6">
                            <div class="bg-red-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-red-800 mb-3">Recta Exterior</h4>
                                <p class="text-gray-700 mb-3">
                                    La recta <strong>no toca</strong> la circunferencia en ning√∫n punto.
                                </p>
                                <div class="bg-white p-3 rounded border-l-4 border-red-500">
                                    <p class="text-sm">La distancia del centro a la recta es mayor que el radio.</p>
                                </div>
                            </div>
                            
                            <div class="bg-yellow-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-yellow-800 mb-3">Recta Tangente</h4>
                                <p class="text-gray-700 mb-3">
                                    La recta <strong>toca</strong> la circunferencia en exactamente <strong>un punto</strong>.
                                </p>
                                <div class="bg-white p-3 rounded border-l-4 border-yellow-500">
                                    <p class="text-sm">La distancia del centro a la recta es igual al radio.</p>
                                </div>
                            </div>
                            
                            <div class="bg-green-50 p-6 rounded-lg">
                                <h4 class="text-xl font-medium text-green-800 mb-3">Recta Secante</h4>
                                <p class="text-gray-700 mb-3">
                                    La recta <strong>cruza</strong> la circunferencia en <strong>dos puntos</strong>.
                                </p>
                                <div class="bg-white p-3 rounded border-l-4 border-green-500">
                                    <p class="text-sm">La distancia del centro a la recta es menor que el radio.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                practica: `
                    <div class="space-y-6">
                        <h3 class="text-2xl font-semibold text-gray-800 mb-4">Pr√°ctica Interactiva</h3>
                        <p class="text-gray-600">Arrastra la l√≠nea para cambiar su posici√≥n respecto a la circunferencia.</p>
                        
                        <div class="bg-gray-50 p-6 rounded-lg">
                            <svg id="linePositionSvg" width="100%" height="400" viewBox="0 0 500 400" class="border border-gray-300 rounded">
                                <!-- Interactive line position will be rendered here -->
                            </svg>
                        </div>
                        
                        <div id="positionStatus" class="text-center p-4 bg-indigo-50 rounded-lg">
                            <p class="text-xl font-bold text-indigo-800">Posici√≥n: Exterior</p>
                        </div>
                    </div>
                `,
                evaluacion: function () {
                    return `
                        <div class="space-y-6">
                            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Evaluaci√≥n</h3>
                            <div id="evaluationContent">
                                <p class="text-gray-600 mb-4">Identifica la posici√≥n de las rectas en las siguientes im√°genes.</p>
                                <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                    <!-- Dynamic questions will be generated here -->
                                </div>
                            </div>
                        </div>
                    `;
                }
            }
        };

        // Current state
        let currentModule = null;
        let currentTab = 'teoria';

        // Performance optimization utilities
        const PerformanceUtils = {
            // Debounce function for drag operations
            debounce: function(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            // Throttle function for high-frequency events
            throttle: function(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            },

            // Request animation frame wrapper for smooth animations
            requestAnimationFrame: window.requestAnimationFrame || 
                                 window.webkitRequestAnimationFrame || 
                                 window.mozRequestAnimationFrame || 
                                 function(callback) { setTimeout(callback, 16); },

            // Passive event listener support detection
            supportsPassive: (function() {
                let supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, 'passive', {
                        get: function() {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassive', null, opts);
                    window.removeEventListener('testPassive', null, opts);
                } catch (e) {}
                return supportsPassive;
            })()
        };

        // Event delegation manager for better performance
        const EventManager = {
            delegatedEvents: new Map(),

            // Add delegated event listener
            delegate: function(container, selector, event, handler, options = {}) {
                const key = `${container.id || 'container'}-${event}`;
                
                if (!this.delegatedEvents.has(key)) {
                    const delegatedHandler = (e) => {
                        const target = e.target.closest(selector);
                        if (target && container.contains(target)) {
                            handler.call(target, e);
                        }
                    };
                    
                    const eventOptions = PerformanceUtils.supportsPassive && options.passive ? 
                        { passive: true } : false;
                    
                    container.addEventListener(event, delegatedHandler, eventOptions);
                    this.delegatedEvents.set(key, delegatedHandler);
                }
            },

            // Remove delegated event listener
            undelegate: function(container, event) {
                const key = `${container.id || 'container'}-${event}`;
                const handler = this.delegatedEvents.get(key);
                
                if (handler) {
                    container.removeEventListener(event, handler);
                    this.delegatedEvents.delete(key);
                }
            },

            // Clean up all delegated events
            cleanup: function() {
                this.delegatedEvents.clear();
            }
        };

        // Initialize the application
        function initApp() {
            renderModuleCards();
            setupEventListeners();
            setupTestPanel();
            enhanceInteractiveElements();
            setupPerformanceOptimizations();
            
            // Show welcome notification
            setTimeout(() => {
                showNotification('¬°Bienvenido a Matem√°ticas - Figuras Planas!', 'info', 3000);
            }, 1000);
        }

        // Setup performance optimizations for mobile devices
        function setupPerformanceOptimizations() {
            // Enable hardware acceleration for interactive elements
            document.querySelectorAll('.interactive-element, .draggable-vertex, svg').forEach(element => {
                element.style.willChange = 'transform';
                element.style.transform = 'translateZ(0)'; // Force hardware acceleration
            });

            // Optimize touch events for mobile
            if ('ontouchstart' in window) {
                // Disable 300ms click delay on mobile
                document.addEventListener('touchstart', function() {}, 
                    PerformanceUtils.supportsPassive ? { passive: true } : false);
                
                // Prevent zoom on double tap for interactive elements
                document.querySelectorAll('.interactive-element').forEach(element => {
                    element.style.touchAction = 'manipulation';
                });
            }

            // Setup event delegation for better performance
            setupEventDelegation();

            // Optimize SVG rendering
            optimizeSVGRendering();
        }

        // Setup event delegation for common interactive elements
        function setupEventDelegation() {
            const app = document.getElementById('app');
            
            // Delegate button clicks with debouncing
            EventManager.delegate(app, 'button', 'click', PerformanceUtils.debounce(function(e) {
                // Add visual feedback for all buttons
                addVisualFeedback(this, 'success');
            }, 100));

            // Delegate interactive element interactions
            EventManager.delegate(app, '.interactive-element', 'click', function(e) {
                // Add ripple effect
                addRippleEffect(this, e);
            });

            // Delegate touch events for mobile optimization
            if ('ontouchstart' in window) {
                EventManager.delegate(app, '.interactive-element', 'touchstart', function(e) {
                    this.classList.add('active');
                }, { passive: true });

                EventManager.delegate(app, '.interactive-element', 'touchend', function(e) {
                    setTimeout(() => this.classList.remove('active'), 150);
                }, { passive: true });
            }
        }

        // Optimize SVG rendering for smooth animations
        function optimizeSVGRendering() {
            document.querySelectorAll('svg').forEach(svg => {
                // Enable hardware acceleration
                svg.style.willChange = 'transform';
                svg.style.transform = 'translateZ(0)';
                
                // Optimize rendering
                svg.style.shapeRendering = 'optimizeSpeed';
                svg.style.textRendering = 'optimizeSpeed';
                
                // Add viewport optimization
                if (!svg.getAttribute('viewBox')) {
                    const width = svg.getAttribute('width') || '100%';
                    const height = svg.getAttribute('height') || '100%';
                    if (width !== '100%' && height !== '100%') {
                        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    }
                }
            });
        }

        // Clean up module instances for better memory management
        function cleanupModuleInstances() {
            // Cancel any running animations
            if (window.currentAnimation) {
                cancelAnimationFrame(window.currentAnimation);
                window.currentAnimation = null;
            }

            // Clear any active timers
            if (window.activeTimers) {
                window.activeTimers.forEach(timer => clearTimeout(timer));
                window.activeTimers = [];
            }

            // Remove any temporary event listeners
            document.querySelectorAll('.temp-listener').forEach(element => {
                element.remove();
            });

            // Clean up all module instances
            angleTriangleInstance = null;
            angleEvaluationInstance = null;
            circleElementsInstance = null;
            circleEvaluationInstance = null;
            piAnimationInstance = null;
            circumferenceCalculatorInstance = null;
            piEvaluationInstance = null;
            figureGameInstance = null;
            figureEvaluationInstance = null;
            linePositionInstance = null;
            linePositionEvaluationInstance = null;

            // Force garbage collection of SVG elements
            document.querySelectorAll('svg').forEach(svg => {
                if (svg.innerHTML) {
                    svg.innerHTML = '';
                }
            });

            // Clear any module-specific event listeners
            document.querySelectorAll('[data-module-listener]').forEach(element => {
                element.removeEventListener('click', element._moduleClickHandler);
                element.removeEventListener('touchstart', element._moduleTouchHandler);
                element.removeEventListener('mousedown', element._moduleMouseHandler);
                element.removeEventListener('mousemove', element._moduleMouseMoveHandler);
                element.removeEventListener('mouseup', element._moduleMouseUpHandler);
                element.removeEventListener('touchmove', element._moduleTouchMoveHandler);
                element.removeEventListener('touchend', element._moduleTouchEndHandler);
            });

            // Clear any drag operations
            if (window.isDragging) {
                window.isDragging = false;
                window.dragVertex = null;
            }

            console.log('‚úÖ Module instances cleaned up successfully');
        }

        // Render module cards in home view with enhanced animations
        function renderModuleCards() {
            const container = document.querySelector('#homeView .grid');
            container.innerHTML = '';

            Object.keys(content).forEach((moduleId, index) => {
                const module = content[moduleId];
                const card = document.createElement('div');
                card.className = `module-card ${module.color} text-white p-4 sm:p-6 rounded-lg shadow-lg cursor-pointer interactive-element touch-target`;
                card.dataset.moduleId = moduleId; // Store module ID for event delegation
                card.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">${module.title}</h3>
                    <p class="text-sm opacity-90">${module.description}</p>
                    <div class="mt-3 text-xs opacity-75">Toca para explorar ‚Üí</div>
                `;
                
                // Add staggered animation
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                card.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
                
                container.appendChild(card);
                
                // Animate card appearance with stagger
                setTimeout(() => {
                    card.style.opacity = '1';
                    card.style.transform = 'translateY(0)';
                }, index * 100 + 100);
            });

            // Use event delegation for module card clicks (better performance)
            EventManager.delegate(container, '.module-card', 'click', function(e) {
                const moduleId = this.dataset.moduleId;
                const module = content[moduleId];
                
                // Add visual feedback
                addVisualFeedback(this, 'success');
                animateButtonPress(this);
                
                // Show loading notification
                showNotification(`Cargando ${module.title}...`, 'info', 2000);
                
                // Load content with delay for visual feedback
                setTimeout(() => {
                    loadTopicContent(moduleId);
                }, 200);
            });
        }

        // Load topic content function
        function loadTopicContent(moduleId) {
            currentModule = moduleId;
            const module = content[moduleId];

            // Update module title
            document.getElementById('moduleTitle').textContent = module.title;

            // Reset to theory tab
            currentTab = 'teoria';
            updateTabButtons();

            // Load content
            loadTabContent();

            // Show module view
            showView('moduleView');
        }

        // Load content for current tab
        function loadTabContent() {
            const contentArea = document.getElementById('moduleContent');
            const module = content[currentModule];

            // Clean up previous interactive instances and optimize memory
            cleanupModuleInstances();

            // Show loading state with animation
            const clearLoading = showLoadingState(contentArea, 'Cargando contenido...');
            
            // Add fade out animation
            contentArea.style.opacity = '0';
            contentArea.style.transform = 'translateY(10px)';
            
            setTimeout(() => {
                // Load content
                if (currentTab === 'evaluacion' && typeof module[currentTab] === 'function') {
                    contentArea.innerHTML = module[currentTab]();
                } else {
                    contentArea.innerHTML = module[currentTab];
                }
                
                clearLoading();
                
                // Add fade in animation
                contentArea.style.transition = 'opacity 0.3s ease-in-out, transform 0.3s ease-in-out';
                contentArea.style.opacity = '1';
                contentArea.style.transform = 'translateY(0)';
                
                // Add content fade-in class
                contentArea.classList.add('content-fade-in');
                
                // Clean up animation classes
                setTimeout(() => {
                    contentArea.style.transition = '';
                    contentArea.classList.remove('content-fade-in');
                }, 300);
                
                // Show success notification
                showNotification(`Contenido de ${currentTab} cargado`, 'success', 2000);
                
            }, 200);

            // Initialize interactive elements based on current module and tab
            setTimeout(() => {
                try {
                    initializeModuleContent(currentModule, currentTab);
                } catch (error) {
                    console.error(`‚ùå Error initializing ${currentModule} - ${currentTab}:`, error);
                    showNotification(`Error al cargar el contenido interactivo`, 'error', 3000);
                }
            }, 100);
        }

        // Centralized module initialization with error handling
        function initializeModuleContent(moduleId, tab) {
            console.log(`üîÑ Initializing ${moduleId} - ${tab}`);
            
            const initializationMap = {
                'suma-angulos': {
                    'practica': () => {
                        if (!angleTriangleInstance) {
                            initAngleTriangle();
                            console.log('‚úÖ Angle Triangle initialized');
                        }
                    },
                    'evaluacion': () => {
                        if (!angleEvaluationInstance) {
                            initAngleEvaluation();
                            console.log('‚úÖ Angle Evaluation initialized');
                        }
                    }
                },
                'circunferencia': {
                    'practica': () => {
                        if (!circleElementsInstance) {
                            initCircleElements();
                            console.log('‚úÖ Circle Elements initialized');
                        }
                    },
                    'evaluacion': () => {
                        if (!circleEvaluationInstance) {
                            initCircleEvaluation();
                            console.log('‚úÖ Circle Evaluation initialized');
                        }
                    }
                },
                'numero-pi': {
                    'practica': () => {
                        if (!piAnimationInstance || !circumferenceCalculatorInstance) {
                            initPiModule();
                            console.log('‚úÖ Pi Module initialized');
                        }
                    },
                    'evaluacion': () => {
                        if (!piEvaluationInstance) {
                            initPiEvaluation();
                            console.log('‚úÖ Pi Evaluation initialized');
                        }
                    }
                },
                'circulo-figuras': {
                    'practica': () => {
                        if (!figureGameInstance) {
                            initFigureGame();
                            console.log('‚úÖ Figure Game initialized');
                        }
                    },
                    'evaluacion': () => {
                        if (!figureEvaluationInstance) {
                            initFigureEvaluation();
                            console.log('‚úÖ Figure Evaluation initialized');
                        }
                    }
                },
                'posiciones-rectas': {
                    'practica': () => {
                        if (!linePositionInstance) {
                            initLinePosition();
                            console.log('‚úÖ Line Position initialized');
                        }
                    },
                    'evaluacion': () => {
                        if (!linePositionEvaluationInstance) {
                            initLinePositionEvaluation();
                            console.log('‚úÖ Line Position Evaluation initialized');
                        }
                    }
                }
            };

            const moduleInitializers = initializationMap[moduleId];
            if (moduleInitializers && moduleInitializers[tab]) {
                try {
                    moduleInitializers[tab]();
                    
                    // Verify initialization was successful
                    setTimeout(() => {
                        verifyModuleInitialization(moduleId, tab);
                    }, 200);
                } catch (error) {
                    console.error(`‚ùå Failed to initialize ${moduleId} - ${tab}:`, error);
                    throw error;
                }
            } else {
                console.warn(`‚ö†Ô∏è No initializer found for ${moduleId} - ${tab}`);
            }
        }

        // Verify that module components were properly initialized
        function verifyModuleInitialization(moduleId, tab) {
            const verificationMap = {
                'suma-angulos': {
                    'practica': () => {
                        const svg = document.getElementById('angleSvg');
                        const toggleBtn = document.getElementById('toggleShape');
                        const display = document.getElementById('angleDisplay');
                        
                        if (!svg || !toggleBtn || !display) {
                            throw new Error('Missing required DOM elements for angle triangle');
                        }
                        
                        if (!angleTriangleInstance) {
                            throw new Error('Angle triangle instance not created');
                        }
                        
                        return true;
                    },
                    'evaluacion': () => {
                        const container = document.getElementById('questionContainer');
                        if (!container) {
                            throw new Error('Missing question container for angle evaluation');
                        }
                        return angleEvaluationInstance !== null;
                    }
                },
                'circunferencia': {
                    'practica': () => {
                        const svg = document.getElementById('circleSvg');
                        const label = document.getElementById('elementLabel');
                        
                        if (!svg || !label) {
                            throw new Error('Missing required DOM elements for circle elements');
                        }
                        
                        return circleElementsInstance !== null;
                    },
                    'evaluacion': () => {
                        const container = document.getElementById('questionContainer');
                        if (!container) {
                            throw new Error('Missing question container for circle evaluation');
                        }
                        return circleEvaluationInstance !== null;
                    }
                },
                'numero-pi': {
                    'practica': () => {
                        const animationSvg = document.getElementById('piAnimationSvg');
                        const playBtn = document.getElementById('playAnimation');
                        const radiusInput = document.getElementById('radiusInput');
                        
                        if (!animationSvg || !playBtn || !radiusInput) {
                            throw new Error('Missing required DOM elements for pi module');
                        }
                        
                        return piAnimationInstance !== null && circumferenceCalculatorInstance !== null;
                    },
                    'evaluacion': () => {
                        const container = document.getElementById('questionContainer');
                        if (!container) {
                            throw new Error('Missing question container for pi evaluation');
                        }
                        return piEvaluationInstance !== null;
                    }
                },
                'circulo-figuras': {
                    'practica': () => {
                        const svg = document.getElementById('figureGameSvg');
                        const options = document.getElementById('gameOptions');
                        const score = document.getElementById('gameScore');
                        
                        if (!svg || !options || !score) {
                            throw new Error('Missing required DOM elements for figure game');
                        }
                        
                        return figureGameInstance !== null;
                    },
                    'evaluacion': () => {
                        const container = document.getElementById('questionContainer');
                        if (!container) {
                            throw new Error('Missing question container for figure evaluation');
                        }
                        return figureEvaluationInstance !== null;
                    }
                },
                'posiciones-rectas': {
                    'practica': () => {
                        const svg = document.getElementById('linePositionSvg');
                        const status = document.getElementById('positionStatus');
                        
                        if (!svg || !status) {
                            throw new Error('Missing required DOM elements for line position');
                        }
                        
                        return linePositionInstance !== null;
                    },
                    'evaluacion': () => {
                        const container = document.getElementById('questionContainer');
                        if (!container) {
                            throw new Error('Missing question container for line position evaluation');
                        }
                        return linePositionEvaluationInstance !== null;
                    }
                }
            };

            const moduleVerifiers = verificationMap[moduleId];
            if (moduleVerifiers && moduleVerifiers[tab]) {
                try {
                    const isValid = moduleVerifiers[tab]();
                    if (isValid) {
                        console.log(`‚úÖ ${moduleId} - ${tab} verification passed`);
                        showNotification(`Contenido interactivo cargado correctamente`, 'success', 2000);
                    } else {
                        console.warn(`‚ö†Ô∏è ${moduleId} - ${tab} verification failed`);
                        showNotification(`Advertencia: Algunos elementos interactivos pueden no funcionar`, 'error', 3000);
                    }
                } catch (error) {
                    console.error(`‚ùå ${moduleId} - ${tab} verification error:`, error);
                    showNotification(`Error: ${error.message}`, 'error', 4000);
                }
            }
        }

        // Update tab button states with animation
        function updateTabButtons() {
            document.querySelectorAll('.tab-button').forEach(button => {
                const wasActive = button.classList.contains('active');
                button.classList.remove('active');
                
                if (button.dataset.tab === currentTab) {
                    // Add loading state briefly
                    button.classList.add('loading');
                    
                    setTimeout(() => {
                        button.classList.add('active');
                        button.classList.remove('loading');
                        
                        // Add visual feedback for tab change
                        if (!wasActive) {
                            addVisualFeedback(button, 'success');
                        }
                    }, 150);
                }
            });
        }

        // Show specific view with smooth transition
        function showView(viewName) {
            const currentView = document.querySelector('.view.active');
            const targetView = document.getElementById(viewName);
            
            if (currentView === targetView) return;
            
            console.log(`üîÑ Transitioning from ${currentView?.id || 'none'} to ${viewName}`);
            
            // Clean up current module when leaving module view
            if (currentView && currentView.id === 'moduleView' && viewName === 'homeView') {
                console.log('üßπ Cleaning up module view');
                cleanupModuleInstances();
                currentModule = null;
                currentTab = 'teoria';
            }
            
            // Add loading state
            if (targetView) {
                targetView.classList.add('loading');
            }
            
            // Fade out current view with proper cleanup
            if (currentView) {
                currentView.style.opacity = '0';
                currentView.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    currentView.classList.remove('active');
                    currentView.style.opacity = '';
                    currentView.style.transform = '';
                }, 150);
            }
            
            // Small delay for smooth transition
            setTimeout(() => {
                if (targetView) {
                    targetView.style.opacity = '0';
                    targetView.style.transform = 'translateY(10px)';
                    targetView.classList.add('active');
                    targetView.classList.remove('loading');
                    
                    // Animate in
                    setTimeout(() => {
                        targetView.style.transition = 'opacity 0.3s ease-in-out, transform 0.3s ease-in-out';
                        targetView.style.opacity = '1';
                        targetView.style.transform = 'translateY(0)';
                        
                        // Clean up styles after animation
                        setTimeout(() => {
                            targetView.style.transition = '';
                            targetView.style.opacity = '';
                            targetView.style.transform = '';
                        }, 300);
                    }, 50);
                    
                    // Initialize view-specific content
                    if (viewName === 'homeView') {
                        // Ensure module cards are rendered
                        if (!document.querySelector('.module-card')) {
                            renderModuleCards();
                        }
                        console.log('‚úÖ Home view activated');
                    } else if (viewName === 'moduleView') {
                        // Ensure module content is properly loaded
                        if (currentModule) {
                            updateTabButtons();
                            loadTabContent();
                        }
                        console.log(`‚úÖ Module view activated for ${currentModule}`);
                    }
                }
            }, currentView ? 150 : 0);
        }

        // Notification system for user feedback
        function showNotification(message, type = 'info', duration = 3000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => notification.remove());
            
            // Create new notification
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Show notification with animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            
            // Hide notification after duration
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }, duration);
        }

        // Add visual feedback to interactive elements
        function addVisualFeedback(element, type = 'success') {
            element.classList.add(`feedback-${type}`);
            setTimeout(() => {
                element.classList.remove(`feedback-${type}`);
            }, 600);
        }

        // Highlight SVG elements with animation
        function highlightSVGElement(element) {
            element.classList.add('svg-element-highlight');
            setTimeout(() => {
                element.classList.remove('svg-element-highlight');
            }, 1000);
        }

        // Enhanced button press animation
        function animateButtonPress(button) {
            button.style.transform = 'scale(0.95)';
            button.style.transition = 'transform 0.1s ease-in-out';
            
            setTimeout(() => {
                button.style.transform = 'scale(1)';
                setTimeout(() => {
                    button.style.transform = '';
                    button.style.transition = '';
                }, 100);
            }, 100);
        }

        // Loading state management
        function showLoadingState(element, text = 'Cargando...') {
            const originalContent = element.innerHTML;
            element.dataset.originalContent = originalContent;
            
            element.innerHTML = `
                <div class="flex items-center justify-center space-x-2">
                    <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>${text}</span>
                </div>
            `;
            element.classList.add('loading');
            
            return () => {
                element.innerHTML = originalContent;
                element.classList.remove('loading');
                delete element.dataset.originalContent;
            };
        }

        // Progress bar animation
        function animateProgressBar(container, progress, duration = 1000) {
            let progressBar = container.querySelector('.progress-bar');
            if (!progressBar) {
                progressBar = document.createElement('div');
                progressBar.className = 'progress-bar mb-4';
                progressBar.innerHTML = '<div class="progress-fill" style="width: 0%"></div>';
                container.insertBefore(progressBar, container.firstChild);
            }
            
            const progressFill = progressBar.querySelector('.progress-fill');
            
            // Animate to target progress
            setTimeout(() => {
                progressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
            }, 50);
            
            // Remove progress bar after animation
            if (progress >= 100) {
                setTimeout(() => {
                    progressBar.style.opacity = '0';
                    setTimeout(() => {
                        if (progressBar.parentNode) {
                            progressBar.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        // Enhanced hover effects for interactive elements
        function enhanceInteractiveElements() {
            document.querySelectorAll('.interactive-element').forEach(element => {
                // Add ripple effect on click
                element.addEventListener('click', function(e) {
                    const ripple = document.createElement('span');
                    const rect = this.getBoundingClientRect();
                    const size = Math.max(rect.width, rect.height);
                    const x = e.clientX - rect.left - size / 2;
                    const y = e.clientY - rect.top - size / 2;
                    
                    ripple.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        left: ${x}px;
                        top: ${y}px;
                        background: rgba(255, 255, 255, 0.6);
                        border-radius: 50%;
                        transform: scale(0);
                        animation: ripple 0.6s linear;
                        pointer-events: none;
                    `;
                    
                    // Ensure element has relative positioning for ripple
                    const originalPosition = this.style.position;
                    if (!originalPosition || originalPosition === 'static') {
                        this.style.position = 'relative';
                    }
                    this.style.overflow = 'hidden';
                    
                    this.appendChild(ripple);
                    
                    setTimeout(() => {
                        ripple.remove();
                    }, 600);
                });
                
                // Enhanced button press animation
                element.addEventListener('mousedown', function() {
                    animateButtonPress(this);
                });
                
                element.addEventListener('touchstart', function() {
                    animateButtonPress(this);
                });
            });
        }

        // Add ripple animation CSS
        const rippleStyle = document.createElement('style');
        rippleStyle.textContent = `
            @keyframes ripple {
                to {
                    transform: scale(4);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(rippleStyle);

        // Setup event listeners
        function setupEventListeners() {
            // Back button
            document.getElementById('backButton').addEventListener('click', () => {
                showView('homeView');
                currentModule = null;
            });

            // Tab buttons with enhanced navigation
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    const newTab = button.dataset.tab;
                    if (newTab === currentTab) return; // No change needed
                    
                    console.log(`üîÑ Switching from ${currentTab} to ${newTab} in ${currentModule}`);
                    
                    // Add visual feedback
                    addVisualFeedback(button, 'success');
                    
                    // Clean up current tab content before switching
                    cleanupModuleInstances();
                    
                    currentTab = newTab;
                    updateTabButtons();
                    loadTabContent();
                });
            });
        }

        // Interactive Triangle for Suma de √Ångulos module
        class AngleTriangle {
            constructor(svgElement) {
                this.svg = svgElement;
                this.isQuadrilateral = false;
                this.isDragging = false;
                this.dragVertex = null;

                // Initial triangle vertices
                this.vertices = [
                    { x: 250, y: 100, id: 'A' },
                    { x: 150, y: 300, id: 'B' },
                    { x: 350, y: 300, id: 'C' }
                ];

                this.angles = [0, 0, 0];
                this.init();
            }

            init() {
                this.render();
                this.calculateAngles();
                this.updateDisplay();
                this.setupEventListeners();
            }

            render() {
                this.svg.innerHTML = '';

                // Draw triangle/quadrilateral
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData = `M ${this.vertices[0].x} ${this.vertices[0].y}`;

                for (let i = 1; i < this.vertices.length; i++) {
                    pathData += ` L ${this.vertices[i].x} ${this.vertices[i].y}`;
                }
                pathData += ' Z';

                path.setAttribute('d', pathData);
                path.setAttribute('fill', 'rgba(59, 130, 246, 0.3)');
                path.setAttribute('stroke', '#3B82F6');
                path.setAttribute('stroke-width', '2');
                this.svg.appendChild(path);

                // Draw vertices
                this.vertices.forEach((vertex, index) => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', vertex.x);
                    circle.setAttribute('cy', vertex.y);
                    circle.setAttribute('r', window.innerWidth <= 768 ? '12' : '8');
                    circle.setAttribute('fill', '#EF4444');
                    circle.setAttribute('stroke', '#DC2626');
                    circle.setAttribute('stroke-width', window.innerWidth <= 768 ? '4' : '2');
                    circle.setAttribute('cursor', 'grab');
                    circle.setAttribute('data-vertex', index);
                    circle.setAttribute('class', 'draggable-vertex');
                    this.svg.appendChild(circle);

                    // Add vertex labels
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', vertex.x + 15);
                    text.setAttribute('y', vertex.y - 10);
                    text.setAttribute('fill', '#1F2937');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = vertex.id;
                    this.svg.appendChild(text);
                });

                // Draw angle arcs and labels
                this.drawAngleArcs();
            }

            drawAngleArcs() {
                this.vertices.forEach((vertex, index) => {
                    const angle = this.angles[index];
                    if (angle > 0) {
                        // Create angle arc
                        const arc = this.createAngleArc(vertex, index, angle);
                        if (arc) this.svg.appendChild(arc);

                        // Add angle label
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        const labelPos = this.getAngleLabelPosition(vertex, index);
                        label.setAttribute('x', labelPos.x);
                        label.setAttribute('y', labelPos.y);
                        label.setAttribute('fill', '#059669');
                        label.setAttribute('font-size', '12');
                        label.setAttribute('font-weight', 'bold');
                        label.setAttribute('text-anchor', 'middle');
                        label.textContent = `${Math.round(angle)}¬∞`;
                        this.svg.appendChild(label);
                    }
                });
            }

            createAngleArc(vertex, vertexIndex, angle) {
                const radius = 30;
                const prevVertex = this.vertices[(vertexIndex - 1 + this.vertices.length) % this.vertices.length];
                const nextVertex = this.vertices[(vertexIndex + 1) % this.vertices.length];

                // Calculate vectors
                const v1 = { x: prevVertex.x - vertex.x, y: prevVertex.y - vertex.y };
                const v2 = { x: nextVertex.x - vertex.x, y: nextVertex.y - vertex.y };

                // Calculate angles
                const angle1 = Math.atan2(v1.y, v1.x);
                const angle2 = Math.atan2(v2.y, v2.x);

                // Calculate arc points
                const startX = vertex.x + radius * Math.cos(angle1);
                const startY = vertex.y + radius * Math.sin(angle1);
                const endX = vertex.x + radius * Math.cos(angle2);
                const endY = vertex.y + radius * Math.sin(angle2);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const largeArcFlag = angle > 180 ? 1 : 0;
                const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;

                path.setAttribute('d', pathData);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#059669');
                path.setAttribute('stroke-width', '2');

                return path;
            }

            getAngleLabelPosition(vertex, vertexIndex) {
                const radius = 40;
                const prevVertex = this.vertices[(vertexIndex - 1 + this.vertices.length) % this.vertices.length];
                const nextVertex = this.vertices[(vertexIndex + 1) % this.vertices.length];

                // Calculate bisector direction
                const v1 = { x: prevVertex.x - vertex.x, y: prevVertex.y - vertex.y };
                const v2 = { x: nextVertex.x - vertex.x, y: nextVertex.y - vertex.y };

                // Normalize vectors
                const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                v1.x /= len1; v1.y /= len1;
                v2.x /= len2; v2.y /= len2;

                // Bisector direction
                const bisector = { x: v1.x + v2.x, y: v1.y + v2.y };
                const bisectorLen = Math.sqrt(bisector.x * bisector.x + bisector.y * bisector.y);
                if (bisectorLen > 0) {
                    bisector.x /= bisectorLen;
                    bisector.y /= bisectorLen;
                }

                return {
                    x: vertex.x + radius * bisector.x,
                    y: vertex.y + radius * bisector.y
                };
            }

            calculateAngles() {
                for (let i = 0; i < this.vertices.length; i++) {
                    const current = this.vertices[i];
                    const prev = this.vertices[(i - 1 + this.vertices.length) % this.vertices.length];
                    const next = this.vertices[(i + 1) % this.vertices.length];

                    // Calculate vectors
                    const v1 = { x: prev.x - current.x, y: prev.y - current.y };
                    const v2 = { x: next.x - current.x, y: next.y - current.y };

                    // Calculate angle using dot product and cross product
                    const dot = v1.x * v2.x + v1.y * v2.y;
                    const cross = v1.x * v2.y - v1.y * v2.x;
                    let angle = Math.atan2(cross, dot) * (180 / Math.PI);

                    // Ensure positive angle
                    if (angle < 0) angle += 360;
                    if (angle > 180) angle = 360 - angle;

                    this.angles[i] = angle;
                }
            }

            updateDisplay() {
                const displayContainer = document.getElementById('angleDisplay');
                if (!displayContainer) return;

                const totalAngles = this.isQuadrilateral ? 4 : 3;
                const expectedSum = this.isQuadrilateral ? 360 : 180;
                const actualSum = this.angles.slice(0, totalAngles).reduce((sum, angle) => sum + angle, 0);

                displayContainer.innerHTML = '';

                // Create angle displays
                for (let i = 0; i < totalAngles; i++) {
                    const angleDiv = document.createElement('div');
                    angleDiv.className = 'bg-white p-4 rounded-lg border-2 border-blue-200';
                    angleDiv.innerHTML = `
                        <div class="text-lg font-bold text-blue-600">√Ångulo ${this.vertices[i].id}</div>
                        <div class="text-2xl font-bold text-gray-800">${Math.round(this.angles[i])}¬∞</div>
                    `;
                    displayContainer.appendChild(angleDiv);
                }

                // Add sum display
                const sumDiv = document.createElement('div');
                sumDiv.className = 'bg-green-50 p-4 rounded-lg border-2 border-green-200 md:col-span-3';
                sumDiv.innerHTML = `
                    <div class="text-lg font-bold text-green-600">Suma Total</div>
                    <div class="text-2xl font-bold text-gray-800">${Math.round(actualSum)}¬∞</div>
                    <div class="text-sm text-gray-600">Esperado: ${expectedSum}¬∞</div>
                `;
                displayContainer.appendChild(sumDiv);
            }

            setupEventListeners() {
                let startX, startY;

                // Debounced update function for smooth performance
                const debouncedUpdate = PerformanceUtils.debounce(() => {
                    this.calculateAngles();
                    this.render();
                    this.updateDisplay();
                }, 16); // ~60fps

                // Throttled drag handler for better performance
                const throttledDrag = PerformanceUtils.throttle((newX, newY) => {
                    // Constrain to SVG bounds
                    const constrainedX = Math.max(20, Math.min(480, newX));
                    const constrainedY = Math.max(20, Math.min(380, newY));

                    this.vertices[this.dragVertex].x = constrainedX;
                    this.vertices[this.dragVertex].y = constrainedY;

                    // Use requestAnimationFrame for smooth updates
                    PerformanceUtils.requestAnimationFrame(() => {
                        this.calculateAngles();
                        this.render();
                        this.updateDisplay();
                    });
                }, 16);

                this.svg.addEventListener('mousedown', (e) => {
                    const target = e.target;
                    if (target.hasAttribute('data-vertex')) {
                        this.isDragging = true;
                        this.dragVertex = parseInt(target.getAttribute('data-vertex'));
                        startX = e.clientX;
                        startY = e.clientY;
                        target.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.dragVertex !== null) {
                        const rect = this.svg.getBoundingClientRect();
                        const scaleX = this.svg.viewBox.baseVal.width / rect.width;
                        const scaleY = this.svg.viewBox.baseVal.height / rect.height;

                        const newX = (e.clientX - rect.left) * scaleX;
                        const newY = (e.clientY - rect.top) * scaleY;

                        throttledDrag(newX, newY);
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.dragVertex = null;
                        this.svg.style.cursor = 'default';
                    }
                });

                // Touch events for mobile with passive listeners where possible
                this.svg.addEventListener('touchstart', (e) => {
                    const target = e.target;
                    if (target.hasAttribute('data-vertex')) {
                        this.isDragging = true;
                        this.dragVertex = parseInt(target.getAttribute('data-vertex'));
                        const touch = e.touches[0];
                        startX = touch.clientX;
                        startY = touch.clientY;
                        e.preventDefault();
                    }
                });

                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging && this.dragVertex !== null) {
                        const touch = e.touches[0];
                        const rect = this.svg.getBoundingClientRect();
                        const scaleX = this.svg.viewBox.baseVal.width / rect.width;
                        const scaleY = this.svg.viewBox.baseVal.height / rect.height;

                        const newX = (touch.clientX - rect.left) * scaleX;
                        const newY = (touch.clientY - rect.top) * scaleY;

                        throttledDrag(newX, newY);
                        e.preventDefault();
                    }
                });

                document.addEventListener('touchend', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.dragVertex = null;
                    }
                });
            }

            toggleShape() {
                this.isQuadrilateral = !this.isQuadrilateral;

                if (this.isQuadrilateral) {
                    // Add fourth vertex
                    this.vertices.push({ x: 400, y: 150, id: 'D' });
                    this.angles.push(0);
                } else {
                    // Remove fourth vertex
                    this.vertices = this.vertices.slice(0, 3);
                    this.angles = this.angles.slice(0, 3);
                }

                this.calculateAngles();
                this.render();
                this.updateDisplay();
            }

            // Testing integration method using automated testing utilities
            validateCalculations() {
                if (typeof AutomatedTestRunner !== 'undefined') {
                    return AutomatedTestRunner.validateAngleTriangleCalculations(this);
                } else {
                    console.warn('AutomatedTestRunner not available');
                    return { success: false, error: 'Testing utilities not loaded' };
                }
            }

            // Method to test drag operations using mock utilities
            testDragOperation(startVertex, endPosition) {
                if (typeof MockInteractionUtils !== 'undefined') {
                    const startPos = this.vertices[startVertex];
                    const mockDragHandler = (event) => {
                        // Simulate the drag handling logic
                        if (event.type === 'mousedown' || event.type === 'touchstart') {
                            this.isDragging = true;
                            this.dragVertex = startVertex;
                        } else if (event.type === 'mousemove' || event.type === 'touchmove') {
                            if (this.isDragging && this.dragVertex === startVertex) {
                                this.vertices[startVertex] = { 
                                    x: event.clientX || event.touches[0].clientX, 
                                    y: event.clientY || event.touches[0].clientY,
                                    id: this.vertices[startVertex].id
                                };
                                this.calculateAngles();
                            }
                        } else if (event.type === 'mouseup' || event.type === 'touchend') {
                            this.isDragging = false;
                            this.dragVertex = null;
                        }
                    };

                    return MockInteractionUtils.testDragInteraction(mockDragHandler, startPos, endPosition);
                } else {
                    console.warn('MockInteractionUtils not available');
                    return { success: false, error: 'Mock interaction utilities not loaded' };
                }
            }
        }

        // Interactive Circle Elements for Circunferencia module
        class CircleElements {
            constructor(svgElement) {
                this.svg = svgElement;
                this.center = { x: 250, y: 200 };
                this.radius = 80;
                this.elements = {
                    center: { color: '#EF4444', label: 'Centro', description: 'Punto interior equidistante de todos los puntos de la circunferencia' },
                    radius: { color: '#10B981', label: 'Radio', description: 'Segmento que une el centro con cualquier punto de la circunferencia' },
                    diameter: { color: '#3B82F6', label: 'Di√°metro', description: 'Segmento que pasa por el centro y une dos puntos de la circunferencia' },
                    chord: { color: '#F59E0B', label: 'Cuerda', description: 'Segmento que une dos puntos cualesquiera de la circunferencia' },
                    arc: { color: '#8B5CF6', label: 'Arco', description: 'Porci√≥n de la circunferencia comprendida entre dos puntos' },
                    tangent: { color: '#06B6D4', label: 'Tangente', description: 'Recta que toca la circunferencia en un solo punto' }
                };
                this.currentHighlight = null;
                this.init();
            }

            init() {
                this.render();
                this.setupEventListeners();
            }

            render() {
                this.svg.innerHTML = '';

                // Draw main circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', this.center.x);
                circle.setAttribute('cy', this.center.y);
                circle.setAttribute('r', this.radius);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#6B7280');
                circle.setAttribute('stroke-width', '2');
                this.svg.appendChild(circle);

                // Draw center point
                const centerPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                centerPoint.setAttribute('cx', this.center.x);
                centerPoint.setAttribute('cy', this.center.y);
                centerPoint.setAttribute('r', '4');
                centerPoint.setAttribute('fill', this.elements.center.color);
                centerPoint.setAttribute('cursor', 'pointer');
                centerPoint.setAttribute('data-element', 'center');
                this.svg.appendChild(centerPoint);

                // Draw radius
                const radiusLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                radiusLine.setAttribute('x1', this.center.x);
                radiusLine.setAttribute('y1', this.center.y);
                radiusLine.setAttribute('x2', this.center.x + this.radius);
                radiusLine.setAttribute('y2', this.center.y);
                radiusLine.setAttribute('stroke', this.elements.radius.color);
                radiusLine.setAttribute('stroke-width', '3');
                radiusLine.setAttribute('cursor', 'pointer');
                radiusLine.setAttribute('data-element', 'radius');
                this.svg.appendChild(radiusLine);

                // Draw diameter
                const diameterLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                diameterLine.setAttribute('x1', this.center.x - this.radius);
                diameterLine.setAttribute('y1', this.center.y + 30);
                diameterLine.setAttribute('x2', this.center.x + this.radius);
                diameterLine.setAttribute('y2', this.center.y + 30);
                diameterLine.setAttribute('stroke', this.elements.diameter.color);
                diameterLine.setAttribute('stroke-width', '3');
                diameterLine.setAttribute('cursor', 'pointer');
                diameterLine.setAttribute('data-element', 'diameter');
                this.svg.appendChild(diameterLine);

                // Draw chord
                const chordLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const chordAngle1 = Math.PI / 4; // 45 degrees
                const chordAngle2 = (3 * Math.PI) / 4; // 135 degrees
                const chord1X = this.center.x + this.radius * Math.cos(chordAngle1);
                const chord1Y = this.center.y + this.radius * Math.sin(chordAngle1);
                const chord2X = this.center.x + this.radius * Math.cos(chordAngle2);
                const chord2Y = this.center.y + this.radius * Math.sin(chordAngle2);

                chordLine.setAttribute('x1', chord1X);
                chordLine.setAttribute('y1', chord1Y);
                chordLine.setAttribute('x2', chord2X);
                chordLine.setAttribute('y2', chord2Y);
                chordLine.setAttribute('stroke', this.elements.chord.color);
                chordLine.setAttribute('stroke-width', '3');
                chordLine.setAttribute('cursor', 'pointer');
                chordLine.setAttribute('data-element', 'chord');
                this.svg.appendChild(chordLine);

                // Draw arc (highlighted portion of circle)
                const arcPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const arcStartAngle = -Math.PI / 3; // -60 degrees
                const arcEndAngle = Math.PI / 6; // 30 degrees
                const arcStartX = this.center.x + this.radius * Math.cos(arcStartAngle);
                const arcStartY = this.center.y + this.radius * Math.sin(arcStartAngle);
                const arcEndX = this.center.x + this.radius * Math.cos(arcEndAngle);
                const arcEndY = this.center.y + this.radius * Math.sin(arcEndAngle);

                const arcPathData = `M ${arcStartX} ${arcStartY} A ${this.radius} ${this.radius} 0 0 1 ${arcEndX} ${arcEndY}`;
                arcPath.setAttribute('d', arcPathData);
                arcPath.setAttribute('fill', 'none');
                arcPath.setAttribute('stroke', this.elements.arc.color);
                arcPath.setAttribute('stroke-width', '4');
                arcPath.setAttribute('cursor', 'pointer');
                arcPath.setAttribute('data-element', 'arc');
                this.svg.appendChild(arcPath);

                // Draw tangent line
                const tangentLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const tangentPointX = this.center.x;
                const tangentPointY = this.center.y - this.radius;
                tangentLine.setAttribute('x1', tangentPointX - 60);
                tangentLine.setAttribute('y1', tangentPointY);
                tangentLine.setAttribute('x2', tangentPointX + 60);
                tangentLine.setAttribute('y2', tangentPointY);
                tangentLine.setAttribute('stroke', this.elements.tangent.color);
                tangentLine.setAttribute('stroke-width', '3');
                tangentLine.setAttribute('cursor', 'pointer');
                tangentLine.setAttribute('data-element', 'tangent');
                this.svg.appendChild(tangentLine);

                // Add element labels (initially hidden)
                Object.keys(this.elements).forEach(elementName => {
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('id', `label-${elementName}`);
                    label.setAttribute('fill', this.elements[elementName].color);
                    label.setAttribute('font-size', '12');
                    label.setAttribute('font-weight', 'bold');
                    label.setAttribute('opacity', '0');
                    label.setAttribute('pointer-events', 'none');
                    label.textContent = this.elements[elementName].label;
                    this.svg.appendChild(label);
                });
            }

            setupEventListeners() {
                // Add hover/touch events to all interactive elements
                const interactiveElements = this.svg.querySelectorAll('[data-element]');

                interactiveElements.forEach(element => {
                    // Mouse events
                    element.addEventListener('mouseenter', (e) => this.highlightElement(e.target.dataset.element));
                    element.addEventListener('mouseleave', () => this.clearHighlight());

                    // Touch events for mobile
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.highlightElement(e.target.dataset.element);
                    });
                });

                // Clear highlight when touching outside
                this.svg.addEventListener('touchstart', (e) => {
                    if (!e.target.dataset.element) {
                        this.clearHighlight();
                    }
                });
            }

            highlightElement(elementName) {
                this.clearHighlight();
                this.currentHighlight = elementName;

                // Highlight the element with enhanced animation
                const element = this.svg.querySelector(`[data-element="${elementName}"]`);
                if (element) {
                    element.style.filter = 'drop-shadow(0 0 12px rgba(59, 130, 246, 1))';
                    element.style.strokeWidth = '4';
                    element.style.transition = 'all 0.3s ease-in-out';
                    
                    // Add pulsing animation
                    element.classList.add('svg-element-highlight');
                    
                    // Scale animation for better visibility
                    const originalTransform = element.style.transform;
                    element.style.transform = 'scale(1.1)';
                    element.style.transformOrigin = 'center';
                    
                    setTimeout(() => {
                        element.style.transform = originalTransform;
                    }, 200);
                }

                // Show label with animation
                const label = this.svg.querySelector(`#label-${elementName}`);
                if (label) {
                    const labelPos = this.getLabelPosition(elementName);
                    label.setAttribute('x', labelPos.x);
                    label.setAttribute('y', labelPos.y);
                    label.style.transition = 'opacity 0.3s ease-in-out';
                    label.setAttribute('opacity', '1');
                }

                // Update description in the UI with animation
                this.updateElementDescription(elementName);
                
                // Show notification for element identification
                const elementInfo = this.elements[elementName];
                if (elementInfo) {
                    showNotification(`${elementInfo.label} identificado`, 'info', 1500);
                }
            }

            clearHighlight() {
                if (this.currentHighlight) {
                    // Remove highlight from element with smooth transition
                    const element = this.svg.querySelector(`[data-element="${this.currentHighlight}"]`);
                    if (element) {
                        element.style.transition = 'all 0.3s ease-in-out';
                        element.style.filter = '';
                        element.style.strokeWidth = element.tagName === 'circle' ? '' : '3';
                        element.style.transform = '';
                        element.classList.remove('svg-element-highlight');
                    }

                    // Hide label with animation
                    const label = this.svg.querySelector(`#label-${this.currentHighlight}`);
                    if (label) {
                        label.style.transition = 'opacity 0.3s ease-in-out';
                        label.setAttribute('opacity', '0');
                    }

                    this.currentHighlight = null;
                }

                // Reset description
                this.updateElementDescription(null);
            }

            getLabelPosition(elementName) {
                switch (elementName) {
                    case 'center':
                        return { x: this.center.x + 10, y: this.center.y - 10 };
                    case 'radius':
                        return { x: this.center.x + this.radius / 2, y: this.center.y - 10 };
                    case 'diameter':
                        return { x: this.center.x, y: this.center.y + 50 };
                    case 'chord':
                        return { x: this.center.x - 30, y: this.center.y - 30 };
                    case 'arc':
                        return { x: this.center.x + 60, y: this.center.y - 60 };
                    case 'tangent':
                        return { x: this.center.x + 70, y: this.center.y - this.radius - 10 };
                    default:
                        return { x: 0, y: 0 };
                }
            }

            updateElementDescription(elementName) {
                const labelElement = document.getElementById('elementLabel');
                if (labelElement) {
                    if (elementName && this.elements[elementName]) {
                        const element = this.elements[elementName];
                        labelElement.innerHTML = `
                            <p class="text-lg font-medium" style="color: ${element.color};">${element.label}</p>
                            <p class="text-sm text-gray-600 mt-1">${element.description}</p>
                        `;
                    } else {
                        labelElement.innerHTML = `
                            <p class="text-lg font-medium text-blue-800">Pasa el mouse sobre los elementos para identificarlos</p>
                        `;
                    }
                }
            }

            // Testing integration method for circle calculations
            validateCircleCalculations() {
                if (typeof AutomatedTestRunner !== 'undefined') {
                    const diameter = this.radius * 2;
                    const circumference = 2 * Math.PI * this.radius;
                    return AutomatedTestRunner.validateCircumferenceCalculations(this.radius, diameter, circumference);
                } else {
                    console.warn('AutomatedTestRunner not available');
                    return { success: false, error: 'Testing utilities not loaded' };
                }
            }

            // Method to test hover interactions using mock utilities
            testHoverInteraction(elementName) {
                if (typeof MockInteractionUtils !== 'undefined') {
                    const element = this.svg.querySelector(`[data-element="${elementName}"]`);
                    if (!element) {
                        return { success: false, error: `Element ${elementName} not found` };
                    }

                    const rect = element.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const mockHoverHandler = (event) => {
                        if (event.type === 'mouseenter') {
                            this.highlightElement(elementName);
                        } else if (event.type === 'mouseleave') {
                            this.clearHighlight();
                        }
                    };

                    // Simulate hover sequence
                    const hoverEvents = [
                        MockInteractionUtils.createMockMouseEvent('mouseenter', centerX, centerY, element),
                        MockInteractionUtils.createMockMouseEvent('mouseleave', centerX + 50, centerY + 50, null)
                    ];

                    try {
                        hoverEvents.forEach(event => mockHoverHandler(event));
                        return { 
                            success: true, 
                            elementName: elementName,
                            position: { x: centerX, y: centerY }
                        };
                    } catch (error) {
                        return { success: false, error: error.message };
                    }
                } else {
                    console.warn('MockInteractionUtils not available');
                    return { success: false, error: 'Mock interaction utilities not loaded' };
                }
            }
        }

        // Initialize circle elements when circunferencia practice tab is loaded
        let circleElementsInstance = null;

        function initCircleElements() {
            const svg = document.getElementById('circleSvg');

            if (svg && !circleElementsInstance) {
                circleElementsInstance = new CircleElements(svg);
            }
        }

        // Pi Animation Class for visualizing pi concept
        class PiAnimation {
            constructor(svgElement) {
                this.svg = svgElement;
                this.radius = 40;
                this.center = { x: 100, y: 150 };
                this.animationState = 'stopped';
                this.animationId = null;
                this.currentAngle = 0;
                this.unrolledLength = 0;
                this.trailPoints = [];
                this.init();
            }

            init() {
                this.render();
                this.setupEventListeners();
            }

            render() {
                this.svg.innerHTML = '';

                // Draw the circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', this.center.x);
                circle.setAttribute('cy', this.center.y);
                circle.setAttribute('r', this.radius);
                circle.setAttribute('fill', 'rgba(147, 51, 234, 0.2)');
                circle.setAttribute('stroke', '#9333EA');
                circle.setAttribute('stroke-width', '3');
                this.svg.appendChild(circle);

                // Draw diameter line
                const diameter = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                diameter.setAttribute('x1', this.center.x - this.radius);
                diameter.setAttribute('y1', this.center.y);
                diameter.setAttribute('x2', this.center.x + this.radius);
                diameter.setAttribute('y2', this.center.y);
                diameter.setAttribute('stroke', '#DC2626');
                diameter.setAttribute('stroke-width', '3');
                this.svg.appendChild(diameter);

                // Add diameter label
                const diameterLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                diameterLabel.setAttribute('x', this.center.x);
                diameterLabel.setAttribute('y', this.center.y + 15);
                diameterLabel.setAttribute('text-anchor', 'middle');
                diameterLabel.setAttribute('fill', '#DC2626');
                diameterLabel.setAttribute('font-size', '12');
                diameterLabel.setAttribute('font-weight', 'bold');
                diameterLabel.textContent = 'd';
                this.svg.appendChild(diameterLabel);

                // Draw unrolled line (initially empty)
                const unrolledLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                unrolledLine.setAttribute('id', 'unrolledLine');
                unrolledLine.setAttribute('x1', 200);
                unrolledLine.setAttribute('y1', this.center.y);
                unrolledLine.setAttribute('x2', 200);
                unrolledLine.setAttribute('y2', this.center.y);
                unrolledLine.setAttribute('stroke', '#9333EA');
                unrolledLine.setAttribute('stroke-width', '3');
                this.svg.appendChild(unrolledLine);

                // Add diameter markers on unrolled line
                for (let i = 1; i <= 3; i++) {
                    const markerX = 200 + (i * this.radius * 2);

                    // Vertical marker line
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    marker.setAttribute('x1', markerX);
                    marker.setAttribute('y1', this.center.y - 10);
                    marker.setAttribute('x2', markerX);
                    marker.setAttribute('y2', this.center.y + 10);
                    marker.setAttribute('stroke', '#DC2626');
                    marker.setAttribute('stroke-width', '2');
                    this.svg.appendChild(marker);

                    // Marker label
                    const markerLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    markerLabel.setAttribute('x', markerX);
                    markerLabel.setAttribute('y', this.center.y + 25);
                    markerLabel.setAttribute('text-anchor', 'middle');
                    markerLabel.setAttribute('fill', '#DC2626');
                    markerLabel.setAttribute('font-size', '10');
                    markerLabel.textContent = `${i}d`;
                    this.svg.appendChild(markerLabel);
                }

                // Add pi marker
                const piMarkerX = 200 + (Math.PI * this.radius * 2);
                const piMarker = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                piMarker.setAttribute('x1', piMarkerX);
                piMarker.setAttribute('y1', this.center.y - 15);
                piMarker.setAttribute('x2', piMarkerX);
                piMarker.setAttribute('y2', this.center.y + 15);
                piMarker.setAttribute('stroke', '#059669');
                piMarker.setAttribute('stroke-width', '3');
                this.svg.appendChild(piMarker);

                const piLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                piLabel.setAttribute('x', piMarkerX);
                piLabel.setAttribute('y', this.center.y + 30);
                piLabel.setAttribute('text-anchor', 'middle');
                piLabel.setAttribute('fill', '#059669');
                piLabel.setAttribute('font-size', '12');
                piLabel.setAttribute('font-weight', 'bold');
                piLabel.textContent = 'œÄ ‚âà 3.14';
                this.svg.appendChild(piLabel);

                // Add explanation text
                const explanation = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                explanation.setAttribute('x', 300);
                explanation.setAttribute('y', 50);
                explanation.setAttribute('text-anchor', 'middle');
                explanation.setAttribute('fill', '#374151');
                explanation.setAttribute('font-size', '14');
                explanation.textContent = 'La circunferencia "desenrollada" mide œÄ √ó d';
                this.svg.appendChild(explanation);

                // Add rolling circle (initially at start position)
                const rollingCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                rollingCircle.setAttribute('id', 'rollingCircle');
                rollingCircle.setAttribute('cx', this.center.x);
                rollingCircle.setAttribute('cy', this.center.y - 80);
                rollingCircle.setAttribute('r', this.radius);
                rollingCircle.setAttribute('fill', 'rgba(147, 51, 234, 0.3)');
                rollingCircle.setAttribute('stroke', '#9333EA');
                rollingCircle.setAttribute('stroke-width', '2');
                rollingCircle.setAttribute('stroke-dasharray', '5,5');
                this.svg.appendChild(rollingCircle);

                // Add a dot on the rolling circle to show rotation
                const rollingDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                rollingDot.setAttribute('id', 'rollingDot');
                rollingDot.setAttribute('cx', this.center.x + this.radius);
                rollingDot.setAttribute('cy', this.center.y - 80);
                rollingDot.setAttribute('r', '3');
                rollingDot.setAttribute('fill', '#DC2626');
                this.svg.appendChild(rollingDot);

                // Add trail path for the dot
                const trailPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                trailPath.setAttribute('id', 'trailPath');
                trailPath.setAttribute('stroke', '#DC2626');
                trailPath.setAttribute('stroke-width', '2');
                trailPath.setAttribute('fill', 'none');
                trailPath.setAttribute('opacity', '0.6');
                this.svg.appendChild(trailPath);
            }

            setupEventListeners() {
                const playButton = document.getElementById('playAnimation');
                const resetButton = document.getElementById('resetAnimation');

                if (playButton) {
                    playButton.addEventListener('click', () => {
                        if (this.animationState === 'stopped' || this.animationState === 'finished') {
                            this.startAnimation();
                        } else if (this.animationState === 'playing') {
                            this.pauseAnimation();
                        } else if (this.animationState === 'paused') {
                            this.resumeAnimation();
                        }
                    });
                }

                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        this.resetAnimation();
                    });
                }
            }

            startAnimation() {
                this.animationState = 'playing';
                this.currentAngle = 0;
                this.unrolledLength = 0;
                this.trailPoints = [];

                // Clear trail
                const trailPath = this.svg.getElementById('trailPath');
                if (trailPath) {
                    trailPath.setAttribute('d', '');
                }

                const playButton = document.getElementById('playAnimation');
                if (playButton) {
                    playButton.textContent = '‚è∏ Pausar Animaci√≥n';
                }

                this.animate();
            }

            pauseAnimation() {
                this.animationState = 'paused';
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                const playButton = document.getElementById('playAnimation');
                if (playButton) {
                    playButton.textContent = '‚ñ∂ Continuar Animaci√≥n';
                }
            }

            resumeAnimation() {
                this.animationState = 'playing';

                const playButton = document.getElementById('playAnimation');
                if (playButton) {
                    playButton.textContent = '‚è∏ Pausar Animaci√≥n';
                }

                this.animate();
            }

            resetAnimation() {
                // Stop any running animation
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                this.animationState = 'stopped';
                this.currentAngle = 0;
                this.unrolledLength = 0;
                this.trailPoints = [];

                // Reset button text
                const playButton = document.getElementById('playAnimation');
                if (playButton) {
                    playButton.textContent = '‚ñ∂ Reproducir Animaci√≥n';
                }

                // Reset visual elements
                const rollingCircle = this.svg.getElementById('rollingCircle');
                const rollingDot = this.svg.getElementById('rollingDot');
                const unrolledLine = this.svg.getElementById('unrolledLine');
                const trailPath = this.svg.getElementById('trailPath');

                if (rollingCircle) {
                    rollingCircle.setAttribute('cx', this.center.x);
                    rollingCircle.setAttribute('transform', '');
                }

                if (rollingDot) {
                    rollingDot.setAttribute('cx', this.center.x + this.radius);
                    rollingDot.setAttribute('cy', this.center.y - 80);
                }

                if (unrolledLine) {
                    unrolledLine.setAttribute('x2', 200);
                }

                if (trailPath) {
                    trailPath.setAttribute('d', '');
                }

                // Remove highlight from pi marker
                const piMarker = this.svg.querySelector('line[stroke="#059669"]');
                if (piMarker) {
                    piMarker.style.filter = '';
                }
            }

            animate() {
                if (this.animationState !== 'playing') return;

                // Update animation
                this.currentAngle += 0.02; // Animation speed
                this.unrolledLength = this.currentAngle * this.radius;

                // Update rolling circle position
                const rollingCircle = this.svg.getElementById('rollingCircle');
                const rollingDot = this.svg.getElementById('rollingDot');
                if (rollingCircle) {
                    const newX = 200 + this.unrolledLength;
                    rollingCircle.setAttribute('cx', newX);

                    // Rotate the circle (visual effect)
                    rollingCircle.setAttribute('transform', `rotate(${this.currentAngle * 180 / Math.PI} ${newX} ${this.center.y - 80})`);

                    // Update the dot position to show rolling motion
                    if (rollingDot) {
                        const dotAngle = -this.currentAngle; // Negative for proper rolling direction
                        const dotX = newX + this.radius * Math.cos(dotAngle);
                        const dotY = (this.center.y - 80) + this.radius * Math.sin(dotAngle);
                        rollingDot.setAttribute('cx', dotX);
                        rollingDot.setAttribute('cy', dotY);

                        // Add point to trail when dot is at bottom of circle (touching the line)
                        if (Math.abs(dotAngle % (2 * Math.PI) - Math.PI) < 0.1) {
                            this.trailPoints.push({ x: 200 + this.unrolledLength, y: this.center.y });
                            this.updateTrail();
                        }
                    }
                }

                // Update unrolled line
                const unrolledLine = this.svg.getElementById('unrolledLine');
                if (unrolledLine) {
                    unrolledLine.setAttribute('x2', 200 + this.unrolledLength);
                }

                // Check if animation is complete (one full rotation)
                if (this.currentAngle >= 2 * Math.PI) {
                    this.finishAnimation();
                    return;
                }

                this.animationId = requestAnimationFrame(() => this.animate());
            }

            finishAnimation() {
                this.animationState = 'finished';

                const playButton = document.getElementById('playAnimation');
                if (playButton) {
                    playButton.textContent = 'üîÑ Repetir Animaci√≥n';
                }

                // Highlight the pi relationship
                setTimeout(() => {
                    const piMarker = this.svg.querySelector('line[stroke="#059669"]');
                    if (piMarker) {
                        piMarker.style.filter = 'drop-shadow(0 0 8px #059669)';
                    }
                }, 500);
            }

            updateTrail() {
                const trailPath = this.svg.getElementById('trailPath');
                if (trailPath && this.trailPoints.length > 1) {
                    let pathData = `M ${this.trailPoints[0].x} ${this.trailPoints[0].y}`;
                    for (let i = 1; i < this.trailPoints.length; i++) {
                        pathData += ` L ${this.trailPoints[i].x} ${this.trailPoints[i].y}`;
                    }
                    trailPath.setAttribute('d', pathData);
                }
            }
        }

        // Circumference Calculator Class
        class CircumferenceCalculator {
            constructor() {
                this.radiusInput = null;
                this.diameterInput = null;
                this.resultDisplay = null;
                this.init();
            }

            init() {
                this.radiusInput = document.getElementById('radiusInput');
                this.diameterInput = document.getElementById('diameterInput');
                this.resultDisplay = document.getElementById('circumferenceResult');

                if (this.radiusInput && this.diameterInput && this.resultDisplay) {
                    this.setupEventListeners();
                }
            }

            setupEventListeners() {
                // Real-time calculation on input
                this.radiusInput.addEventListener('input', (e) => {
                    const radius = parseFloat(e.target.value);
                    if (!isNaN(radius) && radius > 0) {
                        // Update diameter input
                        this.diameterInput.value = (radius * 2).toFixed(2);
                        // Calculate circumference
                        this.calculateFromRadius(radius);
                    } else {
                        this.clearResults();
                    }
                });

                this.diameterInput.addEventListener('input', (e) => {
                    const diameter = parseFloat(e.target.value);
                    if (!isNaN(diameter) && diameter > 0) {
                        // Update radius input
                        this.radiusInput.value = (diameter / 2).toFixed(2);
                        // Calculate circumference
                        this.calculateFromDiameter(diameter);
                    } else {
                        this.clearResults();
                    }
                });
            }

            calculateFromRadius(radius) {
                const circumference = 2 * Math.PI * radius;
                this.displayResult(circumference, 'radio', radius);
            }

            calculateFromDiameter(diameter) {
                const circumference = Math.PI * diameter;
                this.displayResult(circumference, 'di√°metro', diameter);
            }

            displayResult(circumference, inputType, inputValue) {
                const circumferenceRounded = circumference.toFixed(2);
                const circumferenceApprox = (inputType === 'radio' ? 2 * 3.14 * inputValue : 3.14 * inputValue).toFixed(2);

                this.resultDisplay.innerHTML = `
                    <div class="space-y-2">
                        <p class="text-lg font-medium text-purple-800">
                            Longitud de la circunferencia: <span class="font-bold">${circumferenceRounded} cm</span>
                        </p>
                        <div class="text-sm text-gray-600">
                            <p>C√°lculo: ${inputType === 'radio' ? '2 √ó œÄ √ó ' + inputValue : 'œÄ √ó ' + inputValue}</p>
                            <p>Con œÄ ‚âà 3.14: ${circumferenceApprox} cm</p>
                        </div>
                    </div>
                `;
            }

            clearResults() {
                this.resultDisplay.innerHTML = `
                    <p class="text-lg font-medium text-purple-800">Longitud de la circunferencia: --</p>
                `;
            }
        }

        // Initialize Pi module components
        let piAnimationInstance = null;
        let circumferenceCalculatorInstance = null;

        function initPiModule() {
            const animationSvg = document.getElementById('piAnimationSvg');

            if (animationSvg && !piAnimationInstance) {
                piAnimationInstance = new PiAnimation(animationSvg);
            }

            if (!circumferenceCalculatorInstance) {
                circumferenceCalculatorInstance = new CircumferenceCalculator();
            }
        }

        // Unit Tests for CircleElements - Element Detection
        class CircleElementsTests {
            constructor() {
                this.testResults = [];
                this.testInstance = null;
            }

            // Setup test environment
            setupTestEnvironment() {
                // Create a temporary SVG element for testing
                const testSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                testSvg.setAttribute('width', '500');
                testSvg.setAttribute('height', '400');
                testSvg.setAttribute('id', 'testCircleSvg');
                testSvg.style.display = 'none';
                document.body.appendChild(testSvg);

                // Create a temporary label element for testing
                const testLabel = document.createElement('div');
                testLabel.setAttribute('id', 'testElementLabel');
                testLabel.style.display = 'none';
                document.body.appendChild(testLabel);

                // Initialize CircleElements instance for testing
                this.testInstance = new CircleElements(testSvg);

                // Override updateElementDescription to use test label
                const originalUpdate = this.testInstance.updateElementDescription;
                this.testInstance.updateElementDescription = function (elementName) {
                    const labelElement = document.getElementById('testElementLabel');
                    if (labelElement) {
                        if (elementName && this.elements[elementName]) {
                            const element = this.elements[elementName];
                            labelElement.innerHTML = `
                                <p class="text-lg font-medium" style="color: ${element.color};">${element.label}</p>
                                <p class="text-sm text-gray-600 mt-1">${element.description}</p>
                            `;
                        } else {
                            labelElement.innerHTML = `
                                <p class="text-lg font-medium text-blue-800">Pasa el mouse sobre los elementos para identificarlos</p>
                            `;
                        }
                    }
                }.bind(this.testInstance);
            }

            // Cleanup test environment
            cleanupTestEnvironment() {
                const testSvg = document.getElementById('testCircleSvg');
                const testLabel = document.getElementById('testElementLabel');
                if (testSvg) testSvg.remove();
                if (testLabel) testLabel.remove();
                this.testInstance = null;
            }

            // Test helper to assert conditions
            assert(condition, message) {
                if (condition) {
                    this.testResults.push({ status: 'PASS', message });
                    return true;
                } else {
                    this.testResults.push({ status: 'FAIL', message });
                    return false;
                }
            }

            // Test 1: Verify all elements are rendered correctly
            testElementRendering() {
                const elements = ['center', 'radius', 'diameter', 'chord', 'arc', 'tangent'];
                let allElementsRendered = true;

                elements.forEach(elementName => {
                    const element = this.testInstance.svg.querySelector(`[data-element="${elementName}"]`);
                    if (!element) {
                        allElementsRendered = false;
                    }
                });

                this.assert(allElementsRendered, 'All circle elements are rendered with correct data-element attributes');
            }

            // Test 2: Test hover event handling
            testHoverEventHandling() {
                const testElement = this.testInstance.svg.querySelector('[data-element="center"]');

                // Simulate mouseenter event
                const mouseEnterEvent = new MouseEvent('mouseenter', { bubbles: true });
                Object.defineProperty(mouseEnterEvent, 'target', {
                    value: testElement,
                    enumerable: true
                });
                testElement.dispatchEvent(mouseEnterEvent);

                // Check if element is highlighted
                const isHighlighted = this.testInstance.currentHighlight === 'center';
                this.assert(isHighlighted, 'Hover event correctly highlights center element');

                // Check if visual highlight is applied
                const hasVisualHighlight = testElement.style.filter.includes('drop-shadow');
                this.assert(hasVisualHighlight, 'Visual highlight (drop-shadow) is applied on hover');

                // Simulate mouseleave event
                const mouseLeaveEvent = new MouseEvent('mouseleave', { bubbles: true });
                testElement.dispatchEvent(mouseLeaveEvent);

                // Check if highlight is cleared
                const isCleared = this.testInstance.currentHighlight === null;
                this.assert(isCleared, 'Hover leave event correctly clears highlight');
            }

            // Test 3: Test touch event handling
            testTouchEventHandling() {
                const testElement = this.testInstance.svg.querySelector('[data-element="radius"]');

                try {
                    // Simulate touchstart event
                    let touchStartEvent;

                    // Try to create TouchEvent, fallback to generic Event if not supported
                    if (typeof TouchEvent !== 'undefined') {
                        touchStartEvent = new TouchEvent('touchstart', {
                            bubbles: true,
                            cancelable: true
                        });
                    } else {
                        touchStartEvent = new Event('touchstart', {
                            bubbles: true,
                            cancelable: true
                        });
                    }

                    Object.defineProperty(touchStartEvent, 'target', {
                        value: testElement,
                        enumerable: true
                    });

                    // Mock preventDefault
                    touchStartEvent.preventDefault = function () { };

                    testElement.dispatchEvent(touchStartEvent);

                    // Check if element is highlighted
                    const isHighlighted = this.testInstance.currentHighlight === 'radius';
                    this.assert(isHighlighted, 'Touch event correctly highlights radius element');

                } catch (error) {
                    // If TouchEvent is not supported, test the highlight method directly
                    this.testInstance.highlightElement('radius');
                    const isHighlighted = this.testInstance.currentHighlight === 'radius';
                    this.assert(isHighlighted, 'Touch event handling (direct method test) correctly highlights radius element');
                }

                // Clear highlight for next test
                this.testInstance.clearHighlight();
            }

            // Test 4: Test correct element identification
            testElementIdentification() {
                const testCases = [
                    { element: 'center', expectedLabel: 'Centro' },
                    { element: 'radius', expectedLabel: 'Radio' },
                    { element: 'diameter', expectedLabel: 'Di√°metro' },
                    { element: 'chord', expectedLabel: 'Cuerda' },
                    { element: 'arc', expectedLabel: 'Arco' },
                    { element: 'tangent', expectedLabel: 'Tangente' }
                ];

                testCases.forEach(testCase => {
                    this.testInstance.highlightElement(testCase.element);

                    // Check if correct element is identified
                    const isCorrectElement = this.testInstance.currentHighlight === testCase.element;
                    this.assert(isCorrectElement, `Element ${testCase.element} is correctly identified`);

                    // Check if correct label is displayed
                    const labelElement = document.getElementById('testElementLabel');
                    const hasCorrectLabel = labelElement && labelElement.innerHTML.includes(testCase.expectedLabel);
                    this.assert(hasCorrectLabel, `Correct label "${testCase.expectedLabel}" is displayed for ${testCase.element}`);

                    this.testInstance.clearHighlight();
                });
            }

            // Test 5: Test label positioning
            testLabelPositioning() {
                const elements = ['center', 'radius', 'diameter', 'chord', 'arc', 'tangent'];
                let allLabelsPositioned = true;

                elements.forEach(elementName => {
                    const position = this.testInstance.getLabelPosition(elementName);
                    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {
                        allLabelsPositioned = false;
                    }
                });

                this.assert(allLabelsPositioned, 'All elements have valid label positions with numeric x,y coordinates');
            }

            // Test 6: Test element description updates
            testElementDescriptionUpdates() {
                // Test with valid element
                this.testInstance.updateElementDescription('center');
                const labelElement = document.getElementById('testElementLabel');
                const hasDescription = labelElement && labelElement.innerHTML.includes('Centro') &&
                    labelElement.innerHTML.includes('equidistante');
                this.assert(hasDescription, 'Element description is correctly updated with element details');

                // Test with null element (reset state)
                this.testInstance.updateElementDescription(null);
                const hasDefaultMessage = labelElement && labelElement.innerHTML.includes('Pasa el mouse');
                this.assert(hasDefaultMessage, 'Element description correctly resets to default message');
            }

            // Test 7: Test highlight clearing functionality
            testHighlightClearing() {
                // Highlight an element first
                this.testInstance.highlightElement('diameter');
                const isHighlighted = this.testInstance.currentHighlight === 'diameter';
                this.assert(isHighlighted, 'Element is highlighted before clearing');

                // Clear highlight
                this.testInstance.clearHighlight();
                const isCleared = this.testInstance.currentHighlight === null;
                this.assert(isCleared, 'Highlight is properly cleared');

                // Check if visual effects are removed
                const element = this.testInstance.svg.querySelector('[data-element="diameter"]');
                const visualEffectsRemoved = !element.style.filter;
                this.assert(visualEffectsRemoved, 'Visual highlight effects are removed after clearing');
            }

            // Test 8: Test multiple rapid interactions
            testRapidInteractions() {
                const elements = ['center', 'radius', 'chord'];

                // Rapidly highlight different elements
                elements.forEach(elementName => {
                    this.testInstance.highlightElement(elementName);
                });

                // Should end up with the last element highlighted
                const finalHighlight = this.testInstance.currentHighlight === 'chord';
                this.assert(finalHighlight, 'Rapid interactions correctly update to final element');

                // Clear for cleanup
                this.testInstance.clearHighlight();
            }

            // Run all tests
            runAllTests() {
                console.log('üß™ Starting CircleElements Unit Tests...');
                this.testResults = [];

                try {
                    this.setupTestEnvironment();

                    // Run individual tests
                    this.testElementRendering();
                    this.testHoverEventHandling();
                    this.testTouchEventHandling();
                    this.testElementIdentification();
                    this.testLabelPositioning();
                    this.testElementDescriptionUpdates();
                    this.testHighlightClearing();
                    this.testRapidInteractions();

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Test execution error: ${error.message}` });
                } finally {
                    this.cleanupTestEnvironment();
                }

                // Report results
                this.reportResults();
                return this.testResults;
            }

            // Report test results
            reportResults() {
                const passed = this.testResults.filter(r => r.status === 'PASS').length;
                const failed = this.testResults.filter(r => r.status === 'FAIL').length;
                const errors = this.testResults.filter(r => r.status === 'ERROR').length;

                console.log(`\nüìä Test Results Summary:`);
                console.log(`‚úÖ Passed: ${passed}`);
                console.log(`‚ùå Failed: ${failed}`);
                console.log(`üö® Errors: ${errors}`);
                console.log(`üìà Total: ${this.testResults.length}`);

                if (failed > 0 || errors > 0) {
                    console.log('\n‚ùå Failed/Error Tests:');
                    this.testResults
                        .filter(r => r.status !== 'PASS')
                        .forEach(result => {
                            console.log(`${result.status === 'FAIL' ? '‚ùå' : 'üö®'} ${result.message}`);
                        });
                }

                // Return success status
                return failed === 0 && errors === 0;
            }
        }

        // Global function to run CircleElements tests
        function runCircleElementsTests() {
            const tester = new CircleElementsTests();
            return tester.runAllTests();
        }

        // Test runner utility - can be called from browser console
        window.testCircleElements = runCircleElementsTests;

        // Auto-run tests in development mode (uncomment for testing)
        // setTimeout(() => {
        //     console.log('üîß Development Mode: Running CircleElements tests...');
        //     runCircleElementsTests();
        // }, 1000);

        // Test Panel Management
        function setupTestPanel() {
            const testPanel = document.getElementById('testPanel');
            const closeBtn = document.getElementById('closeTestPanel');
            const testResults = document.getElementById('testResults');

            // Show test panel with Ctrl+Shift+T
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                    e.preventDefault();
                    testPanel.classList.remove('hidden');
                }
            });

            // Close test panel
            closeBtn.addEventListener('click', () => {
                testPanel.classList.add('hidden');
            });

            // Close on background click
            testPanel.addEventListener('click', (e) => {
                if (e.target === testPanel) {
                    testPanel.classList.add('hidden');
                }
            });

            // Helper function to display test results in UI
            function displayTestResults(testResults, testName) {
                const passed = testResults.filter(r => r.status === 'PASS').length;
                const failed = testResults.filter(r => r.status === 'FAIL').length;
                const errors = testResults.filter(r => r.status === 'ERROR').length;

                let html = `
                    <div class="mb-4">
                        <h4 class="font-semibold text-lg mb-2">${testName} Results Summary</h4>
                        <div class="grid grid-cols-3 gap-4 text-center">
                            <div class="bg-green-100 p-2 rounded">
                                <div class="text-green-800 font-bold">${passed}</div>
                                <div class="text-green-600 text-sm">Passed</div>
                            </div>
                            <div class="bg-red-100 p-2 rounded">
                                <div class="text-red-800 font-bold">${failed}</div>
                                <div class="text-red-600 text-sm">Failed</div>
                            </div>
                            <div class="bg-yellow-100 p-2 rounded">
                                <div class="text-yellow-800 font-bold">${errors}</div>
                                <div class="text-yellow-600 text-sm">Errors</div>
                            </div>
                        </div>
                    </div>
                `;

                if (testResults.length > 0) {
                    html += '<div class="space-y-2">';
                    testResults.forEach(result => {
                        const statusColor = result.status === 'PASS' ? 'text-green-600' :
                            result.status === 'FAIL' ? 'text-red-600' : 'text-yellow-600';
                        const statusIcon = result.status === 'PASS' ? '‚úÖ' :
                            result.status === 'FAIL' ? '‚ùå' : 'üö®';
                        html += `
                            <div class="flex items-start space-x-2 p-2 bg-white rounded border-l-4 ${result.status === 'PASS' ? 'border-green-500' :
                                result.status === 'FAIL' ? 'border-red-500' : 'border-yellow-500'
                            }">
                                <span>${statusIcon}</span>
                                <span class="${statusColor} text-sm">${result.message}</span>
                            </div>
                        `;
                    });
                    html += '</div>';
                }

                document.getElementById('testResults').innerHTML = html;
            }

            // Run Circle Elements tests button
            const runCircleTestsBtn = document.getElementById('runCircleTestsBtn');
            runCircleTestsBtn.addEventListener('click', () => {
                document.getElementById('testResults').innerHTML = '<p class="text-blue-600">Running Circle Elements tests...</p>';

                setTimeout(() => {
                    const tester = new CircleElementsTests();
                    const results = tester.runAllTests();
                    displayTestResults(results, 'Circle Elements Tests');
                }, 100);
            });

            // Run Pi Calculation tests button
            const runPiTestsBtn = document.getElementById('runPiTestsBtn');
            runPiTestsBtn.addEventListener('click', () => {
                document.getElementById('testResults').innerHTML = '<p class="text-purple-600">Running Pi Calculation tests...</p>';

                setTimeout(() => {
                    const tester = new PiCalculationTests();
                    const results = tester.runAllTests();
                    displayTestResults(results.results, 'Pi Calculation Tests');
                }, 100);
            });

            // Run Figure Game tests button
            const runFigureGameTestsBtn = document.getElementById('runFigureGameTestsBtn');
            runFigureGameTestsBtn.addEventListener('click', () => {
                document.getElementById('testResults').innerHTML = '<p class="text-yellow-600">Running Figure Game tests...</p>';

                setTimeout(() => {
                    const tester = new FigureGameTests();
                    const results = tester.runAllTests();
                    displayTestResults(results, 'Figure Game Tests');
                }, 100);
            });

            // Run Evaluation Flow Integration tests button
            const runEvaluationTestsBtn = document.getElementById('runEvaluationTestsBtn');
            runEvaluationTestsBtn.addEventListener('click', () => {
                document.getElementById('testResults').innerHTML = '<p class="text-orange-600">Running evaluation flow integration tests...</p>';

                setTimeout(() => {
                    const tester = new EvaluationFlowTests();
                    const results = tester.runAllTests();
                    displayTestResults(results, 'Evaluation Flow Integration Tests');
                }, 100);
            });

            // Run All tests button
            const runAllTestsBtn = document.getElementById('runAllTestsBtn');
            runAllTestsBtn.addEventListener('click', () => {
                document.getElementById('testResults').innerHTML = '<p class="text-blue-600">Running all tests...</p>';

                setTimeout(() => {
                    // Run Circle Elements tests
                    const circleTester = new CircleElementsTests();
                    const circleResults = circleTester.runAllTests();

                    // Run Pi Calculation tests
                    const piTester = new PiCalculationTests();
                    const piResults = piTester.runAllTests();

                    // Run Figure Game tests
                    const figureGameTester = new FigureGameTests();
                    const figureGameResults = figureGameTester.runAllTests();

                    // Run Evaluation Flow Integration tests
                    const evaluationTester = new EvaluationFlowTests();
                    const evaluationResults = evaluationTester.runAllTests();

                    // Combine results
                    const allResults = [...circleResults, ...piResults.results, ...figureGameResults, ...evaluationResults];
                    displayTestResults(allResults, 'All Tests');
                }, 100);
            });

            // Run Automated Testing Utilities button
            const runAutomatedTestsBtn = document.getElementById('runAutomatedTestsBtn');
            runAutomatedTestsBtn.addEventListener('click', () => {
                document.getElementById('testResults').innerHTML = '<p class="text-teal-600">Running automated testing utilities...</p>';

                setTimeout(() => {
                    const results = AutomatedTestRunner.runAllAutomatedTests();
                    displayAutomatedTestResults(results);
                }, 100);
            });
        }

        // Display function for automated test results
        function displayAutomatedTestResults(results) {
            const testResultsDiv = document.getElementById('testResults');
            
            let html = `
                <div class="mb-4">
                    <h4 class="font-semibold text-lg mb-2">Automated Testing Utilities Results</h4>
                    <div class="grid grid-cols-3 gap-4 text-center mb-4">
                        <div class="bg-green-100 p-2 rounded">
                            <div class="text-2xl font-bold text-green-600">${results.summary.passed}</div>
                            <div class="text-sm text-green-700">Passed</div>
                        </div>
                        <div class="bg-red-100 p-2 rounded">
                            <div class="text-2xl font-bold text-red-600">${results.summary.failed}</div>
                            <div class="text-sm text-red-700">Failed</div>
                        </div>
                        <div class="bg-blue-100 p-2 rounded">
                            <div class="text-2xl font-bold text-blue-600">${results.summary.total}</div>
                            <div class="text-sm text-blue-700">Total</div>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h5 class="font-medium text-blue-800 mb-2">üìä Mathematical Calculation Tests</h5>
                        <div class="space-y-2">
            `;
            
            results.mathResults.forEach(result => {
                const statusIcon = result.passed ? '‚úÖ' : '‚ùå';
                const statusClass = result.passed ? 'text-green-700' : 'text-red-700';
                html += `
                    <div class="flex items-center justify-between p-2 bg-white rounded border-l-4 ${result.passed ? 'border-green-500' : 'border-red-500'}">
                        <span class="font-medium">${statusIcon} ${result.test}</span>
                        <span class="text-sm ${statusClass}">${result.details}</span>
                    </div>
                `;
            });
            
            html += `
                        </div>
                    </div>
                    
                    <div class="bg-purple-50 p-4 rounded-lg">
                        <h5 class="font-medium text-purple-800 mb-2">üñ±Ô∏è Mock Interaction Tests</h5>
                        <div class="space-y-2">
            `;
            
            results.interactionResults.forEach(result => {
                const statusIcon = result.passed ? '‚úÖ' : '‚ùå';
                const statusClass = result.passed ? 'text-green-700' : 'text-red-700';
                html += `
                    <div class="flex items-center justify-between p-2 bg-white rounded border-l-4 ${result.passed ? 'border-green-500' : 'border-red-500'}">
                        <span class="font-medium">${statusIcon} ${result.test}</span>
                        <span class="text-sm ${statusClass}">${result.details}</span>
                    </div>
                `;
            });
            
            html += `
                        </div>
                    </div>
                </div>
                
                <div class="mt-4 p-3 bg-gray-100 rounded text-sm text-gray-600">
                    <strong>Usage:</strong> These utilities can be used programmatically via:
                    <br>‚Ä¢ <code>MathTestingUtils.validateAngleSum(angles, expectedSum)</code>
                    <br>‚Ä¢ <code>MockInteractionUtils.simulateDragSequence(element, startX, startY, endX, endY)</code>
                    <br>‚Ä¢ <code>AutomatedTestRunner.validateAngleTriangleCalculations(triangleInstance)</code>
                </div>
            `;
            
            testResultsDiv.innerHTML = html;
        }

        // Initialize angle triangle when suma-angulos practice tab is loaded
        let angleTriangleInstance = null;

        function initAngleTriangle() {
            const svg = document.getElementById('angleSvg');
            const toggleButton = document.getElementById('toggleShape');

            if (svg && !angleTriangleInstance) {
                angleTriangleInstance = new AngleTriangle(svg);

                if (toggleButton) {
                    toggleButton.addEventListener('click', () => {
                        angleTriangleInstance.toggleShape();
                        toggleButton.textContent = angleTriangleInstance.isQuadrilateral ?
                            'Cambiar a Tri√°ngulo' : 'Cambiar a Cuadril√°tero';
                    });
                }
            }
        }

        // Centralized Question Generation System
        class QuestionGenerator {
            constructor() {
                this.difficultyLevels = {
                    easy: 1,
                    medium: 2,
                    hard: 3
                };
                this.gradeLevel = 6; // 6th grade
            }

            // Generate random mathematical problems based on module and difficulty
            generateQuestion(moduleId, questionType, difficulty = 'medium') {
                const generators = {
                    'suma-angulos': this.generateAngleQuestion.bind(this),
                    'circunferencia': this.generateCircleQuestion.bind(this),
                    'numero-pi': this.generatePiQuestion.bind(this),
                    'circulo-figuras': this.generateFigureQuestion.bind(this),
                    'posiciones-rectas': this.generatePositionQuestion.bind(this)
                };

                const generator = generators[moduleId];
                if (!generator) {
                    throw new Error(`No question generator found for module: ${moduleId}`);
                }

                return generator(questionType, difficulty);
            }

            // Generate angle sum questions
            generateAngleQuestion(questionType, difficulty) {
                const difficultyLevel = this.difficultyLevels[difficulty];
                
                if (questionType === 'multiple-choice') {
                    return this.generateAngleMultipleChoice(difficultyLevel);
                } else if (questionType === 'calculation') {
                    return this.generateAngleCalculation(difficultyLevel);
                }
            }

            generateAngleMultipleChoice(difficultyLevel) {
                const isTriangle = Math.random() < 0.6; // 60% triangles, 40% quadrilaterals
                const targetSum = isTriangle ? 180 : 360;
                const shapeType = isTriangle ? 'tri√°ngulo' : 'cuadril√°tero';
                
                let angles, missingIndex;
                
                if (difficultyLevel === 1) {
                    // Easy: nice round numbers
                    if (isTriangle) {
                        angles = [60, 60, 60];
                        missingIndex = Math.floor(Math.random() * 3);
                        angles[missingIndex] = null;
                    } else {
                        angles = [90, 90, 90, 90];
                        missingIndex = Math.floor(Math.random() * 4);
                        angles[missingIndex] = null;
                    }
                } else if (difficultyLevel === 2) {
                    // Medium: mixed numbers
                    if (isTriangle) {
                        const angle1 = 30 + Math.floor(Math.random() * 8) * 10; // 30-100
                        const angle2 = 20 + Math.floor(Math.random() * 6) * 10; // 20-70
                        const angle3 = 180 - angle1 - angle2;
                        angles = [angle1, angle2, angle3];
                        missingIndex = Math.floor(Math.random() * 3);
                        angles[missingIndex] = null;
                    } else {
                        const angle1 = 60 + Math.floor(Math.random() * 6) * 10; // 60-110
                        const angle2 = 70 + Math.floor(Math.random() * 5) * 10; // 70-110
                        const angle3 = 80 + Math.floor(Math.random() * 4) * 10; // 80-110
                        const angle4 = 360 - angle1 - angle2 - angle3;
                        angles = [angle1, angle2, angle3, angle4];
                        missingIndex = Math.floor(Math.random() * 4);
                        angles[missingIndex] = null;
                    }
                } else {
                    // Hard: decimal numbers
                    if (isTriangle) {
                        const angle1 = 25.5 + Math.random() * 50; // 25.5-75.5
                        const angle2 = 30.5 + Math.random() * 40; // 30.5-70.5
                        const angle3 = 180 - angle1 - angle2;
                        angles = [Math.round(angle1 * 10) / 10, Math.round(angle2 * 10) / 10, Math.round(angle3 * 10) / 10];
                        missingIndex = Math.floor(Math.random() * 3);
                        angles[missingIndex] = null;
                    } else {
                        const angle1 = 75.5 + Math.random() * 30; // 75.5-105.5
                        const angle2 = 80.5 + Math.random() * 25; // 80.5-105.5
                        const angle3 = 85.5 + Math.random() * 20; // 85.5-105.5
                        const angle4 = 360 - angle1 - angle2 - angle3;
                        angles = [Math.round(angle1 * 10) / 10, Math.round(angle2 * 10) / 10, Math.round(angle3 * 10) / 10, Math.round(angle4 * 10) / 10];
                        missingIndex = Math.floor(Math.random() * 4);
                        angles[missingIndex] = null;
                    }
                }

                const correctAnswer = targetSum - angles.reduce((sum, angle, index) => {
                    return sum + (index !== missingIndex ? angle : 0);
                }, 0);

                // Generate wrong options
                const wrongOptions = [];
                for (let i = 0; i < 3; i++) {
                    let wrongAnswer;
                    do {
                        wrongAnswer = correctAnswer + (Math.random() - 0.5) * 60;
                        wrongAnswer = Math.round(wrongAnswer * 10) / 10;
                    } while (wrongOptions.includes(wrongAnswer) || wrongAnswer === correctAnswer || wrongAnswer <= 0);
                    wrongOptions.push(wrongAnswer);
                }

                const allOptions = [correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);

                return {
                    id: `angle-mc-${Date.now()}`,
                    type: 'multiple-choice',
                    question: `En un ${shapeType}, los √°ngulos conocidos son: ${angles.map((angle, index) => 
                        index === missingIndex ? '?' : `${angle}¬∞`
                    ).join(', ')}. ¬øCu√°l es el valor del √°ngulo faltante?`,
                    options: allOptions.map(opt => `${opt}¬∞`),
                    correctAnswer: `${correctAnswer}¬∞`,
                    explanation: `La suma de √°ngulos internos de un ${shapeType} es ${targetSum}¬∞. Por lo tanto: ${correctAnswer}¬∞ = ${targetSum}¬∞ - ${angles.filter((_, i) => i !== missingIndex).join('¬∞ - ')}¬∞`,
                    difficulty: difficulty,
                    moduleId: 'suma-angulos'
                };
            }

            generateAngleCalculation(difficultyLevel) {
                const isTriangle = Math.random() < 0.7;
                const targetSum = isTriangle ? 180 : 360;
                const shapeType = isTriangle ? 'tri√°ngulo' : 'cuadril√°tero';
                
                let knownAngles = [];
                if (difficultyLevel === 1) {
                    knownAngles = isTriangle ? [45, 90] : [90, 90, 90];
                } else if (difficultyLevel === 2) {
                    knownAngles = isTriangle ? [65, 75] : [85, 95, 100];
                } else {
                    knownAngles = isTriangle ? [67.5, 82.5] : [87.5, 92.5, 97.5];
                }

                const correctAnswer = targetSum - knownAngles.reduce((sum, angle) => sum + angle, 0);

                return {
                    id: `angle-calc-${Date.now()}`,
                    type: 'calculation',
                    question: `Calcula el √°ngulo faltante en un ${shapeType} donde los √°ngulos conocidos son: ${knownAngles.join('¬∞, ')}¬∞.`,
                    correctAnswer: correctAnswer,
                    tolerance: difficultyLevel === 3 ? 0.5 : 1,
                    explanation: `La suma de √°ngulos internos de un ${shapeType} es ${targetSum}¬∞. Por lo tanto: ${correctAnswer}¬∞ = ${targetSum}¬∞ - ${knownAngles.join('¬∞ - ')}¬∞`,
                    difficulty: difficulty,
                    moduleId: 'suma-angulos'
                };
            }

            // Generate circle element questions
            generateCircleQuestion(questionType, difficulty) {
                const elements = ['centro', 'radio', 'di√°metro', 'cuerda', 'arco', 'tangente'];
                const difficultyLevel = this.difficultyLevels[difficulty];

                if (questionType === 'identification') {
                    const element = elements[Math.floor(Math.random() * elements.length)];
                    const wrongOptions = elements.filter(e => e !== element);
                    const selectedWrong = wrongOptions.sort(() => Math.random() - 0.5).slice(0, 3);
                    const allOptions = [element, ...selectedWrong].sort(() => Math.random() - 0.5);

                    return {
                        id: `circle-id-${Date.now()}`,
                        type: 'identification',
                        question: `¬øC√≥mo se llama el elemento resaltado en la circunferencia?`,
                        targetElement: element,
                        options: allOptions,
                        correctAnswer: element,
                        explanation: this.getCircleElementExplanation(element),
                        difficulty: difficulty,
                        moduleId: 'circunferencia'
                    };
                } else if (questionType === 'calculation') {
                    // Radius-diameter relationship problems
                    const isRadiusGiven = Math.random() < 0.5;
                    let value;
                    
                    if (difficultyLevel === 1) {
                        value = Math.floor(Math.random() * 10) + 1; // 1-10
                    } else if (difficultyLevel === 2) {
                        value = Math.floor(Math.random() * 20) + 5; // 5-24
                    } else {
                        value = (Math.random() * 15 + 2.5).toFixed(1); // 2.5-17.5
                        value = parseFloat(value);
                    }

                    const correctAnswer = isRadiusGiven ? value * 2 : value / 2;
                    const questionText = isRadiusGiven 
                        ? `Si el radio de una circunferencia es ${value} cm, ¬øcu√°l es su di√°metro?`
                        : `Si el di√°metro de una circunferencia es ${value} cm, ¬øcu√°l es su radio?`;

                    return {
                        id: `circle-calc-${Date.now()}`,
                        type: 'calculation',
                        question: questionText,
                        correctAnswer: correctAnswer,
                        tolerance: difficultyLevel === 3 ? 0.1 : 0.5,
                        explanation: isRadiusGiven 
                            ? `El di√°metro es el doble del radio: ${correctAnswer} = ${value} √ó 2`
                            : `El radio es la mitad del di√°metro: ${correctAnswer} = ${value} √∑ 2`,
                        difficulty: difficulty,
                        moduleId: 'circunferencia'
                    };
                }
            }

            // Generate pi calculation questions
            generatePiQuestion(questionType, difficulty) {
                const difficultyLevel = this.difficultyLevels[difficulty];
                
                if (questionType === 'calculation') {
                    const isRadiusGiven = Math.random() < 0.5;
                    let value;
                    
                    if (difficultyLevel === 1) {
                        value = Math.floor(Math.random() * 5) + 1; // 1-5
                    } else if (difficultyLevel === 2) {
                        value = Math.floor(Math.random() * 10) + 3; // 3-12
                    } else {
                        value = (Math.random() * 8 + 1.5).toFixed(1); // 1.5-9.5
                        value = parseFloat(value);
                    }

                    const pi = 3.14;
                    const correctAnswer = isRadiusGiven ? 2 * pi * value : pi * value;
                    const formula = isRadiusGiven ? `L = 2 √ó œÄ √ó r` : `L = œÄ √ó d`;
                    const calculation = isRadiusGiven ? `L = 2 √ó 3.14 √ó ${value}` : `L = 3.14 √ó ${value}`;
                    
                    const questionText = isRadiusGiven 
                        ? `Calcula la longitud de una circunferencia con radio ${value} cm. (Usa œÄ = 3.14)`
                        : `Calcula la longitud de una circunferencia con di√°metro ${value} cm. (Usa œÄ = 3.14)`;

                    return {
                        id: `pi-calc-${Date.now()}`,
                        type: 'calculation',
                        question: questionText,
                        correctAnswer: Math.round(correctAnswer * 100) / 100,
                        tolerance: 0.1,
                        explanation: `Usando la f√≥rmula ${formula}: ${calculation} = ${Math.round(correctAnswer * 100) / 100} cm`,
                        difficulty: difficulty,
                        moduleId: 'numero-pi'
                    };
                } else if (questionType === 'multiple-choice') {
                    const radius = difficultyLevel === 1 ? Math.floor(Math.random() * 5) + 2 : Math.floor(Math.random() * 8) + 3;
                    const correctAnswer = Math.round(2 * 3.14 * radius * 100) / 100;
                    
                    // Generate wrong options
                    const wrongOptions = [
                        Math.round((correctAnswer * 0.8) * 100) / 100,
                        Math.round((correctAnswer * 1.2) * 100) / 100,
                        Math.round((3.14 * radius) * 100) / 100 // Common mistake: using diameter formula
                    ];

                    const allOptions = [correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);

                    return {
                        id: `pi-mc-${Date.now()}`,
                        type: 'multiple-choice',
                        question: `¬øCu√°l es la longitud de una circunferencia con radio ${radius} cm? (Usa œÄ = 3.14)`,
                        options: allOptions.map(opt => `${opt} cm`),
                        correctAnswer: `${correctAnswer} cm`,
                        explanation: `L = 2 √ó œÄ √ó r = 2 √ó 3.14 √ó ${radius} = ${correctAnswer} cm`,
                        difficulty: difficulty,
                        moduleId: 'numero-pi'
                    };
                }
            }

            // Generate figure identification questions
            generateFigureQuestion(questionType, difficulty) {
                const figures = [
                    { name: 'sector', label: 'Sector circular' },
                    { name: 'segment', label: 'Segmento circular' },
                    { name: 'corona', label: 'Corona circular' }
                ];

                if (questionType === 'identification') {
                    const figure = figures[Math.floor(Math.random() * figures.length)];
                    const wrongOptions = figures.filter(f => f.name !== figure.name);
                    const allOptions = [figure.label, ...wrongOptions.map(f => f.label)].sort(() => Math.random() - 0.5);

                    return {
                        id: `figure-id-${Date.now()}`,
                        type: 'identification',
                        question: `¬øQu√© figura circular est√° resaltada en la imagen?`,
                        targetFigure: figure.name,
                        options: allOptions,
                        correctAnswer: figure.label,
                        explanation: this.getFigureExplanation(figure.name),
                        difficulty: difficulty,
                        moduleId: 'circulo-figuras'
                    };
                }
            }

            // Generate line position questions
            generatePositionQuestion(questionType, difficulty) {
                const positions = [
                    { name: 'exterior', label: 'Exterior' },
                    { name: 'tangente', label: 'Tangente' },
                    { name: 'secante', label: 'Secante' }
                ];

                if (questionType === 'identification') {
                    const position = positions[Math.floor(Math.random() * positions.length)];
                    const wrongOptions = positions.filter(p => p.name !== position.name);
                    const allOptions = [position.label, ...wrongOptions.map(p => p.label)].sort(() => Math.random() - 0.5);

                    return {
                        id: `position-id-${Date.now()}`,
                        type: 'identification',
                        question: `¬øCu√°l es la posici√≥n de la recta respecto a la circunferencia?`,
                        targetPosition: position.name,
                        options: allOptions,
                        correctAnswer: position.label,
                        explanation: this.getPositionExplanation(position.name),
                        difficulty: difficulty,
                        moduleId: 'posiciones-rectas'
                    };
                }
            }

            // Helper methods for explanations
            getCircleElementExplanation(element) {
                const explanations = {
                    'centro': 'El centro es el punto interior equidistante de todos los puntos de la circunferencia.',
                    'radio': 'El radio es el segmento que une el centro con cualquier punto de la circunferencia.',
                    'di√°metro': 'El di√°metro es el segmento que pasa por el centro y une dos puntos de la circunferencia.',
                    'cuerda': 'La cuerda es un segmento que une dos puntos cualesquiera de la circunferencia.',
                    'arco': 'El arco es la porci√≥n de circunferencia comprendida entre dos puntos.',
                    'tangente': 'La tangente es una recta que toca la circunferencia en un solo punto.'
                };
                return explanations[element] || '';
            }

            getFigureExplanation(figure) {
                const explanations = {
                    'sector': 'Un sector circular es la regi√≥n limitada por dos radios y el arco correspondiente.',
                    'segment': 'Un segmento circular es la regi√≥n limitada por una cuerda y el arco correspondiente.',
                    'corona': 'Una corona circular es la regi√≥n entre dos circunferencias conc√©ntricas.'
                };
                return explanations[figure] || '';
            }

            getPositionExplanation(position) {
                const explanations = {
                    'exterior': 'Una recta es exterior cuando no toca la circunferencia en ning√∫n punto.',
                    'tangente': 'Una recta es tangente cuando toca la circunferencia en exactamente un punto.',
                    'secante': 'Una recta es secante cuando cruza la circunferencia en dos puntos.'
                };
                return explanations[position] || '';
            }

            // Generate multiple questions for a module
            generateQuestionSet(moduleId, count = 5, difficulty = 'medium') {
                const questions = [];
                const questionTypes = this.getQuestionTypesForModule(moduleId);
                
                for (let i = 0; i < count; i++) {
                    const questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)];
                    const question = this.generateQuestion(moduleId, questionType, difficulty);
                    questions.push(question);
                }
                
                return questions;
            }

            // Get available question types for each module
            getQuestionTypesForModule(moduleId) {
                const moduleTypes = {
                    'suma-angulos': ['multiple-choice', 'calculation'],
                    'circunferencia': ['identification', 'calculation'],
                    'numero-pi': ['calculation', 'multiple-choice'],
                    'circulo-figuras': ['identification'],
                    'posiciones-rectas': ['identification']
                };
                return moduleTypes[moduleId] || ['multiple-choice'];
            }

            // Scale difficulty based on grade level
            scaleDifficultyForGrade(baseDifficulty, gradeLevel) {
                if (gradeLevel <= 5) {
                    return 'easy';
                } else if (gradeLevel <= 7) {
                    return baseDifficulty;
                } else {
                    return baseDifficulty === 'easy' ? 'medium' : 'hard';
                }
            }
        }

        // Global question generator instance
        const questionGenerator = new QuestionGenerator();

        // Comprehensive Feedback System
        class FeedbackSystem {
            constructor() {
                this.feedbackHistory = [];
                this.currentSession = {
                    startTime: null,
                    moduleId: null,
                    totalQuestions: 0,
                    correctAnswers: 0,
                    incorrectAnswers: 0,
                    averageResponseTime: 0,
                    questionStartTime: null
                };
            }

            // Initialize a new evaluation session
            startSession(moduleId, totalQuestions) {
                this.currentSession = {
                    startTime: Date.now(),
                    moduleId: moduleId,
                    totalQuestions: totalQuestions,
                    correctAnswers: 0,
                    incorrectAnswers: 0,
                    averageResponseTime: 0,
                    questionStartTime: Date.now(),
                    responses: []
                };
            }

            // Start timing for a question
            startQuestionTimer() {
                this.currentSession.questionStartTime = Date.now();
            }

            // Provide immediate response validation and feedback
            validateResponse(userAnswer, correctAnswer, question, tolerance = 0) {
                const responseTime = Date.now() - this.currentSession.questionStartTime;
                let isCorrect = false;

                // Validate based on question type
                if (question.type === 'multiple-choice' || question.type === 'identification') {
                    isCorrect = userAnswer === correctAnswer;
                } else if (question.type === 'calculation') {
                    const userNum = parseFloat(userAnswer);
                    const correctNum = parseFloat(correctAnswer);
                    isCorrect = !isNaN(userNum) && !isNaN(correctNum) && 
                               Math.abs(userNum - correctNum) <= tolerance;
                }

                // Record response
                const response = {
                    questionId: question.id,
                    userAnswer: userAnswer,
                    correctAnswer: correctAnswer,
                    isCorrect: isCorrect,
                    responseTime: responseTime,
                    difficulty: question.difficulty,
                    timestamp: Date.now()
                };

                this.currentSession.responses.push(response);

                // Update session statistics
                if (isCorrect) {
                    this.currentSession.correctAnswers++;
                } else {
                    this.currentSession.incorrectAnswers++;
                }

                // Calculate average response time
                const totalResponses = this.currentSession.responses.length;
                const totalTime = this.currentSession.responses.reduce((sum, r) => sum + r.responseTime, 0);
                this.currentSession.averageResponseTime = totalTime / totalResponses;

                return {
                    isCorrect: isCorrect,
                    feedback: this.generateFeedback(isCorrect, question, userAnswer, correctAnswer),
                    responseTime: responseTime,
                    sessionProgress: this.getSessionProgress()
                };
            }

            // Generate explanatory feedback for incorrect answers
            generateFeedback(isCorrect, question, userAnswer, correctAnswer) {
                let feedback = {
                    type: isCorrect ? 'success' : 'error',
                    title: isCorrect ? '¬°Correcto!' : 'Incorrecto',
                    message: '',
                    explanation: question.explanation || '',
                    encouragement: '',
                    nextSteps: ''
                };

                if (isCorrect) {
                    feedback.encouragement = this.getPositiveEncouragement(question.difficulty);
                    feedback.message = 'Tu respuesta es correcta.';
                } else {
                    feedback.message = `Tu respuesta: ${userAnswer}\nRespuesta correcta: ${correctAnswer}`;
                    feedback.encouragement = this.getConstructiveEncouragement();
                    feedback.nextSteps = this.getNextSteps(question);
                }

                return feedback;
            }

            // Get positive encouragement based on difficulty
            getPositiveEncouragement(difficulty) {
                const encouragements = {
                    easy: [
                        '¬°Muy bien! Sigues por buen camino.',
                        '¬°Excelente! Dominas este concepto.',
                        '¬°Perfecto! Contin√∫a as√≠.'
                    ],
                    medium: [
                        '¬°Fant√°stico! Est√°s progresando muy bien.',
                        '¬°Genial! Muestras un buen dominio del tema.',
                        '¬°Muy bien! Tu comprensi√≥n es s√≥lida.'
                    ],
                    hard: [
                        '¬°Impresionante! Has resuelto un problema complejo.',
                        '¬°Excelente trabajo! Dominas conceptos avanzados.',
                        '¬°Sobresaliente! Tu nivel de comprensi√≥n es muy alto.'
                    ]
                };

                const options = encouragements[difficulty] || encouragements.medium;
                return options[Math.floor(Math.random() * options.length)];
            }

            // Get constructive encouragement for incorrect answers
            getConstructiveEncouragement() {
                const encouragements = [
                    'No te preocupes, los errores son parte del aprendizaje.',
                    'Cada error es una oportunidad para aprender algo nuevo.',
                    'Sigue intentando, est√°s mejorando con cada pregunta.',
                    'Recuerda que la pr√°ctica hace al maestro.',
                    'No te desanimes, todos aprendemos a nuestro ritmo.'
                ];

                return encouragements[Math.floor(Math.random() * encouragements.length)];
            }

            // Get next steps suggestions based on question type
            getNextSteps(question) {
                const suggestions = {
                    'suma-angulos': 'Repasa que la suma de √°ngulos internos de tri√°ngulos es 180¬∞ y de cuadril√°teros es 360¬∞.',
                    'circunferencia': 'Revisa los elementos de la circunferencia en la secci√≥n de teor√≠a.',
                    'numero-pi': 'Recuerda las f√≥rmulas: L = 2œÄr para radio y L = œÄd para di√°metro.',
                    'circulo-figuras': 'Practica identificando las diferentes figuras circulares en la secci√≥n interactiva.',
                    'posiciones-rectas': 'Repasa las tres posiciones: exterior, tangente y secante.'
                };

                return suggestions[question.moduleId] || 'Revisa la teor√≠a del tema para reforzar tu comprensi√≥n.';
            }

            // Get current session progress
            getSessionProgress() {
                const totalAnswered = this.currentSession.correctAnswers + this.currentSession.incorrectAnswers;
                const percentage = totalAnswered > 0 ? 
                    Math.round((this.currentSession.correctAnswers / totalAnswered) * 100) : 0;

                return {
                    totalQuestions: this.currentSession.totalQuestions,
                    answeredQuestions: totalAnswered,
                    correctAnswers: this.currentSession.correctAnswers,
                    incorrectAnswers: this.currentSession.incorrectAnswers,
                    percentage: percentage,
                    averageResponseTime: Math.round(this.currentSession.averageResponseTime / 1000), // in seconds
                    remainingQuestions: this.currentSession.totalQuestions - totalAnswered
                };
            }

            // Display feedback in the UI
            displayFeedback(feedbackData, containerId = 'feedback') {
                const container = document.getElementById(containerId);
                if (!container) return;

                const { feedback, sessionProgress } = feedbackData;
                const bgColor = feedback.type === 'success' ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200';
                const textColor = feedback.type === 'success' ? 'text-green-800' : 'text-red-800';
                const icon = feedback.type === 'success' ? '‚úì' : '‚úó';

                let feedbackHTML = `
                    <div class="p-4 rounded-lg border-2 ${bgColor} ${textColor} space-y-3">
                        <div class="flex items-center">
                            <span class="text-2xl mr-2">${icon}</span>
                            <h5 class="font-semibold text-lg">${feedback.title}</h5>
                        </div>
                `;

                if (feedback.message) {
                    feedbackHTML += `
                        <div class="text-sm">
                            <pre class="whitespace-pre-wrap font-sans">${feedback.message}</pre>
                        </div>
                    `;
                }

                if (feedback.explanation) {
                    feedbackHTML += `
                        <div class="bg-white bg-opacity-50 p-3 rounded border-l-4 ${feedback.type === 'success' ? 'border-green-400' : 'border-red-400'}">
                            <p class="text-sm font-medium">Explicaci√≥n:</p>
                            <p class="text-sm">${feedback.explanation}</p>
                        </div>
                    `;
                }

                if (feedback.encouragement) {
                    feedbackHTML += `
                        <div class="text-sm italic">
                            üí° ${feedback.encouragement}
                        </div>
                    `;
                }

                if (feedback.nextSteps && feedback.type === 'error') {
                    feedbackHTML += `
                        <div class="bg-blue-50 p-3 rounded border-l-4 border-blue-400">
                            <p class="text-sm font-medium text-blue-800">Sugerencia:</p>
                            <p class="text-sm text-blue-700">${feedback.nextSteps}</p>
                        </div>
                    `;
                }

                feedbackHTML += `</div>`;

                // Add progress indicator
                if (sessionProgress) {
                    feedbackHTML += this.generateProgressIndicator(sessionProgress);
                }

                container.innerHTML = feedbackHTML;
                container.classList.remove('hidden');
                container.classList.add('content-fade-in');

                // Show notification
                if (typeof showNotification === 'function') {
                    const notificationType = feedback.type === 'success' ? 'success' : 'error';
                    const notificationMessage = feedback.type === 'success' ? 
                        '¬°Respuesta correcta!' : 'Respuesta incorrecta';
                    showNotification(notificationMessage, notificationType, 2000);
                }
            }

            // Generate progress indicator HTML
            generateProgressIndicator(progress) {
                const progressPercentage = (progress.answeredQuestions / progress.totalQuestions) * 100;
                const scorePercentage = progress.percentage;

                return `
                    <div class="mt-4 p-3 bg-white bg-opacity-70 rounded-lg">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-sm font-medium text-gray-700">Progreso</span>
                            <span class="text-sm text-gray-600">${progress.answeredQuestions}/${progress.totalQuestions}</span>
                        </div>
                        <div class="progress-bar mb-2">
                            <div class="progress-fill" style="width: ${progressPercentage}%"></div>
                        </div>
                        <div class="flex justify-between text-xs text-gray-600">
                            <span>Aciertos: ${progress.correctAnswers} (${scorePercentage}%)</span>
                            <span>Tiempo promedio: ${progress.averageResponseTime}s</span>
                        </div>
                    </div>
                `;
            }

            // Generate final results with detailed analysis
            generateResults() {
                const progress = this.getSessionProgress();
                const sessionDuration = Math.round((Date.now() - this.currentSession.startTime) / 1000);
                
                let performanceLevel = '';
                let performanceColor = '';
                let recommendations = [];

                if (progress.percentage >= 80) {
                    performanceLevel = 'Excelente';
                    performanceColor = 'text-green-600';
                    recommendations.push('¬°Felicitaciones! Dominas muy bien este tema.');
                    recommendations.push('Puedes continuar con temas m√°s avanzados.');
                } else if (progress.percentage >= 60) {
                    performanceLevel = 'Bueno';
                    performanceColor = 'text-blue-600';
                    recommendations.push('Tienes un buen dominio del tema.');
                    recommendations.push('Practica un poco m√°s para perfeccionar tu comprensi√≥n.');
                } else if (progress.percentage >= 40) {
                    performanceLevel = 'Regular';
                    performanceColor = 'text-yellow-600';
                    recommendations.push('Necesitas repasar algunos conceptos.');
                    recommendations.push('Te recomendamos revisar la teor√≠a y practicar m√°s.');
                } else {
                    performanceLevel = 'Necesita mejorar';
                    performanceColor = 'text-red-600';
                    recommendations.push('Es importante que repases la teor√≠a del tema.');
                    recommendations.push('Practica con los elementos interactivos antes de intentar de nuevo.');
                }

                // Analyze response patterns
                const fastResponses = this.currentSession.responses.filter(r => r.responseTime < 5000).length;
                const slowResponses = this.currentSession.responses.filter(r => r.responseTime > 15000).length;

                if (fastResponses > progress.totalQuestions * 0.7) {
                    recommendations.push('Respondes r√°pidamente, lo cual indica confianza en tus conocimientos.');
                }
                if (slowResponses > progress.totalQuestions * 0.3) {
                    recommendations.push('T√≥mate el tiempo necesario para reflexionar, pero trata de ser m√°s eficiente.');
                }

                return {
                    performanceLevel,
                    performanceColor,
                    progress,
                    sessionDuration,
                    recommendations,
                    moduleId: this.currentSession.moduleId
                };
            }

            // Display final results
            displayResults(containerId = 'questionContainer') {
                const container = document.getElementById(containerId);
                if (!container) return;

                const results = this.generateResults();
                const { performanceLevel, performanceColor, progress, sessionDuration, recommendations } = results;

                let emoji = '';
                if (progress.percentage >= 80) emoji = 'üéâ';
                else if (progress.percentage >= 60) emoji = 'üëç';
                else if (progress.percentage >= 40) emoji = 'üìö';
                else emoji = 'üí™';

                let resultsHTML = `
                    <div class="text-center space-y-6">
                        <div class="text-6xl mb-4">${emoji}</div>
                        <h3 class="text-2xl font-bold ${performanceColor} mb-2">${performanceLevel}</h3>
                        <p class="text-xl text-gray-700 mb-4">
                            Puntuaci√≥n final: ${progress.correctAnswers}/${progress.totalQuestions} (${progress.percentage}%)
                        </p>
                        
                        <div class="grid md:grid-cols-2 gap-4 mb-6">
                            <div class="bg-blue-50 p-4 rounded-lg">
                                <h4 class="font-semibold text-blue-800 mb-2">Estad√≠sticas</h4>
                                <div class="text-sm text-blue-700 space-y-1">
                                    <p>Tiempo total: ${Math.floor(sessionDuration / 60)}m ${sessionDuration % 60}s</p>
                                    <p>Tiempo promedio por pregunta: ${progress.averageResponseTime}s</p>
                                    <p>Respuestas correctas: ${progress.correctAnswers}</p>
                                    <p>Respuestas incorrectas: ${progress.incorrectAnswers}</p>
                                </div>
                            </div>
                            
                            <div class="bg-green-50 p-4 rounded-lg">
                                <h4 class="font-semibold text-green-800 mb-2">Recomendaciones</h4>
                                <div class="text-sm text-green-700 space-y-1">
                                    ${recommendations.map(rec => `<p>‚Ä¢ ${rec}</p>`).join('')}
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex flex-col sm:flex-row gap-4 justify-center">
                            <button id="restartEvaluation" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg transition-colors touch-target interactive-element">
                                Intentar de Nuevo
                            </button>
                            <button id="reviewTheory" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors touch-target interactive-element">
                                Revisar Teor√≠a
                            </button>
                        </div>
                    </div>
                `;

                container.innerHTML = resultsHTML;

                // Add event listeners
                const restartBtn = document.getElementById('restartEvaluation');
                const reviewBtn = document.getElementById('reviewTheory');

                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        // Trigger restart of current evaluation
                        const event = new CustomEvent('restartEvaluation', { 
                            detail: { moduleId: this.currentSession.moduleId } 
                        });
                        document.dispatchEvent(event);
                    });
                }

                if (reviewBtn) {
                    reviewBtn.addEventListener('click', () => {
                        // Switch to theory tab
                        const theoryTab = document.querySelector('[data-tab="teoria"]');
                        if (theoryTab) {
                            theoryTab.click();
                        }
                    });
                }
            }

            // Save session to history
            saveSession() {
                const sessionSummary = {
                    moduleId: this.currentSession.moduleId,
                    timestamp: this.currentSession.startTime,
                    duration: Date.now() - this.currentSession.startTime,
                    totalQuestions: this.currentSession.totalQuestions,
                    correctAnswers: this.currentSession.correctAnswers,
                    percentage: this.getSessionProgress().percentage,
                    averageResponseTime: this.currentSession.averageResponseTime
                };

                this.feedbackHistory.push(sessionSummary);

                // Keep only last 10 sessions
                if (this.feedbackHistory.length > 10) {
                    this.feedbackHistory = this.feedbackHistory.slice(-10);
                }

                // Save to localStorage if available
                try {
                    localStorage.setItem('mathAppFeedbackHistory', JSON.stringify(this.feedbackHistory));
                } catch (e) {
                    console.warn('Could not save feedback history to localStorage');
                }
            }

            // Load history from localStorage
            loadHistory() {
                try {
                    const saved = localStorage.getItem('mathAppFeedbackHistory');
                    if (saved) {
                        this.feedbackHistory = JSON.parse(saved);
                    }
                } catch (e) {
                    console.warn('Could not load feedback history from localStorage');
                    this.feedbackHistory = [];
                }
            }
        }

        // Global feedback system instance
        const feedbackSystem = new FeedbackSystem();
        feedbackSystem.loadHistory();

        // Evaluation System for Suma de √Ångulos
        class AngleEvaluation {
            constructor() {
                this.currentQuestion = 0;
                this.score = 0;
                this.questions = [];
                this.totalQuestions = 5;
            }

            generateQuestions() {
                this.questions = [];
                
                // Use centralized question generator
                const generatedQuestions = questionGenerator.generateQuestionSet('suma-angulos', this.totalQuestions, 'medium');
                
                // Convert to the format expected by this evaluation class
                this.questions = generatedQuestions.map(q => {
                    if (q.type === 'multiple-choice') {
                        return {
                            type: 'multiple-choice',
                            question: q.question,
                            options: q.options,
                            correctAnswer: q.correctAnswer,
                            explanation: q.explanation,
                            difficulty: q.difficulty
                        };
                    } else if (q.type === 'calculation') {
                        return {
                            type: 'calculation',
                            question: q.question,
                            correctAnswer: q.correctAnswer,
                            tolerance: q.tolerance || 1,
                            explanation: q.explanation,
                            difficulty: q.difficulty
                        };
                    }
                });
            }

            generateTriangleQuestion() {
                // Generate two random angles, calculate the third
                const angle1 = Math.floor(Math.random() * 80) + 20; // 20-100¬∞
                const angle2 = Math.floor(Math.random() * (140 - angle1)) + 20; // Ensure sum < 180
                const angle3 = 180 - angle1 - angle2;

                const angles = [angle1, angle2, angle3];
                const hiddenIndex = Math.floor(Math.random() * 3);
                const hiddenAngle = angles[hiddenIndex];

                // Create question text
                const visibleAngles = angles.filter((_, index) => index !== hiddenIndex);
                const questionText = `En un tri√°ngulo, dos de los √°ngulos miden ${visibleAngles[0]}¬∞ y ${visibleAngles[1]}¬∞. ¬øCu√°nto mide el tercer √°ngulo?`;

                // Generate wrong answers
                const wrongAnswers = [
                    hiddenAngle + Math.floor(Math.random() * 20) + 10,
                    hiddenAngle - Math.floor(Math.random() * 20) - 10,
                    Math.floor(Math.random() * 90) + 30
                ].filter(angle => angle > 0 && angle < 180 && angle !== hiddenAngle);

                // Ensure we have exactly 3 wrong answers
                while (wrongAnswers.length < 3) {
                    const wrongAngle = Math.floor(Math.random() * 120) + 20;
                    if (wrongAngle !== hiddenAngle && !wrongAnswers.includes(wrongAngle)) {
                        wrongAnswers.push(wrongAngle);
                    }
                }

                const options = [hiddenAngle, ...wrongAnswers.slice(0, 3)];
                this.shuffleArray(options);

                return {
                    type: 'triangle',
                    question: questionText,
                    options: options.map(angle => `${angle}¬∞`),
                    correctAnswer: `${hiddenAngle}¬∞`,
                    explanation: `La suma de los √°ngulos internos de un tri√°ngulo es 180¬∞. Por lo tanto: 180¬∞ - ${visibleAngles[0]}¬∞ - ${visibleAngles[1]}¬∞ = ${hiddenAngle}¬∞`
                };
            }

            generateQuadrilateralQuestion() {
                // Generate three random angles, calculate the fourth
                const angle1 = Math.floor(Math.random() * 80) + 30; // 30-110¬∞
                const angle2 = Math.floor(Math.random() * 80) + 30;
                const angle3 = Math.floor(Math.random() * (200 - angle1 - angle2)) + 30;
                const angle4 = 360 - angle1 - angle2 - angle3;

                const angles = [angle1, angle2, angle3, angle4];
                const hiddenIndex = Math.floor(Math.random() * 4);
                const hiddenAngle = angles[hiddenIndex];

                // Create question text
                const visibleAngles = angles.filter((_, index) => index !== hiddenIndex);
                const questionText = `En un cuadril√°tero, tres de los √°ngulos miden ${visibleAngles[0]}¬∞, ${visibleAngles[1]}¬∞ y ${visibleAngles[2]}¬∞. ¬øCu√°nto mide el cuarto √°ngulo?`;

                // Generate wrong answers
                const wrongAnswers = [
                    hiddenAngle + Math.floor(Math.random() * 30) + 15,
                    hiddenAngle - Math.floor(Math.random() * 30) - 15,
                    Math.floor(Math.random() * 120) + 60
                ].filter(angle => angle > 0 && angle < 180 && angle !== hiddenAngle);

                // Ensure we have exactly 3 wrong answers
                while (wrongAnswers.length < 3) {
                    const wrongAngle = Math.floor(Math.random() * 150) + 30;
                    if (wrongAngle !== hiddenAngle && !wrongAnswers.includes(wrongAngle)) {
                        wrongAnswers.push(wrongAngle);
                    }
                }

                const options = [hiddenAngle, ...wrongAnswers.slice(0, 3)];
                this.shuffleArray(options);

                return {
                    type: 'quadrilateral',
                    question: questionText,
                    options: options.map(angle => `${angle}¬∞`),
                    correctAnswer: `${hiddenAngle}¬∞`,
                    explanation: `La suma de los √°ngulos internos de un cuadril√°tero es 360¬∞. Por lo tanto: 360¬∞ - ${visibleAngles[0]}¬∞ - ${visibleAngles[1]}¬∞ - ${visibleAngles[2]}¬∞ = ${hiddenAngle}¬∞`
                };
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            start() {
                this.currentQuestion = 0;
                this.score = 0;
                this.generateQuestions();
                this.showQuestion();
            }

            showQuestion() {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                if (this.currentQuestion >= this.questions.length) {
                    this.showResults();
                    return;
                }

                const question = this.questions[this.currentQuestion];

                let questionHTML = `
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <h4 class="text-lg font-semibold text-gray-800">Pregunta ${this.currentQuestion + 1} de ${this.totalQuestions}</h4>
                            <div class="text-sm text-gray-600">Puntuaci√≥n: ${this.score}/${this.currentQuestion}</div>
                        </div>
                        
                        <div class="bg-white p-4 rounded-lg border-l-4 border-blue-500">
                            <p class="text-gray-800 font-medium">${question.question}</p>
                        </div>
                `;

                if (question.type === 'multiple-choice') {
                    questionHTML += `
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            ${question.options.map((option, index) => `
                                <button class="option-btn bg-white hover:bg-blue-50 border-2 border-gray-200 hover:border-blue-300 p-3 rounded-lg text-left transition-colors touch-target interactive-element" data-answer="${option}">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </button>
                            `).join('')}
                        </div>
                    `;
                } else if (question.type === 'calculation') {
                    questionHTML += `
                        <div class="space-y-4">
                            <div class="flex flex-col sm:flex-row gap-4 items-end">
                                <div class="flex-1">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Tu respuesta:</label>
                                    <input type="number" id="calculationInput" class="w-full p-3 border border-gray-300 rounded-lg text-base touch-target" placeholder="Ingresa tu respuesta" step="0.1">
                                </div>
                                <button id="submitCalculation" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors touch-target interactive-element">
                                    Verificar
                                </button>
                            </div>
                        </div>
                    `;
                }

                questionHTML += `
                        <div id="feedback" class="hidden"></div>
                    </div>
                `;

                container.innerHTML = questionHTML;

                // Start question timer
                feedbackSystem.startQuestionTimer();

                // Add event listeners based on question type
                if (question.type === 'multiple-choice') {
                    container.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => this.checkAnswer(e.target.dataset.answer, question));
                    });
                } else if (question.type === 'calculation') {
                    const submitBtn = document.getElementById('submitCalculation');
                    const input = document.getElementById('calculationInput');
                    
                    const submitAnswer = () => {
                        const userAnswer = parseFloat(input.value);
                        if (!isNaN(userAnswer)) {
                            this.checkCalculationAnswer(userAnswer, question);
                        }
                    };

                    submitBtn.addEventListener('click', submitAnswer);
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            submitAnswer();
                        }
                    });
                }
            }

            checkAnswer(selectedAnswer, question) {
                // Use feedback system for validation and feedback
                const result = feedbackSystem.validateResponse(selectedAnswer, question.correctAnswer, question);
                
                // Add visual feedback to selected button
                const selectedButton = document.querySelector(`[data-answer="${selectedAnswer}"]`);
                if (selectedButton) {
                    if (typeof animateButtonPress === 'function') animateButtonPress(selectedButton);
                    if (typeof addVisualFeedback === 'function') addVisualFeedback(selectedButton, result.isCorrect ? 'success' : 'error');
                }

                // Display comprehensive feedback
                feedbackSystem.displayFeedback(result);

                if (result.isCorrect) {
                    this.score++;
                }

                // Disable all buttons
                document.querySelectorAll('.option-btn').forEach(btn => {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                });

                // Show next question after delay
                setTimeout(() => {
                    this.currentQuestion++;
                    if (this.currentQuestion >= this.questions.length) {
                        this.showResults();
                    } else {
                        this.showQuestion();
                    }
                }, 3000);
            }

            checkCalculationAnswer(userAnswer, question) {
                const tolerance = question.tolerance || 1;
                
                // Use feedback system for validation and feedback
                const result = feedbackSystem.validateResponse(userAnswer, question.correctAnswer, question, tolerance);
                
                // Display comprehensive feedback
                feedbackSystem.displayFeedback(result);

                if (result.isCorrect) {
                    this.score++;
                }

                // Disable input and button
                const input = document.getElementById('calculationInput');
                const submitBtn = document.getElementById('submitCalculation');
                if (input) input.disabled = true;
                if (submitBtn) {
                    submitBtn.disabled = true;
                    submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                }

                // Show next question after delay
                setTimeout(() => {
                    this.currentQuestion++;
                    if (this.currentQuestion >= this.questions.length) {
                        this.showResults();
                    } else {
                        this.showQuestion();
                    }
                }, 3000);
            }

            showFeedback(isCorrect, explanation, userAnswer, correctAnswer) {
                const feedbackDiv = document.getElementById('feedback');
                if (!feedbackDiv) return;

                const bgColor = isCorrect ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200';
                const textColor = isCorrect ? 'text-green-800' : 'text-red-800';
                const icon = isCorrect ? '‚úì' : '‚úó';
                const title = isCorrect ? '¬°Correcto!' : 'Incorrecto';

                let feedbackContent = `
                    <div class="p-4 rounded-lg border-2 ${bgColor} ${textColor}">
                        <div class="flex items-center mb-2">
                            <span class="text-2xl mr-2">${icon}</span>
                            <h5 class="font-semibold text-lg">${title}</h5>
                        </div>
                `;

                if (!isCorrect) {
                    feedbackContent += `
                        <p class="mb-2">
                            <strong>Tu respuesta:</strong> ${userAnswer}<br>
                            <strong>Respuesta correcta:</strong> ${correctAnswer}
                        </p>
                    `;
                }

                feedbackContent += `
                        <p class="text-sm">${explanation}</p>
                    </div>
                `;

                feedbackDiv.innerHTML = feedbackContent;
                feedbackDiv.classList.remove('hidden');
                feedbackDiv.classList.add('content-fade-in');

                // Show notification
                if (typeof showNotification === 'function') {
                    showNotification(isCorrect ? '¬°Respuesta correcta!' : 'Respuesta incorrecta', isCorrect ? 'success' : 'error', 2000);
                }
            }

            showResults() {
                // Save session and display comprehensive results
                feedbackSystem.saveSession();
                feedbackSystem.displayResults();
                
                // Add restart event listener
                document.addEventListener('restartEvaluation', (e) => {
                    if (e.detail.moduleId === 'suma-angulos') {
                        this.start();
                    }
                }, { once: true });
            }
        }

        // Evaluation System for Circunferencia module
        class CircleEvaluation {
            constructor() {
                this.currentQuestion = 0;
                this.score = 0;
                this.questions = [];
                this.totalQuestions = 5;
            }

            generateQuestions() {
                this.questions = [];
                
                // Use centralized question generator
                const generatedQuestions = questionGenerator.generateQuestionSet('circunferencia', this.totalQuestions, 'medium');
                
                // Convert to the format expected by this evaluation class
                this.questions = generatedQuestions.map(q => {
                    if (q.type === 'identification') {
                        return {
                            type: 'identification',
                            question: q.question,
                            visualElement: q.targetElement,
                            options: q.options,
                            correctAnswer: q.correctAnswer,
                            explanation: q.explanation,
                            difficulty: q.difficulty
                        };
                    } else if (q.type === 'calculation') {
                        return {
                            type: 'calculation',
                            question: q.question,
                            correctAnswer: q.correctAnswer,
                            tolerance: q.tolerance || 0.5,
                            explanation: q.explanation,
                            difficulty: q.difficulty
                        };
                    }
                });
            }

            generateIdentificationQuestion() {
                const elements = [
                    { name: 'centro', description: 'Punto interior equidistante de todos los puntos de la circunferencia', color: '#EF4444' },
                    { name: 'radio', description: 'Segmento que une el centro con cualquier punto de la circunferencia', color: '#10B981' },
                    { name: 'di√°metro', description: 'Segmento que pasa por el centro y une dos puntos de la circunferencia', color: '#3B82F6' },
                    { name: 'cuerda', description: 'Segmento que une dos puntos cualesquiera de la circunferencia', color: '#F59E0B' },
                    { name: 'arco', description: 'Porci√≥n de la circunferencia comprendida entre dos puntos', color: '#8B5CF6' },
                    { name: 'tangente', description: 'Recta que toca la circunferencia en un solo punto', color: '#06B6D4' }
                ];

                const correctElement = elements[Math.floor(Math.random() * elements.length)];
                const wrongElements = elements.filter(el => el.name !== correctElement.name);

                // Shuffle and take 3 wrong answers
                this.shuffleArray(wrongElements);
                const options = [correctElement.name, ...wrongElements.slice(0, 3).map(el => el.name)];
                this.shuffleArray(options);

                return {
                    type: 'identification',
                    question: `¬øC√≥mo se llama el elemento resaltado en color ${this.getColorName(correctElement.color)}?`,
                    visualElement: correctElement.name,
                    options: options.map(name => this.capitalizeFirst(name)),
                    correctAnswer: this.capitalizeFirst(correctElement.name),
                    explanation: `El ${correctElement.name} es ${correctElement.description.toLowerCase()}.`
                };
            }

            generateRelationshipQuestion() {
                const relationships = [
                    {
                        question: 'Si el radio de una circunferencia mide 5 cm, ¬øcu√°nto mide el di√°metro?',
                        correctAnswer: '10 cm',
                        wrongAnswers: ['5 cm', '15 cm', '2.5 cm'],
                        explanation: 'El di√°metro es el doble del radio. Si el radio es 5 cm, entonces el di√°metro es 5 √ó 2 = 10 cm.'
                    },
                    {
                        question: 'Si el di√°metro de una circunferencia mide 12 cm, ¬øcu√°nto mide el radio?',
                        correctAnswer: '6 cm',
                        wrongAnswers: ['12 cm', '24 cm', '3 cm'],
                        explanation: 'El radio es la mitad del di√°metro. Si el di√°metro es 12 cm, entonces el radio es 12 √∑ 2 = 6 cm.'
                    },
                    {
                        question: 'Si el radio de una circunferencia mide 8 cm, ¬øcu√°nto mide el di√°metro?',
                        correctAnswer: '16 cm',
                        wrongAnswers: ['8 cm', '4 cm', '24 cm'],
                        explanation: 'El di√°metro es el doble del radio. Si el radio es 8 cm, entonces el di√°metro es 8 √ó 2 = 16 cm.'
                    },
                    {
                        question: 'Si el di√°metro de una circunferencia mide 20 cm, ¬øcu√°nto mide el radio?',
                        correctAnswer: '10 cm',
                        wrongAnswers: ['20 cm', '40 cm', '5 cm'],
                        explanation: 'El radio es la mitad del di√°metro. Si el di√°metro es 20 cm, entonces el radio es 20 √∑ 2 = 10 cm.'
                    }
                ];

                const selectedRelationship = relationships[Math.floor(Math.random() * relationships.length)];
                const options = [selectedRelationship.correctAnswer, ...selectedRelationship.wrongAnswers];
                this.shuffleArray(options);

                return {
                    type: 'relationship',
                    question: selectedRelationship.question,
                    options: options,
                    correctAnswer: selectedRelationship.correctAnswer,
                    explanation: selectedRelationship.explanation
                };
            }

            getColorName(hexColor) {
                const colorNames = {
                    '#EF4444': 'rojo',
                    '#10B981': 'verde',
                    '#3B82F6': 'azul',
                    '#F59E0B': 'amarillo',
                    '#8B5CF6': 'morado',
                    '#06B6D4': 'cian'
                };
                return colorNames[hexColor] || 'desconocido';
            }

            capitalizeFirst(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            start() {
                this.currentQuestion = 0;
                this.score = 0;
                this.generateQuestions();
                this.showQuestion();
            }

            showQuestion() {
                const question = this.questions[this.currentQuestion];
                const container = document.getElementById('questionContainer');

                let visualContent = '';
                if (question.type === 'identification') {
                    visualContent = this.createVisualQuestion(question.visualElement);
                }

                container.innerHTML = `
                    <div class="mb-4">
                        <div class="flex justify-between items-center mb-4">
                            <h4 class="text-lg font-semibold">Pregunta ${this.currentQuestion + 1} de ${this.totalQuestions}</h4>
                            <div class="text-sm text-gray-600">Puntuaci√≥n: ${this.score}/${this.totalQuestions}</div>
                        </div>
                        
                        ${visualContent}
                        
                        <p class="text-gray-800 mb-4 text-lg">${question.question}</p>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            ${question.options.map((option, index) => `
                                <button class="option-btn p-3 text-left border border-gray-300 rounded-lg hover:bg-blue-50 hover:border-blue-300 transition-colors" 
                                        data-answer="${option}">
                                    ${String.fromCharCode(65 + index)}. ${option}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;

                // Add event listeners to option buttons
                container.querySelectorAll('.option-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.checkAnswer(e.target.dataset.answer);
                    });
                });

                // Render visual element if it's an identification question
                if (question.type === 'identification') {
                    setTimeout(() => this.renderVisualElement(question.visualElement), 50);
                }
            }

            createVisualQuestion(elementName) {
                const svgId = `question-svg-${this.currentQuestion}`;
                return `
                    <div class="mb-4 flex justify-center">
                        <svg id="${svgId}" width="200" height="200" viewBox="0 0 200 200" class="border border-gray-300 rounded">
                            <!-- Visual representation will be created by JavaScript -->
                        </svg>
                    </div>
                `;
            }

            renderVisualElement(elementName) {
                const svgId = `question-svg-${this.currentQuestion}`;
                const svg = document.getElementById(svgId);
                if (!svg) return;

                const center = { x: 100, y: 100 };
                const radius = 60;

                // Clear SVG
                svg.innerHTML = '';

                // Draw base circle (always visible but not highlighted)
                const baseCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                baseCircle.setAttribute('cx', center.x);
                baseCircle.setAttribute('cy', center.y);
                baseCircle.setAttribute('r', radius);
                baseCircle.setAttribute('fill', 'none');
                baseCircle.setAttribute('stroke', '#D1D5DB');
                baseCircle.setAttribute('stroke-width', '2');
                svg.appendChild(baseCircle);

                // Get element color
                const elements = {
                    'centro': '#EF4444',
                    'radio': '#10B981',
                    'di√°metro': '#3B82F6',
                    'cuerda': '#F59E0B',
                    'arco': '#8B5CF6',
                    'tangente': '#06B6D4'
                };

                const color = elements[elementName] || '#6B7280';

                // Render specific element highlighted
                switch (elementName) {
                    case 'centro':
                        const centerPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        centerPoint.setAttribute('cx', center.x);
                        centerPoint.setAttribute('cy', center.y);
                        centerPoint.setAttribute('r', '6');
                        centerPoint.setAttribute('fill', color);
                        centerPoint.setAttribute('stroke', '#FFFFFF');
                        centerPoint.setAttribute('stroke-width', '2');
                        svg.appendChild(centerPoint);
                        break;

                    case 'radio':
                        const radiusLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        radiusLine.setAttribute('x1', center.x);
                        radiusLine.setAttribute('y1', center.y);
                        radiusLine.setAttribute('x2', center.x + radius);
                        radiusLine.setAttribute('y2', center.y);
                        radiusLine.setAttribute('stroke', color);
                        radiusLine.setAttribute('stroke-width', '4');
                        svg.appendChild(radiusLine);
                        break;

                    case 'di√°metro':
                        const diameterLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        diameterLine.setAttribute('x1', center.x - radius);
                        diameterLine.setAttribute('y1', center.y);
                        diameterLine.setAttribute('x2', center.x + radius);
                        diameterLine.setAttribute('y2', center.y);
                        diameterLine.setAttribute('stroke', color);
                        diameterLine.setAttribute('stroke-width', '4');
                        svg.appendChild(diameterLine);
                        break;

                    case 'cuerda':
                        const chordLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        const chordAngle1 = Math.PI / 4;
                        const chordAngle2 = (3 * Math.PI) / 4;
                        const chord1X = center.x + radius * Math.cos(chordAngle1);
                        const chord1Y = center.y + radius * Math.sin(chordAngle1);
                        const chord2X = center.x + radius * Math.cos(chordAngle2);
                        const chord2Y = center.y + radius * Math.sin(chordAngle2);

                        chordLine.setAttribute('x1', chord1X);
                        chordLine.setAttribute('y1', chord1Y);
                        chordLine.setAttribute('x2', chord2X);
                        chordLine.setAttribute('y2', chord2Y);
                        chordLine.setAttribute('stroke', color);
                        chordLine.setAttribute('stroke-width', '4');
                        svg.appendChild(chordLine);
                        break;

                    case 'arco':
                        const arcPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const arcStartAngle = -Math.PI / 3;
                        const arcEndAngle = Math.PI / 6;
                        const arcStartX = center.x + radius * Math.cos(arcStartAngle);
                        const arcStartY = center.y + radius * Math.sin(arcStartAngle);
                        const arcEndX = center.x + radius * Math.cos(arcEndAngle);
                        const arcEndY = center.y + radius * Math.sin(arcEndAngle);

                        const arcPathData = `M ${arcStartX} ${arcStartY} A ${radius} ${radius} 0 0 1 ${arcEndX} ${arcEndY}`;
                        arcPath.setAttribute('d', arcPathData);
                        arcPath.setAttribute('fill', 'none');
                        arcPath.setAttribute('stroke', color);
                        arcPath.setAttribute('stroke-width', '5');
                        svg.appendChild(arcPath);
                        break;

                    case 'tangente':
                        const tangentLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        const tangentPointX = center.x;
                        const tangentPointY = center.y - radius;
                        tangentLine.setAttribute('x1', tangentPointX - 40);
                        tangentLine.setAttribute('y1', tangentPointY);
                        tangentLine.setAttribute('x2', tangentPointX + 40);
                        tangentLine.setAttribute('y2', tangentPointY);
                        tangentLine.setAttribute('stroke', color);
                        tangentLine.setAttribute('stroke-width', '4');
                        svg.appendChild(tangentLine);
                        break;
                }
            }

            checkAnswer(selectedAnswer) {
                const question = this.questions[this.currentQuestion];
                const isCorrect = selectedAnswer === question.correctAnswer;

                if (isCorrect) {
                    this.score++;
                }

                this.showFeedback(isCorrect, question.explanation);
            }

            showFeedback(isCorrect, explanation) {
                const container = document.getElementById('questionContainer');

                container.innerHTML = `
                    <div class="text-center">
                        <div class="mb-4">
                            <div class="text-6xl mb-2">${isCorrect ? '‚úÖ' : '‚ùå'}</div>
                            <h3 class="text-2xl font-bold ${isCorrect ? 'text-green-600' : 'text-red-600'}">
                                ${isCorrect ? '¬°Correcto!' : 'Incorrecto'}
                            </h3>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg mb-6">
                            <p class="text-gray-700">${explanation}</p>
                        </div>
                        
                        <button id="nextQuestion" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg transition-colors">
                            ${this.currentQuestion < this.totalQuestions - 1 ? 'Siguiente Pregunta' : 'Ver Resultados'}
                        </button>
                    </div>
                `;

                document.getElementById('nextQuestion').addEventListener('click', () => {
                    this.currentQuestion++;
                    if (this.currentQuestion < this.totalQuestions) {
                        this.showQuestion();
                    } else {
                        this.showResults();
                    }
                });
            }

            showResults() {
                const container = document.getElementById('questionContainer');
                const percentage = Math.round((this.score / this.totalQuestions) * 100);

                let message = '';
                let emoji = '';
                if (percentage >= 80) {
                    message = '¬°Excelente trabajo!';
                    emoji = 'üéâ';
                } else if (percentage >= 60) {
                    message = '¬°Buen trabajo!';
                    emoji = 'üëç';
                } else {
                    message = 'Sigue practicando';
                    emoji = 'üí™';
                }

                container.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4">${emoji}</div>
                        <h3 class="text-2xl font-bold text-blue-600 mb-2">${message}</h3>
                        <p class="text-xl text-gray-700 mb-4">
                            Puntuaci√≥n final: ${this.score}/${this.totalQuestions} (${percentage}%)
                        </p>
                        
                        <div class="bg-blue-50 p-4 rounded-lg mb-6">
                            <p class="text-gray-700">
                                ${percentage >= 80 ?
                        'Dominas muy bien los elementos de la circunferencia.' :
                        percentage >= 60 ?
                            'Tienes un buen conocimiento de los elementos de la circunferencia.' :
                            'Te recomendamos repasar la teor√≠a y practicar m√°s con los elementos interactivos.'
                    }
                            </p>
                        </div>
                        
                        <button id="restartEvaluation" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors">
                            Intentar de Nuevo
                        </button>
                    </div>
                `;

                document.getElementById('restartEvaluation').addEventListener('click', () => {
                    this.start();
                });
            }
        }

        // Initialize circle evaluation when circunferencia evaluation tab is loaded
        let circleEvaluationInstance = null;

        function initCircleEvaluation() {
            const container = document.getElementById('questionContainer');
            if (container && !circleEvaluationInstance) {
                circleEvaluationInstance = new CircleEvaluation();
                circleEvaluationInstance.start();
            }
        }

        // Initialize angle evaluation when suma-angulos evaluation tab is loaded
        let angleEvaluationInstance = null;

        function initAngleEvaluation() {
            const container = document.getElementById('questionContainer');
            if (container && !angleEvaluationInstance) {
                angleEvaluationInstance = new AngleEvaluation();
                angleEvaluationInstance.start();
            }
        }

        // Pi Evaluation Class for dynamic calculation problems
        class PiEvaluation {
            constructor() {
                this.currentQuestion = 0;
                this.score = 0;
                this.totalQuestions = 5;
                this.questions = [];
                this.tolerance = 0.5; // Tolerance for answer validation
            }

            start() {
                this.generateQuestions();
                this.displayQuestion();
            }

            generateQuestions() {
                this.questions = [];
                
                // Use centralized question generator
                const generatedQuestions = questionGenerator.generateQuestionSet('numero-pi', this.totalQuestions, 'medium');
                
                // Convert to the format expected by this evaluation class
                this.questions = generatedQuestions.map(q => {
                    if (q.type === 'calculation') {
                        return {
                            type: 'calculation',
                            text: q.question,
                            correctAnswer: q.correctAnswer,
                            tolerance: q.tolerance || 0.1,
                            explanation: q.explanation,
                            difficulty: q.difficulty
                        };
                    } else if (q.type === 'multiple-choice') {
                        return {
                            type: 'multiple-choice',
                            text: q.question,
                            options: q.options,
                            correctAnswer: q.correctAnswer,
                            explanation: q.explanation,
                            difficulty: q.difficulty
                        };
                    }
                });
            }

            displayQuestion() {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                if (this.currentQuestion >= this.totalQuestions) {
                    this.showResults();
                    return;
                }

                const question = this.questions[this.currentQuestion];

                container.innerHTML = `
                    <div class="space-y-6">
                        <div class="flex justify-between items-center">
                            <h4 class="text-lg font-semibold text-gray-800">
                                Pregunta ${this.currentQuestion + 1} de ${this.totalQuestions}
                            </h4>
                            <div class="text-sm text-gray-600">
                                Puntuaci√≥n: ${this.score}/${this.currentQuestion}
                            </div>
                        </div>
                        
                        <div class="bg-white p-6 rounded-lg border border-gray-200">
                            <p class="text-lg text-gray-800 mb-4">${question.text}</p>
                            <p class="text-sm text-gray-600 mb-4">Usa œÄ ‚âà 3.14 para tus c√°lculos</p>
                            
                            <div class="flex items-center space-x-4">
                                <input type="number" 
                                       id="answerInput" 
                                       class="flex-1 p-3 border border-gray-300 rounded-lg text-lg"
                                       placeholder="Ingresa tu respuesta"
                                       step="0.01">
                                <span class="text-gray-600">cm</span>
                                <button id="submitAnswer" 
                                        class="bg-purple-500 hover:bg-purple-600 text-white px-6 py-3 rounded-lg transition-colors">
                                    Verificar
                                </button>
                            </div>
                        </div>
                        
                        <div id="feedback" class="hidden">
                            <!-- Feedback will be shown here -->
                        </div>
                    </div>
                `;

                // Setup event listeners
                const submitButton = document.getElementById('submitAnswer');
                const answerInput = document.getElementById('answerInput');

                const submitAnswer = () => this.checkAnswer();

                submitButton.addEventListener('click', submitAnswer);
                answerInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        submitAnswer();
                    }
                });

                // Focus on input
                answerInput.focus();
            }

            checkAnswer() {
                const answerInput = document.getElementById('answerInput');
                const feedbackDiv = document.getElementById('feedback');
                const submitButton = document.getElementById('submitAnswer');

                const userAnswer = parseFloat(answerInput.value);
                const question = this.questions[this.currentQuestion];

                if (isNaN(userAnswer)) {
                    this.showFeedback('Por favor ingresa un n√∫mero v√°lido.', 'error');
                    return;
                }

                const isCorrect = Math.abs(userAnswer - question.correctAnswer) <= this.tolerance;

                if (isCorrect) {
                    this.score++;
                    this.showFeedback(
                        `¬°Correcto! ${question.solution}`,
                        'success',
                        question.formula
                    );
                } else {
                    this.showFeedback(
                        `Incorrecto. La respuesta correcta es ${question.solution}`,
                        'error',
                        `${question.formula}<br>Tu respuesta: ${userAnswer.toFixed(2)} cm`
                    );
                }

                // Disable input and change button
                answerInput.disabled = true;
                submitButton.textContent = 'Siguiente';
                submitButton.onclick = () => {
                    this.currentQuestion++;
                    this.displayQuestion();
                };
            }

            showFeedback(message, type, details = '') {
                const feedbackDiv = document.getElementById('feedback');
                const bgColor = type === 'success' ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200';
                const textColor = type === 'success' ? 'text-green-800' : 'text-red-800';

                feedbackDiv.innerHTML = `
                    <div class="${bgColor} border rounded-lg p-4">
                        <p class="${textColor} font-medium">${message}</p>
                        ${details ? `<div class="text-sm text-gray-600 mt-2">${details}</div>` : ''}
                    </div>
                `;
                feedbackDiv.classList.remove('hidden');
            }

            showResults() {
                const container = document.getElementById('questionContainer');
                const percentage = Math.round((this.score / this.totalQuestions) * 100);
                let message, bgColor, textColor;

                if (percentage >= 80) {
                    message = '¬°Excelente trabajo!';
                    bgColor = 'bg-green-50';
                    textColor = 'text-green-800';
                } else if (percentage >= 60) {
                    message = '¬°Buen trabajo!';
                    bgColor = 'bg-yellow-50';
                    textColor = 'text-yellow-800';
                } else {
                    message = 'Sigue practicando';
                    bgColor = 'bg-red-50';
                    textColor = 'text-red-800';
                }

                container.innerHTML = `
                    <div class="text-center space-y-6">
                        <div class="${bgColor} p-6 rounded-lg">
                            <h3 class="text-2xl font-bold ${textColor} mb-2">${message}</h3>
                            <p class="text-lg ${textColor}">
                                Puntuaci√≥n final: ${this.score}/${this.totalQuestions} (${percentage}%)
                            </p>
                        </div>
                        
                        <div class="bg-white p-6 rounded-lg border border-gray-200">
                            <h4 class="text-lg font-semibold text-gray-800 mb-4">Recordatorio de F√≥rmulas</h4>
                            <div class="grid md:grid-cols-2 gap-4 text-left">
                                <div class="bg-purple-50 p-4 rounded-lg">
                                    <p class="font-medium text-purple-800">Con radio:</p>
                                    <p class="text-sm text-gray-700">L = 2 √ó œÄ √ó r</p>
                                    <p class="text-sm text-gray-700">L = 2 √ó 3.14 √ó r</p>
                                </div>
                                <div class="bg-purple-50 p-4 rounded-lg">
                                    <p class="font-medium text-purple-800">Con di√°metro:</p>
                                    <p class="text-sm text-gray-700">L = œÄ √ó d</p>
                                    <p class="text-sm text-gray-700">L = 3.14 √ó d</p>
                                </div>
                            </div>
                        </div>
                        
                        <button id="restartEvaluation" 
                                class="bg-purple-500 hover:bg-purple-600 text-white px-6 py-3 rounded-lg transition-colors">
                            Intentar de Nuevo
                        </button>
                    </div>
                `;

                // Setup restart functionality
                document.getElementById('restartEvaluation').addEventListener('click', () => {
                    this.currentQuestion = 0;
                    this.score = 0;
                    this.start();
                });
            }
        }

        // Initialize pi evaluation when numero-pi evaluation tab is loaded
        let piEvaluationInstance = null;

        function initPiEvaluation() {
            const container = document.getElementById('questionContainer');
            if (container && !piEvaluationInstance) {
                piEvaluationInstance = new PiEvaluation();
                piEvaluationInstance.start();
            }
        }

        // Integration Tests for Evaluation Flow
        class EvaluationFlowTests {
            constructor() {
                this.testResults = [];
                this.testInstances = {};
            }

            assert(condition, message) {
                if (condition) {
                    this.testResults.push({ status: 'PASS', message });
                    return true;
                } else {
                    this.testResults.push({ status: 'FAIL', message });
                    return false;
                }
            }

            // Test complete question-answer-feedback cycle for Suma de √Ångulos
            testAngleEvaluationFlow() {
                try {
                    // Create test container
                    const testContainer = document.createElement('div');
                    testContainer.id = 'testEvaluationContainer';
                    testContainer.innerHTML = `
                        <div id="evaluationContent">
                            <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg"></div>
                        </div>
                    `;
                    document.body.appendChild(testContainer);

                    // Initialize evaluation instance
                    const evaluation = new AngleEvaluation();
                    this.testInstances.angleEvaluation = evaluation;
                    
                    // Test initialization
                    evaluation.init();
                    this.assert(evaluation.questions.length > 0, 'Angle evaluation generates questions');
                    this.assert(evaluation.currentQuestion === 0, 'Starts at first question');
                    this.assert(evaluation.score === 0, 'Initial score is zero');

                    // Test question display
                    const questionContainer = document.getElementById('questionContainer');
                    this.assert(questionContainer.innerHTML.length > 0, 'Question content is displayed');

                    // Test answer checking with correct answer
                    const initialScore = evaluation.score;
                    const firstQuestion = evaluation.questions[0];
                    evaluation.checkAnswer(firstQuestion.correctAnswer, firstQuestion);
                    this.assert(evaluation.score === initialScore + 1, 'Correct answer increases score');

                    // Test answer checking with incorrect answer
                    const scoreBeforeWrong = evaluation.score;
                    const wrongAnswer = firstQuestion.options ? 
                        firstQuestion.options.find(opt => opt !== firstQuestion.correctAnswer) : 
                        'wrong_answer';
                    evaluation.checkAnswer(wrongAnswer, firstQuestion);
                    this.assert(evaluation.score === scoreBeforeWrong, 'Incorrect answer does not increase score');

                    // Test progress tracking
                    const initialQuestion = evaluation.currentQuestion;
                    evaluation.nextQuestion();
                    this.assert(evaluation.currentQuestion === initialQuestion + 1, 'Progress tracking works correctly');

                    // Cleanup
                    document.body.removeChild(testContainer);

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Angle evaluation flow test error: ${error.message}` });
                }
            }

            // Test complete question-answer-feedback cycle for Circunferencia
            testCircleEvaluationFlow() {
                try {
                    // Create test container
                    const testContainer = document.createElement('div');
                    testContainer.id = 'testCircleEvaluationContainer';
                    testContainer.innerHTML = `
                        <div id="evaluationContent">
                            <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg"></div>
                        </div>
                    `;
                    document.body.appendChild(testContainer);

                    // Initialize evaluation instance
                    const evaluation = new CircleEvaluation();
                    this.testInstances.circleEvaluation = evaluation;
                    
                    // Test initialization
                    evaluation.init();
                    this.assert(evaluation.questions.length > 0, 'Circle evaluation generates questions');
                    this.assert(evaluation.currentQuestion === 0, 'Starts at first question');
                    this.assert(evaluation.score === 0, 'Initial score is zero');

                    // Test question display
                    const questionContainer = document.getElementById('questionContainer');
                    this.assert(questionContainer.innerHTML.length > 0, 'Question content is displayed');

                    // Test answer checking with correct answer
                    const initialScore = evaluation.score;
                    const firstQuestion = evaluation.questions[0];
                    evaluation.checkAnswer(firstQuestion.correctAnswer);
                    this.assert(evaluation.score === initialScore + 1, 'Correct answer increases score');

                    // Test answer checking with incorrect answer
                    const scoreBeforeWrong = evaluation.score;
                    const wrongAnswer = firstQuestion.options ? 
                        firstQuestion.options.find(opt => opt !== firstQuestion.correctAnswer) : 
                        'wrong_answer';
                    evaluation.checkAnswer(wrongAnswer);
                    this.assert(evaluation.score === scoreBeforeWrong, 'Incorrect answer does not increase score');

                    // Test progress tracking
                    const initialQuestion = evaluation.currentQuestion;
                    evaluation.nextQuestion();
                    this.assert(evaluation.currentQuestion === initialQuestion + 1, 'Progress tracking works correctly');

                    // Cleanup
                    document.body.removeChild(testContainer);

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Circle evaluation flow test error: ${error.message}` });
                }
            }

            // Test complete question-answer-feedback cycle for Pi calculations
            testPiEvaluationFlow() {
                try {
                    // Create test container
                    const testContainer = document.createElement('div');
                    testContainer.id = 'testPiEvaluationContainer';
                    testContainer.innerHTML = `
                        <div id="evaluationContent">
                            <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                <div id="answerInput"></div>
                                <div id="feedback"></div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(testContainer);

                    // Initialize evaluation instance
                    const evaluation = new PiEvaluation();
                    this.testInstances.piEvaluation = evaluation;
                    
                    // Test initialization
                    evaluation.start();
                    this.assert(evaluation.questions.length > 0, 'Pi evaluation generates questions');
                    this.assert(evaluation.currentQuestion === 0, 'Starts at first question');
                    this.assert(evaluation.score === 0, 'Initial score is zero');

                    // Test question display
                    const questionContainer = document.getElementById('questionContainer');
                    this.assert(questionContainer.innerHTML.length > 0, 'Question content is displayed');

                    // Test score calculation with correct answer
                    const initialScore = evaluation.score;
                    const firstQuestion = evaluation.questions[0];
                    
                    // Mock correct answer input
                    const answerInput = document.createElement('input');
                    answerInput.id = 'answerInput';
                    answerInput.value = firstQuestion.correctAnswer.toString();
                    questionContainer.appendChild(answerInput);
                    
                    evaluation.checkAnswer();
                    this.assert(evaluation.score === initialScore + 1, 'Correct pi answer increases score');

                    // Test score calculation with incorrect answer
                    const scoreBeforeWrong = evaluation.score;
                    answerInput.value = (parseFloat(firstQuestion.correctAnswer) + 10).toString();
                    evaluation.checkAnswer();
                    this.assert(evaluation.score === scoreBeforeWrong, 'Incorrect pi answer does not increase score');

                    // Cleanup
                    document.body.removeChild(testContainer);

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Pi evaluation flow test error: ${error.message}` });
                }
            }

            // Test feedback system integration
            testFeedbackSystemIntegration() {
                try {
                    // Test feedback system initialization
                    this.assert(typeof feedbackSystem !== 'undefined', 'Feedback system is available');
                    this.assert(typeof feedbackSystem.validateResponse === 'function', 'Feedback system has validateResponse method');
                    this.assert(typeof feedbackSystem.displayFeedback === 'function', 'Feedback system has displayFeedback method');

                    // Test feedback validation with correct answer
                    const testQuestion = {
                        id: 'test-1',
                        type: 'multiple-choice',
                        correctAnswer: 'correct_option',
                        explanation: 'Test explanation'
                    };

                    feedbackSystem.startQuestionTimer();
                    const correctResult = feedbackSystem.validateResponse('correct_option', 'correct_option', testQuestion);
                    this.assert(correctResult.isCorrect === true, 'Feedback system correctly validates correct answers');
                    this.assert(correctResult.responseTime > 0, 'Feedback system tracks response time');

                    // Test feedback validation with incorrect answer
                    feedbackSystem.startQuestionTimer();
                    const incorrectResult = feedbackSystem.validateResponse('wrong_option', 'correct_option', testQuestion);
                    this.assert(incorrectResult.isCorrect === false, 'Feedback system correctly validates incorrect answers');
                    this.assert(incorrectResult.feedback.length > 0, 'Feedback system provides feedback message');

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Feedback system integration test error: ${error.message}` });
                }
            }

            // Test score calculation and progress tracking across modules
            testScoreCalculationAndProgress() {
                try {
                    // Test question generator integration
                    this.assert(typeof questionGenerator !== 'undefined', 'Question generator is available');
                    
                    // Test question generation for different modules
                    const angleQuestions = questionGenerator.generateQuestionSet('suma-angulos', 3, 'medium');
                    this.assert(angleQuestions.length === 3, 'Question generator creates correct number of angle questions');
                    
                    const circleQuestions = questionGenerator.generateQuestionSet('circunferencia', 2, 'easy');
                    this.assert(circleQuestions.length === 2, 'Question generator creates correct number of circle questions');
                    
                    const piQuestions = questionGenerator.generateQuestionSet('numero-pi', 2, 'hard');
                    this.assert(piQuestions.length === 2, 'Question generator creates correct number of pi questions');

                    // Test question structure
                    if (angleQuestions.length > 0) {
                        const question = angleQuestions[0];
                        this.assert(question.hasOwnProperty('id'), 'Generated questions have ID');
                        this.assert(question.hasOwnProperty('type'), 'Generated questions have type');
                        this.assert(question.hasOwnProperty('question'), 'Generated questions have question text');
                        this.assert(question.hasOwnProperty('correctAnswer'), 'Generated questions have correct answer');
                    }

                    // Test difficulty scaling
                    const easyQuestions = questionGenerator.generateQuestionSet('suma-angulos', 2, 'easy');
                    const hardQuestions = questionGenerator.generateQuestionSet('suma-angulos', 2, 'hard');
                    this.assert(easyQuestions.length === 2, 'Easy questions generated correctly');
                    this.assert(hardQuestions.length === 2, 'Hard questions generated correctly');

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Score calculation and progress test error: ${error.message}` });
                }
            }

            // Test complete evaluation cycle end-to-end
            testCompleteEvaluationCycle() {
                try {
                    // Create test container for figure game evaluation
                    const testContainer = document.createElement('div');
                    testContainer.id = 'testFigureGameContainer';
                    testContainer.innerHTML = `
                        <div id="evaluationContent">
                            <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg">
                                <div id="gameContainer"></div>
                                <div id="scoreDisplay"></div>
                                <div id="feedbackDisplay"></div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(testContainer);

                    // Initialize figure game evaluation
                    const figureGame = new FigureIdentificationGame(document.getElementById('gameContainer'));
                    this.testInstances.figureGame = figureGame;

                    // Test initialization
                    figureGame.init();
                    this.assert(figureGame.score === 0, 'Figure game starts with zero score');
                    this.assert(figureGame.currentFigure !== null, 'Figure game generates initial figure');

                    // Test complete answer cycle
                    const initialScore = figureGame.score;
                    const correctAnswer = figureGame.currentFigure.name;
                    figureGame.checkAnswer(correctAnswer);
                    this.assert(figureGame.score === initialScore + 1, 'Correct figure identification increases score');

                    // Test incorrect answer
                    const scoreBeforeWrong = figureGame.score;
                    const wrongAnswers = ['sector', 'segment', 'corona'].filter(name => name !== correctAnswer);
                    if (wrongAnswers.length > 0) {
                        figureGame.checkAnswer(wrongAnswers[0]);
                        this.assert(figureGame.score === scoreBeforeWrong, 'Incorrect figure identification does not increase score');
                    }

                    // Test progress through multiple questions
                    const questionsAnswered = figureGame.questionsAnswered;
                    figureGame.nextQuestion();
                    this.assert(figureGame.questionsAnswered === questionsAnswered + 1, 'Question progress tracking works');

                    // Cleanup
                    document.body.removeChild(testContainer);

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Complete evaluation cycle test error: ${error.message}` });
                }
            }

            // Test line position evaluation flow
            testLinePositionEvaluationFlow() {
                try {
                    // Create test container
                    const testContainer = document.createElement('div');
                    testContainer.id = 'testLinePositionContainer';
                    testContainer.innerHTML = `
                        <div id="evaluationContent">
                            <div id="questionContainer" class="bg-gray-50 p-6 rounded-lg"></div>
                        </div>
                    `;
                    document.body.appendChild(testContainer);

                    // Initialize line position evaluation
                    const evaluation = new LinePositionEvaluation();
                    this.testInstances.linePositionEvaluation = evaluation;
                    
                    // Test initialization
                    evaluation.init();
                    this.assert(evaluation.questions.length > 0, 'Line position evaluation generates questions');
                    this.assert(evaluation.currentQuestion === 0, 'Starts at first question');
                    this.assert(evaluation.score === 0, 'Initial score is zero');

                    // Test question display
                    const questionContainer = document.getElementById('questionContainer');
                    this.assert(questionContainer.innerHTML.length > 0, 'Question content is displayed');

                    // Test answer checking with correct answer
                    const initialScore = evaluation.score;
                    const firstQuestion = evaluation.questions[0];
                    evaluation.checkAnswer(firstQuestion.position);
                    this.assert(evaluation.score === initialScore + 1, 'Correct position answer increases score');

                    // Test answer checking with incorrect answer
                    const scoreBeforeWrong = evaluation.score;
                    const wrongPositions = ['exterior', 'tangente', 'secante'].filter(pos => pos !== firstQuestion.position);
                    if (wrongPositions.length > 0) {
                        evaluation.checkAnswer(wrongPositions[0]);
                        this.assert(evaluation.score === scoreBeforeWrong, 'Incorrect position answer does not increase score');
                    }

                    // Test progress tracking
                    const initialQuestion = evaluation.currentQuestion;
                    evaluation.nextQuestion();
                    this.assert(evaluation.currentQuestion === initialQuestion + 1, 'Progress tracking works correctly');

                    // Cleanup
                    document.body.removeChild(testContainer);

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Line position evaluation flow test error: ${error.message}` });
                }
            }

            // Run all integration tests
            runAllTests() {
                console.log('üß™ Starting Evaluation Flow Integration Tests...');
                this.testResults = [];

                try {
                    this.testAngleEvaluationFlow();
                    this.testCircleEvaluationFlow();
                    this.testPiEvaluationFlow();
                    this.testLinePositionEvaluationFlow();
                    this.testFeedbackSystemIntegration();
                    this.testScoreCalculationAndProgress();
                    this.testCompleteEvaluationCycle();

                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Test execution error: ${error.message}` });
                } finally {
                    // Cleanup any remaining test instances
                    this.cleanupTestInstances();
                }

                // Report results
                this.reportResults();
                return this.testResults;
            }

            // Cleanup test instances
            cleanupTestInstances() {
                try {
                    // Clean up any test containers that might still exist
                    const testContainers = [
                        'testEvaluationContainer',
                        'testCircleEvaluationContainer', 
                        'testPiEvaluationContainer',
                        'testLinePositionContainer',
                        'testFigureGameContainer'
                    ];
                    
                    testContainers.forEach(containerId => {
                        const container = document.getElementById(containerId);
                        if (container && container.parentNode) {
                            container.parentNode.removeChild(container);
                        }
                    });

                    // Reset test instances
                    this.testInstances = {};
                } catch (error) {
                    console.warn('Cleanup warning:', error.message);
                }
            }

            // Report test results
            reportResults() {
                const passed = this.testResults.filter(r => r.status === 'PASS').length;
                const failed = this.testResults.filter(r => r.status === 'FAIL').length;
                const errors = this.testResults.filter(r => r.status === 'ERROR').length;

                console.log(`\nüìä Evaluation Flow Integration Test Results:`);
                console.log(`‚úÖ Passed: ${passed}`);
                console.log(`‚ùå Failed: ${failed}`);
                console.log(`üö® Errors: ${errors}`);
                console.log(`üìà Total: ${this.testResults.length}`);

                if (failed > 0 || errors > 0) {
                    console.log('\n‚ùå Failed/Error Tests:');
                    this.testResults
                        .filter(r => r.status !== 'PASS')
                        .forEach(result => {
                            console.log(`${result.status}: ${result.message}`);
                        });
                }
            }
        }

        // Initialize app when DOM is loaded
        // Unit Tests for Angle Calculations
        // Unit Tests for Pi Calculations - Circumference Calculator
        class PiCalculationTests {
            constructor() {
                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;
            }

            // Test helper method
            assert(condition, testName, message = '') {
                this.totalTests++;
                const passed = condition;

                if (passed) {
                    this.passedTests++;
                    console.log(`‚úÖ ${testName}: PASSED`);
                } else {
                    console.log(`‚ùå ${testName}: FAILED - ${message}`);
                }

                this.testResults.push({
                    status: passed ? 'PASS' : 'FAIL',
                    name: testName,
                    passed,
                    message: message
                });

                return passed;
            }

            // Test helper for approximate equality (for floating point comparisons)
            assertAlmostEqual(actual, expected, tolerance, testName, message = '') {
                this.totalTests++;
                const diff = Math.abs(actual - expected);
                const passed = diff <= tolerance;

                if (passed) {
                    this.passedTests++;
                    console.log(`‚úÖ ${testName}: PASSED (${actual} ‚âà ${expected})`);
                } else {
                    console.log(`‚ùå ${testName}: FAILED - Expected ${expected}, got ${actual}, diff: ${diff} > ${tolerance}. ${message}`);
                }

                this.testResults.push({
                    status: passed ? 'PASS' : 'FAIL',
                    name: testName,
                    passed,
                    message: message || `Expected ${expected}, got ${actual}, tolerance: ${tolerance}`
                });

                return passed;
            }

            // Test circumference calculation accuracy with radius
            testCircumferenceFromRadius() {
                console.log('\nüîç Testing circumference calculation from radius...');

                // Test case 1: radius = 5
                const radius1 = 5;
                const expectedExact1 = 2 * Math.PI * radius1; // ~31.416
                const expectedApprox1 = 2 * 3.14 * radius1; // 31.4

                // Create temporary calculator instance
                const calculator = new CircumferenceCalculator();

                // Mock the display method to capture results
                let capturedExact, capturedApprox;
                const originalDisplay = calculator.displayResult;
                calculator.displayResult = function (circumference, inputType, inputValue) {
                    capturedExact = circumference;
                    capturedApprox = (inputType === 'radio' ? 2 * 3.14 * inputValue : 3.14 * inputValue);
                };

                calculator.calculateFromRadius(radius1);

                this.assertAlmostEqual(capturedExact, expectedExact1, 0.001,
                    'Radius 5 - Exact calculation',
                    'Should use Math.PI for precise calculation');

                this.assertAlmostEqual(capturedApprox, expectedApprox1, 0.001,
                    'Radius 5 - Approximate calculation',
                    'Should use 3.14 for approximate calculation');

                // Test case 2: radius = 10
                const radius2 = 10;
                const expectedExact2 = 2 * Math.PI * radius2; // ~62.832
                const expectedApprox2 = 2 * 3.14 * radius2; // 62.8

                calculator.calculateFromRadius(radius2);

                this.assertAlmostEqual(capturedExact, expectedExact2, 0.001,
                    'Radius 10 - Exact calculation');

                this.assertAlmostEqual(capturedApprox, expectedApprox2, 0.001,
                    'Radius 10 - Approximate calculation');

                // Test case 3: radius = 1 (unit circle)
                const radius3 = 1;
                const expectedExact3 = 2 * Math.PI; // ~6.283
                const expectedApprox3 = 2 * 3.14; // 6.28

                calculator.calculateFromRadius(radius3);

                this.assertAlmostEqual(capturedExact, expectedExact3, 0.001,
                    'Unit circle - Exact calculation');

                this.assertAlmostEqual(capturedApprox, expectedApprox3, 0.001,
                    'Unit circle - Approximate calculation');

                // Restore original display method
                calculator.displayResult = originalDisplay;
            }

            // Test circumference calculation accuracy with diameter
            testCircumferenceFromDiameter() {
                console.log('\nüîç Testing circumference calculation from diameter...');

                // Test case 1: diameter = 10
                const diameter1 = 10;
                const expectedExact1 = Math.PI * diameter1; // ~31.416
                const expectedApprox1 = 3.14 * diameter1; // 31.4

                const calculator = new CircumferenceCalculator();

                // Mock the display method to capture results
                let capturedExact, capturedApprox;
                calculator.displayResult = function (circumference, inputType, inputValue) {
                    capturedExact = circumference;
                    capturedApprox = (inputType === 'radio' ? 2 * 3.14 * inputValue : 3.14 * inputValue);
                };

                calculator.calculateFromDiameter(diameter1);

                this.assertAlmostEqual(capturedExact, expectedExact1, 0.001,
                    'Diameter 10 - Exact calculation');

                this.assertAlmostEqual(capturedApprox, expectedApprox1, 0.001,
                    'Diameter 10 - Approximate calculation');

                // Test case 2: diameter = 6
                const diameter2 = 6;
                const expectedExact2 = Math.PI * diameter2; // ~18.85
                const expectedApprox2 = 3.14 * diameter2; // 18.84

                calculator.calculateFromDiameter(diameter2);

                this.assertAlmostEqual(capturedExact, expectedExact2, 0.001,
                    'Diameter 6 - Exact calculation');

                this.assertAlmostEqual(capturedApprox, expectedApprox2, 0.001,
                    'Diameter 6 - Approximate calculation');
            }

            // Test input validation logic
            testInputValidation() {
                console.log('\nüîç Testing input validation logic...');

                // Test valid positive numbers
                this.assert(!isNaN(5) && 5 > 0,
                    'Valid positive integer',
                    'Should accept positive integers');

                this.assert(!isNaN(3.14) && 3.14 > 0,
                    'Valid positive decimal',
                    'Should accept positive decimals');

                this.assert(!isNaN(0.5) && 0.5 > 0,
                    'Valid small positive number',
                    'Should accept small positive numbers');

                // Test invalid inputs
                this.assert(isNaN('abc') || 'abc' <= 0,
                    'Invalid text input',
                    'Should reject non-numeric text');

                this.assert(isNaN(-5) || -5 <= 0,
                    'Invalid negative number',
                    'Should reject negative numbers');

                this.assert(isNaN(0) || 0 <= 0,
                    'Invalid zero input',
                    'Should reject zero');

                this.assert(isNaN('') || '' <= 0,
                    'Invalid empty input',
                    'Should reject empty strings');

                // Test edge cases
                this.assert(!isNaN(Number.MAX_SAFE_INTEGER) && Number.MAX_SAFE_INTEGER > 0,
                    'Very large number',
                    'Should handle very large numbers');

                this.assert(!isNaN(Number.MIN_VALUE) && Number.MIN_VALUE > 0,
                    'Very small positive number',
                    'Should handle very small positive numbers');
            }

            // Test radius-diameter relationship
            testRadiusDiameterRelationship() {
                console.log('\nüîç Testing radius-diameter relationship...');

                const testCases = [
                    { radius: 5, expectedDiameter: 10 },
                    { radius: 3.5, expectedDiameter: 7 },
                    { radius: 1, expectedDiameter: 2 },
                    { radius: 0.5, expectedDiameter: 1 }
                ];

                testCases.forEach((testCase, index) => {
                    const calculatedDiameter = testCase.radius * 2;
                    this.assertAlmostEqual(calculatedDiameter, testCase.expectedDiameter, 0.001,
                        `Radius to diameter conversion ${index + 1}`,
                        `Radius ${testCase.radius} should give diameter ${testCase.expectedDiameter}`);

                    const calculatedRadius = testCase.expectedDiameter / 2;
                    this.assertAlmostEqual(calculatedRadius, testCase.radius, 0.001,
                        `Diameter to radius conversion ${index + 1}`,
                        `Diameter ${testCase.expectedDiameter} should give radius ${testCase.radius}`);
                });
            }

            // Test pi approximation accuracy
            testPiApproximationAccuracy() {
                console.log('\nüîç Testing pi approximation accuracy...');

                const piExact = Math.PI; // ~3.14159...
                const piApprox = 3.14;
                const tolerance = Math.abs(piExact - piApprox);

                this.assertAlmostEqual(piApprox, piExact, 0.01,
                    'Pi approximation within 0.01',
                    'œÄ ‚âà 3.14 should be close enough for educational purposes');

                // Test that the approximation error is reasonable for different calculations
                const testRadius = 10;
                const exactCircumference = 2 * piExact * testRadius;
                const approxCircumference = 2 * piApprox * testRadius;
                const errorPercentage = Math.abs(exactCircumference - approxCircumference) / exactCircumference * 100;

                this.assert(errorPercentage < 1,
                    'Approximation error under 1%',
                    `Error percentage: ${errorPercentage.toFixed(3)}%`);
            }

            // Test formula consistency
            testFormulaConsistency() {
                console.log('\nüîç Testing formula consistency...');

                const radius = 7;
                const diameter = radius * 2; // 14

                // Calculate circumference using both formulas
                const circumferenceFromRadius = 2 * Math.PI * radius;
                const circumferenceFromDiameter = Math.PI * diameter;

                this.assertAlmostEqual(circumferenceFromRadius, circumferenceFromDiameter, 0.001,
                    'Formula consistency check',
                    'L = 2œÄr should equal L = œÄd when d = 2r');

                // Test with approximation
                const approxFromRadius = 2 * 3.14 * radius;
                const approxFromDiameter = 3.14 * diameter;

                this.assertAlmostEqual(approxFromRadius, approxFromDiameter, 0.001,
                    'Approximation formula consistency',
                    'Approximate formulas should also be consistent');
            }

            // Run all pi calculation tests
            runAllTests() {
                console.log('üß™ Starting Pi Calculation Unit Tests...\n');

                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;

                try {
                    this.testCircumferenceFromRadius();
                    this.testCircumferenceFromDiameter();
                    this.testInputValidation();
                    this.testRadiusDiameterRelationship();
                    this.testPiApproximationAccuracy();
                    this.testFormulaConsistency();
                } catch (error) {
                    console.error('‚ùå Test execution error:', error);
                    this.testResults.push({
                        status: 'ERROR',
                        name: 'Test Execution',
                        passed: false,
                        message: `Test execution error: ${error.message}`
                    });
                }

                // Report results
                console.log('\nüìä Pi Calculation Test Results Summary:');
                console.log(`‚úÖ Passed: ${this.passedTests}`);
                console.log(`‚ùå Failed: ${this.totalTests - this.passedTests}`);
                console.log(`üìà Total: ${this.totalTests}`);
                console.log(`üéØ Success Rate: ${((this.passedTests / this.totalTests) * 100).toFixed(1)}%`);

                if (this.passedTests < this.totalTests) {
                    console.log('\n‚ùå Failed Tests:');
                    this.testResults
                        .filter(r => !r.passed)
                        .forEach(result => {
                            console.log(`   ‚Ä¢ ${result.name}: ${result.message}`);
                        });
                }

                return {
                    passed: this.passedTests,
                    failed: this.totalTests - this.passedTests,
                    successRate: (this.passedTests / this.totalTests) * 100,
                    results: this.testResults
                };
            }
        }

        // Global function to run pi calculation tests from console
        function runPiTests() {
            const tester = new PiCalculationTests();
            return tester.runAllTests();
        }

        // Unit Tests for FigureIdentificationGame - Game Logic
        class FigureGameTests {
            constructor() {
                this.testResults = [];
                this.testInstance = null;
            }

            // Setup test environment
            setupTestEnvironment() {
                // Create temporary elements for testing
                const testSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                testSvg.setAttribute('width', '400');
                testSvg.setAttribute('height', '300');
                testSvg.setAttribute('id', 'testFigureGameSvg');
                testSvg.style.display = 'none';
                document.body.appendChild(testSvg);

                const testOptionsContainer = document.createElement('div');
                testOptionsContainer.setAttribute('id', 'testGameOptions');
                testOptionsContainer.style.display = 'none';
                document.body.appendChild(testOptionsContainer);

                const testScoreContainer = document.createElement('div');
                testScoreContainer.setAttribute('id', 'testGameScore');
                testScoreContainer.style.display = 'none';
                document.body.appendChild(testScoreContainer);

                // Initialize FigureIdentificationGame instance for testing
                this.testInstance = new FigureIdentificationGame(testSvg, testOptionsContainer, testScoreContainer);
            }

            // Cleanup test environment
            cleanupTestEnvironment() {
                const testSvg = document.getElementById('testFigureGameSvg');
                const testOptions = document.getElementById('testGameOptions');
                const testScore = document.getElementById('testGameScore');
                if (testSvg) testSvg.remove();
                if (testOptions) testOptions.remove();
                if (testScore) testScore.remove();
                this.testInstance = null;
            }

            // Test helper to assert conditions
            assert(condition, message) {
                if (condition) {
                    this.testResults.push({ status: 'PASS', message });
                    return true;
                } else {
                    this.testResults.push({ status: 'FAIL', message });
                    return false;
                }
            }

            // Test 1: Verify figure generation functionality
            testFigureGeneration() {
                const initialFigure = this.testInstance.currentFigure;
                this.assert(initialFigure !== null, 'Initial figure is generated on game initialization');
                
                const validFigures = ['sector', 'segment', 'corona'];
                this.assert(validFigures.includes(initialFigure.name), 'Generated figure is one of the valid types');
                
                // Test multiple generations
                const generatedFigures = new Set();
                for (let i = 0; i < 10; i++) {
                    this.testInstance.generateQuestion();
                    generatedFigures.add(this.testInstance.currentFigure.name);
                }
                
                this.assert(generatedFigures.size > 1, 'Multiple figure generations produce different figures');
            }

            // Test 2: Verify SVG figure rendering
            testFigureRendering() {
                // Test sector rendering
                this.testInstance.renderFigure('sector');
                const sectorPath = this.testInstance.svg.querySelector('path[fill*="239, 68, 68"]');
                this.assert(sectorPath !== null, 'Sector figure renders correctly with proper fill color');
                
                const sectorRadii = this.testInstance.svg.querySelectorAll('line[stroke="#DC2626"]');
                this.assert(sectorRadii.length === 2, 'Sector renders with two radii lines');

                // Test segment rendering
                this.testInstance.renderFigure('segment');
                const segmentPath = this.testInstance.svg.querySelector('path[fill*="59, 130, 246"]');
                this.assert(segmentPath !== null, 'Segment figure renders correctly with proper fill color');
                
                const segmentChord = this.testInstance.svg.querySelector('line[stroke="#1D4ED8"]');
                this.assert(segmentChord !== null, 'Segment renders with chord line');

                // Test corona rendering
                this.testInstance.renderFigure('corona');
                const coronaCircles = this.testInstance.svg.querySelectorAll('circle');
                this.assert(coronaCircles.length >= 3, 'Corona renders with multiple circles (base + outer + inner)');
                
                const innerCircle = this.testInstance.svg.querySelector('circle[fill="white"]');
                this.assert(innerCircle !== null, 'Corona renders with white inner circle');
            }

            // Test 3: Verify option generation and shuffling
            testOptionGeneration() {
                this.testInstance.generateOptions();
                
                const optionButtons = this.testInstance.optionsContainer.querySelectorAll('button');
                this.assert(optionButtons.length === 3, 'Generates exactly 3 option buttons');
                
                // Verify all options have proper structure
                let allOptionsValid = true;
                optionButtons.forEach(button => {
                    const hasLabel = button.querySelector('.font-semibold') !== null;
                    const hasDescription = button.querySelector('.text-sm') !== null;
                    if (!hasLabel || !hasDescription) {
                        allOptionsValid = false;
                    }
                });
                this.assert(allOptionsValid, 'All option buttons have proper label and description structure');
                
                // Test shuffling by generating multiple sets
                const optionSets = [];
                for (let i = 0; i < 5; i++) {
                    this.testInstance.generateOptions();
                    const buttons = this.testInstance.optionsContainer.querySelectorAll('button');
                    const labels = Array.from(buttons).map(btn => btn.querySelector('.font-semibold').textContent);
                    optionSets.push(labels.join(','));
                }
                
                const uniqueSets = new Set(optionSets);
                this.assert(uniqueSets.size > 1, 'Option shuffling produces different arrangements');
            }

            // Test 4: Verify answer checking logic
            testAnswerChecking() {
                // Set a known figure for testing
                this.testInstance.currentFigure = this.testInstance.figures[0]; // sector
                const initialScore = this.testInstance.score;
                
                // Test correct answer
                this.testInstance.checkAnswer('sector');
                this.assert(this.testInstance.score === initialScore + 1, 'Correct answer increases score by 1');
                
                // Test incorrect answer
                const scoreBeforeWrong = this.testInstance.score;
                this.testInstance.checkAnswer('segment');
                this.assert(this.testInstance.score === scoreBeforeWrong, 'Incorrect answer does not increase score');
            }

            // Test 5: Verify scoring system
            testScoringSystem() {
                const initialScore = this.testInstance.score;
                
                // Test score initialization
                this.assert(typeof initialScore === 'number', 'Score is initialized as a number');
                this.assert(initialScore >= 0, 'Initial score is non-negative');
                
                // Test score updates
                this.testInstance.score = 5;
                this.testInstance.updateScore();
                
                const scoreDisplay = this.testInstance.scoreContainer.innerHTML;
                this.assert(scoreDisplay.includes('5'), 'Score display updates correctly');
                this.assert(scoreDisplay.includes('Puntuaci√≥n'), 'Score display includes proper label');
            }

            // Test 6: Verify feedback system
            testFeedbackSystem() {
                // Test correct feedback
                this.testInstance.showFeedback(true, 'Test correct message');
                
                // Check if feedback overlay is created
                setTimeout(() => {
                    const feedbackOverlay = document.querySelector('.fixed.inset-0.bg-black.bg-opacity-50');
                    this.assert(feedbackOverlay !== null, 'Feedback overlay is created for correct answers');
                    
                    const correctIcon = feedbackOverlay.querySelector('.text-4xl');
                    this.assert(correctIcon && correctIcon.textContent.includes('‚úÖ'), 'Correct feedback shows checkmark icon');
                }, 100);
                
                // Test incorrect feedback
                this.testInstance.showFeedback(false, 'Test incorrect message');
                
                setTimeout(() => {
                    const feedbackOverlay = document.querySelector('.fixed.inset-0.bg-black.bg-opacity-50');
                    const incorrectIcon = feedbackOverlay ? feedbackOverlay.querySelector('.text-4xl') : null;
                    this.assert(incorrectIcon && incorrectIcon.textContent.includes('‚ùå'), 'Incorrect feedback shows X icon');
                }, 100);
            }

            // Test 7: Verify array shuffling utility
            testArrayShuffling() {
                const originalArray = [1, 2, 3, 4, 5];
                const shuffledArray = this.testInstance.shuffleArray(originalArray);
                
                this.assert(shuffledArray.length === originalArray.length, 'Shuffled array maintains original length');
                
                // Check all elements are preserved
                const allElementsPreserved = originalArray.every(item => shuffledArray.includes(item));
                this.assert(allElementsPreserved, 'Shuffling preserves all original elements');
                
                // Test multiple shuffles produce different results
                const shuffleResults = [];
                for (let i = 0; i < 10; i++) {
                    shuffleResults.push(this.testInstance.shuffleArray([1, 2, 3]).join(','));
                }
                
                const uniqueResults = new Set(shuffleResults);
                this.assert(uniqueResults.size > 1, 'Multiple shuffles produce different arrangements');
            }

            // Run all tests
            runAllTests() {
                this.testResults = [];
                
                try {
                    this.setupTestEnvironment();
                    
                    this.testFigureGeneration();
                    this.testFigureRendering();
                    this.testOptionGeneration();
                    this.testAnswerChecking();
                    this.testScoringSystem();
                    this.testFeedbackSystem();
                    this.testArrayShuffling();
                    
                } catch (error) {
                    this.testResults.push({ 
                        status: 'FAIL', 
                        message: `Test execution error: ${error.message}` 
                    });
                } finally {
                    this.cleanupTestEnvironment();
                }
                
                return this.testResults;
            }
        }

        // Global function to run figure game tests
        function runFigureGameTests() {
            const tester = new FigureGameTests();
            return tester.runAllTests();
        }

        // To run tests manually, open browser console and execute: runAngleTests()
        // Tests cover vector-based angle calculations and sum validation logic
        class AngleCalculationTests {
            constructor() {
                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;
            }

            // Test helper to create a test triangle instance
            createTestTriangle(vertices) {
                const mockSvg = {
                    getBoundingClientRect: () => ({ left: 0, top: 0, width: 500, height: 400 })
                };
                const triangle = new AngleTriangle(mockSvg);
                triangle.vertices = vertices;
                return triangle;
            }

            // Test helper to assert equality with tolerance
            assertAlmostEqual(actual, expected, tolerance = 1, testName) {
                this.totalTests++;
                const diff = Math.abs(actual - expected);
                const passed = diff <= tolerance;

                if (passed) {
                    this.passedTests++;
                    console.log(`‚úì ${testName}: ${actual} ‚âà ${expected} (diff: ${diff.toFixed(2)})`);
                } else {
                    console.error(`‚úó ${testName}: ${actual} ‚â† ${expected} (diff: ${diff.toFixed(2)})`);
                }

                this.testResults.push({
                    name: testName,
                    passed,
                    actual,
                    expected,
                    difference: diff
                });

                return passed;
            }

            // Test helper to assert exact equality
            assertEqual(actual, expected, testName) {
                this.totalTests++;
                const passed = actual === expected;

                if (passed) {
                    this.passedTests++;
                    console.log(`‚úì ${testName}: ${actual} === ${expected}`);
                } else {
                    console.error(`‚úó ${testName}: ${actual} !== ${expected}`);
                }

                this.testResults.push({
                    name: testName,
                    passed,
                    actual,
                    expected,
                    difference: Math.abs(actual - expected)
                });

                return passed;
            }

            // Test vector-based angle calculation for right triangle
            testRightTriangleAngles() {
                console.log('\n--- Testing Right Triangle Angles ---');

                // Create a right triangle with vertices at (0,0), (100,0), (0,100)
                const vertices = [
                    { x: 0, y: 0, id: 'A' },
                    { x: 100, y: 0, id: 'B' },
                    { x: 0, y: 100, id: 'C' }
                ];

                const triangle = this.createTestTriangle(vertices);
                triangle.calculateAngles();

                // Right triangle should have angles: 90¬∞, 45¬∞, 45¬∞
                this.assertAlmostEqual(triangle.angles[0], 90, 2, 'Right angle at vertex A');
                this.assertAlmostEqual(triangle.angles[1], 45, 2, 'Angle at vertex B');
                this.assertAlmostEqual(triangle.angles[2], 45, 2, 'Angle at vertex C');

                // Test sum validation
                const sum = triangle.angles[0] + triangle.angles[1] + triangle.angles[2];
                this.assertAlmostEqual(sum, 180, 2, 'Right triangle angle sum');
            }

            // Test vector-based angle calculation for equilateral triangle
            testEquilateralTriangleAngles() {
                console.log('\n--- Testing Equilateral Triangle Angles ---');

                // Create an equilateral triangle
                const side = 100;
                const height = side * Math.sqrt(3) / 2;
                const vertices = [
                    { x: 0, y: 0, id: 'A' },
                    { x: side, y: 0, id: 'B' },
                    { x: side / 2, y: height, id: 'C' }
                ];

                const triangle = this.createTestTriangle(vertices);
                triangle.calculateAngles();

                // Equilateral triangle should have all angles = 60¬∞
                this.assertAlmostEqual(triangle.angles[0], 60, 2, 'Angle at vertex A');
                this.assertAlmostEqual(triangle.angles[1], 60, 2, 'Angle at vertex B');
                this.assertAlmostEqual(triangle.angles[2], 60, 2, 'Angle at vertex C');

                // Test sum validation
                const sum = triangle.angles[0] + triangle.angles[1] + triangle.angles[2];
                this.assertAlmostEqual(sum, 180, 2, 'Equilateral triangle angle sum');
            }

            // Test vector-based angle calculation for obtuse triangle
            testObtuseTriangleAngles() {
                console.log('\n--- Testing Obtuse Triangle Angles ---');

                // Create an obtuse triangle
                const vertices = [
                    { x: 0, y: 0, id: 'A' },
                    { x: 150, y: 0, id: 'B' },
                    { x: 20, y: 50, id: 'C' }
                ];

                const triangle = this.createTestTriangle(vertices);
                triangle.calculateAngles();

                // Verify that one angle is greater than 90¬∞
                const hasObtuseAngle = triangle.angles.some(angle => angle > 90);
                this.assertEqual(hasObtuseAngle, true, 'Has obtuse angle (>90¬∞)');

                // Test sum validation
                const sum = triangle.angles[0] + triangle.angles[1] + triangle.angles[2];
                this.assertAlmostEqual(sum, 180, 2, 'Obtuse triangle angle sum');
            }

            // Test quadrilateral angle calculations
            testQuadrilateralAngles() {
                console.log('\n--- Testing Quadrilateral Angles ---');

                // Create a rectangle
                const vertices = [
                    { x: 0, y: 0, id: 'A' },
                    { x: 100, y: 0, id: 'B' },
                    { x: 100, y: 80, id: 'C' },
                    { x: 0, y: 80, id: 'D' }
                ];

                const quadrilateral = this.createTestTriangle(vertices);
                quadrilateral.isQuadrilateral = true;
                quadrilateral.angles = [0, 0, 0, 0]; // Initialize 4 angles
                quadrilateral.calculateAngles();

                // Rectangle should have all angles = 90¬∞
                this.assertAlmostEqual(quadrilateral.angles[0], 90, 2, 'Rectangle angle at vertex A');
                this.assertAlmostEqual(quadrilateral.angles[1], 90, 2, 'Rectangle angle at vertex B');
                this.assertAlmostEqual(quadrilateral.angles[2], 90, 2, 'Rectangle angle at vertex C');
                this.assertAlmostEqual(quadrilateral.angles[3], 90, 2, 'Rectangle angle at vertex D');

                // Test sum validation
                const sum = quadrilateral.angles[0] + quadrilateral.angles[1] + quadrilateral.angles[2] + quadrilateral.angles[3];
                this.assertAlmostEqual(sum, 360, 2, 'Rectangle angle sum');
            }

            // Test edge cases and error conditions
            testEdgeCases() {
                console.log('\n--- Testing Edge Cases ---');

                // Test degenerate triangle (collinear points)
                const degenerateVertices = [
                    { x: 0, y: 0, id: 'A' },
                    { x: 50, y: 0, id: 'B' },
                    { x: 100, y: 0, id: 'C' }
                ];

                const degenerateTriangle = this.createTestTriangle(degenerateVertices);
                degenerateTriangle.calculateAngles();

                // Degenerate triangle should have angles close to 0¬∞ and 180¬∞
                const hasZeroAngle = degenerateTriangle.angles.some(angle => angle < 5);
                const hasStraightAngle = degenerateTriangle.angles.some(angle => angle > 175);

                this.assertEqual(hasZeroAngle, true, 'Degenerate triangle has near-zero angle');
                this.assertEqual(hasStraightAngle, true, 'Degenerate triangle has near-straight angle');
            }

            // Test sum validation logic
            testSumValidation() {
                console.log('\n--- Testing Sum Validation Logic ---');

                // Test triangle sum validation
                const triangleAngles = [60, 60, 60];
                const triangleSum = triangleAngles.reduce((sum, angle) => sum + angle, 0);
                this.assertEqual(triangleSum, 180, 'Valid triangle angle sum');

                // Test quadrilateral sum validation
                const quadrilateralAngles = [90, 90, 90, 90];
                const quadrilateralSum = quadrilateralAngles.reduce((sum, angle) => sum + angle, 0);
                this.assertEqual(quadrilateralSum, 360, 'Valid quadrilateral angle sum');

                // Test invalid sums
                const invalidTriangleAngles = [90, 90, 90];
                const invalidSum = invalidTriangleAngles.reduce((sum, angle) => sum + angle, 0);
                const isValidTriangleSum = Math.abs(invalidSum - 180) < 2;
                this.assertEqual(isValidTriangleSum, false, 'Invalid triangle sum detection');
            }

            // Test vector calculation accuracy
            testVectorCalculations() {
                console.log('\n--- Testing Vector Calculations ---');

                // Test dot product calculation
                const v1 = { x: 1, y: 0 };
                const v2 = { x: 0, y: 1 };
                const dotProduct = v1.x * v2.x + v1.y * v2.y;
                this.assertEqual(dotProduct, 0, 'Perpendicular vectors dot product');

                // Test cross product calculation
                const crossProduct = v1.x * v2.y - v1.y * v2.x;
                this.assertEqual(crossProduct, 1, 'Perpendicular vectors cross product');

                // Test angle calculation from vectors
                const angle = Math.atan2(crossProduct, dotProduct) * (180 / Math.PI);
                this.assertAlmostEqual(Math.abs(angle), 90, 1, 'Perpendicular vectors angle');
            }

            // Test angle normalization
            testAngleNormalization() {
                console.log('\n--- Testing Angle Normalization ---');

                // Test negative angle normalization
                let angle = -45;
                if (angle < 0) angle += 360;
                this.assertEqual(angle, 315, 'Negative angle normalization');

                // Test angle > 180¬∞ normalization
                angle = 270;
                if (angle > 180) angle = 360 - angle;
                this.assertEqual(angle, 90, 'Large angle normalization');
            }

            // Run all tests
            runAllTests() {
                console.log('üß™ Starting Angle Calculation Unit Tests...\n');

                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;

                try {
                    this.testRightTriangleAngles();
                    this.testEquilateralTriangleAngles();
                    this.testObtuseTriangleAngles();
                    this.testQuadrilateralAngles();
                    this.testEdgeCases();
                    this.testSumValidation();
                    this.testVectorCalculations();
                    this.testAngleNormalization();
                } catch (error) {
                    console.error('Test execution error:', error);
                }

                this.printTestSummary();
            }

            // Print test summary
            printTestSummary() {
                console.log('\nüìä Test Summary:');
                console.log(`Total Tests: ${this.totalTests}`);
                console.log(`Passed: ${this.passedTests}`);
                console.log(`Failed: ${this.totalTests - this.passedTests}`);
                console.log(`Success Rate: ${((this.passedTests / this.totalTests) * 100).toFixed(1)}%`);

                if (this.passedTests === this.totalTests) {
                    console.log('üéâ All tests passed!');
                } else {
                    console.log('‚ùå Some tests failed. Check the details above.');
                }

                // Return test results for potential integration
                return {
                    total: this.totalTests,
                    passed: this.passedTests,
                    failed: this.totalTests - this.passedTests,
                    successRate: (this.passedTests / this.totalTests) * 100,
                    results: this.testResults
                };
            }
        }

        // Figure Identification Game Class for C√≠rculo y Figuras module
        class FigureIdentificationGame {
            constructor(svgElement, optionsContainer, scoreContainer) {
                this.svg = svgElement;
                this.optionsContainer = optionsContainer;
                this.scoreContainer = scoreContainer;
                this.score = 0;
                this.currentFigure = null;
                this.figures = [
                    {
                        name: 'sector',
                        label: 'Sector Circular',
                        description: 'Porci√≥n del c√≠rculo limitada por dos radios y un arco'
                    },
                    {
                        name: 'segment',
                        label: 'Segmento Circular',
                        description: 'Porci√≥n del c√≠rculo limitada por una cuerda y un arco'
                    },
                    {
                        name: 'corona',
                        label: 'Corona Circular',
                        description: 'Regi√≥n entre dos circunferencias conc√©ntricas'
                    }
                ];
                this.init();
            }

            init() {
                this.generateQuestion();
                this.updateScore();
            }

            generateQuestion() {
                // Select random figure
                this.currentFigure = this.figures[Math.floor(Math.random() * this.figures.length)];

                // Clear SVG and render the figure
                this.renderFigure(this.currentFigure.name);

                // Generate options (correct answer + 2 wrong answers)
                this.generateOptions();
            }

            renderFigure(figureName) {
                this.svg.innerHTML = '';

                const centerX = 200;
                const centerY = 150;
                const radius = 80;

                // Draw base circle outline
                const baseCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                baseCircle.setAttribute('cx', centerX);
                baseCircle.setAttribute('cy', centerY);
                baseCircle.setAttribute('r', radius);
                baseCircle.setAttribute('fill', 'none');
                baseCircle.setAttribute('stroke', '#6B7280');
                baseCircle.setAttribute('stroke-width', '2');
                this.svg.appendChild(baseCircle);

                switch (figureName) {
                    case 'sector':
                        this.renderSector(centerX, centerY, radius);
                        break;
                    case 'segment':
                        this.renderSegment(centerX, centerY, radius);
                        break;
                    case 'corona':
                        this.renderCorona(centerX, centerY, radius);
                        break;
                }
            }

            renderSector(centerX, centerY, radius) {
                // Draw sector (pie slice)
                const startAngle = -Math.PI / 3; // -60 degrees
                const endAngle = Math.PI / 4; // 45 degrees

                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);

                const largeArcFlag = (endAngle - startAngle) > Math.PI ? 1 : 0;

                const pathData = `M ${centerX} ${centerY} L ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;

                const sectorPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                sectorPath.setAttribute('d', pathData);
                sectorPath.setAttribute('fill', 'rgba(239, 68, 68, 0.6)');
                sectorPath.setAttribute('stroke', '#EF4444');
                sectorPath.setAttribute('stroke-width', '2');
                this.svg.appendChild(sectorPath);

                // Draw radii
                const radius1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                radius1.setAttribute('x1', centerX);
                radius1.setAttribute('y1', centerY);
                radius1.setAttribute('x2', startX);
                radius1.setAttribute('y2', startY);
                radius1.setAttribute('stroke', '#DC2626');
                radius1.setAttribute('stroke-width', '2');
                this.svg.appendChild(radius1);

                const radius2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                radius2.setAttribute('x1', centerX);
                radius2.setAttribute('y1', centerY);
                radius2.setAttribute('x2', endX);
                radius2.setAttribute('y2', endY);
                radius2.setAttribute('stroke', '#DC2626');
                radius2.setAttribute('stroke-width', '2');
                this.svg.appendChild(radius2);
            }

            renderSegment(centerX, centerY, radius) {
                // Draw segment (area between chord and arc)
                const startAngle = Math.PI / 6; // 30 degrees
                const endAngle = (5 * Math.PI) / 6; // 150 degrees

                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);

                const largeArcFlag = (endAngle - startAngle) > Math.PI ? 1 : 0;

                const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;

                const segmentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                segmentPath.setAttribute('d', pathData);
                segmentPath.setAttribute('fill', 'rgba(59, 130, 246, 0.6)');
                segmentPath.setAttribute('stroke', '#3B82F6');
                segmentPath.setAttribute('stroke-width', '2');
                this.svg.appendChild(segmentPath);

                // Draw chord
                const chord = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                chord.setAttribute('x1', startX);
                chord.setAttribute('y1', startY);
                chord.setAttribute('x2', endX);
                chord.setAttribute('y2', endY);
                chord.setAttribute('stroke', '#1D4ED8');
                chord.setAttribute('stroke-width', '3');
                this.svg.appendChild(chord);
            }

            renderCorona(centerX, centerY, radius) {
                // Draw corona (ring between two circles)
                const outerRadius = radius;
                const innerRadius = radius * 0.6;

                // Outer circle
                const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                outerCircle.setAttribute('cx', centerX);
                outerCircle.setAttribute('cy', centerY);
                outerCircle.setAttribute('r', outerRadius);
                outerCircle.setAttribute('fill', 'rgba(16, 185, 129, 0.6)');
                outerCircle.setAttribute('stroke', '#10B981');
                outerCircle.setAttribute('stroke-width', '2');
                this.svg.appendChild(outerCircle);

                // Inner circle (white to create ring effect)
                const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                innerCircle.setAttribute('cx', centerX);
                innerCircle.setAttribute('cy', centerY);
                innerCircle.setAttribute('r', innerRadius);
                innerCircle.setAttribute('fill', 'white');
                innerCircle.setAttribute('stroke', '#059669');
                innerCircle.setAttribute('stroke-width', '2');
                this.svg.appendChild(innerCircle);
            }

            generateOptions() {
                // Clear previous options
                this.optionsContainer.innerHTML = '';

                // Create shuffled array of all figures
                const allOptions = [...this.figures];
                const shuffledOptions = this.shuffleArray(allOptions);

                // Create option buttons
                shuffledOptions.forEach(figure => {
                    const button = document.createElement('button');
                    button.className = 'bg-white hover:bg-blue-50 border-2 border-blue-200 hover:border-blue-400 rounded-lg p-4 text-center transition-colors';
                    button.innerHTML = `
                        <div class="font-semibold text-blue-800">${figure.label}</div>
                        <div class="text-sm text-gray-600 mt-1">${figure.description}</div>
                    `;

                    button.addEventListener('click', () => this.checkAnswer(figure.name));
                    this.optionsContainer.appendChild(button);
                });
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            checkAnswer(selectedAnswer) {
                const isCorrect = selectedAnswer === this.currentFigure.name;

                if (isCorrect) {
                    this.score++;
                    this.showFeedback(true, '¬°Correcto! Has identificado correctamente la figura.');
                } else {
                    const correctFigure = this.figures.find(f => f.name === this.currentFigure.name);
                    this.showFeedback(false, `Incorrecto. La figura mostrada es: ${correctFigure.label}`);
                }

                this.updateScore();

                // Generate new question after delay
                setTimeout(() => {
                    this.generateQuestion();
                }, 2000);
            }

            showFeedback(isCorrect, message) {
                // Create feedback overlay
                const feedback = document.createElement('div');
                feedback.className = `fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50`;
                feedback.innerHTML = `
                    <div class="bg-white rounded-lg p-6 max-w-md mx-4 text-center">
                        <div class="text-4xl mb-4">${isCorrect ? '‚úÖ' : '‚ùå'}</div>
                        <div class="text-lg font-semibold ${isCorrect ? 'text-green-600' : 'text-red-600'} mb-2">
                            ${isCorrect ? '¬°Correcto!' : 'Incorrecto'}
                        </div>
                        <div class="text-gray-700">${message}</div>
                    </div>
                `;

                document.body.appendChild(feedback);

                // Remove feedback after delay
                setTimeout(() => {
                    feedback.remove();
                }, 1500);
            }

            updateScore() {
                if (this.scoreContainer) {
                    this.scoreContainer.innerHTML = `
                        <p class="text-lg font-medium text-yellow-800">Puntuaci√≥n: ${this.score}</p>
                    `;
                }
            }
        }

        // Figure Evaluation Class for C√≠rculo y Figuras module
        class FigureEvaluation {
            constructor() {
                this.questions = [];
                this.currentQuestion = 0;
                this.score = 0;
                this.totalQuestions = 5;
                this.figures = [
                    {
                        name: 'sector',
                        label: 'Sector Circular',
                        description: 'Porci√≥n del c√≠rculo limitada por dos radios y un arco'
                    },
                    {
                        name: 'segment',
                        label: 'Segmento Circular',
                        description: 'Porci√≥n del c√≠rculo limitada por una cuerda y un arco'
                    },
                    {
                        name: 'corona',
                        label: 'Corona Circular',
                        description: 'Regi√≥n entre dos circunferencias conc√©ntricas'
                    },
                    {
                        name: 'circle',
                        label: 'C√≠rculo',
                        description: 'Superficie completa limitada por la circunferencia'
                    },
                    {
                        name: 'circumference',
                        label: 'Circunferencia',
                        description: 'L√≠nea curva cerrada que forma el borde del c√≠rculo'
                    }
                ];
                this.init();
            }

            init() {
                this.generateQuestions();
                this.renderQuestion();
            }

            generateQuestions() {
                this.questions = [];

                // Generate questions about figure identification
                for (let i = 0; i < this.totalQuestions; i++) {
                    const correctFigure = this.figures[Math.floor(Math.random() * this.figures.length)];

                    // Create wrong options
                    const wrongOptions = this.figures.filter(f => f.name !== correctFigure.name);
                    const selectedWrong = this.shuffleArray(wrongOptions).slice(0, 2);

                    // Combine and shuffle all options
                    const allOptions = [correctFigure, ...selectedWrong];
                    const shuffledOptions = this.shuffleArray(allOptions);

                    const question = {
                        id: i + 1,
                        figure: correctFigure,
                        options: shuffledOptions,
                        correctAnswer: correctFigure.name,
                        answered: false,
                        selectedAnswer: null
                    };

                    this.questions.push(question);
                }
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            renderQuestion() {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                const question = this.questions[this.currentQuestion];

                container.innerHTML = `
                    <div class="mb-6">
                        <div class="flex justify-between items-center mb-4">
                            <h4 class="text-lg font-semibold text-gray-800">Pregunta ${this.currentQuestion + 1} de ${this.totalQuestions}</h4>
                            <div class="text-sm text-gray-600">Puntuaci√≥n: ${this.score}/${this.currentQuestion}</div>
                        </div>
                        
                        <div class="bg-white p-4 rounded-lg border mb-4">
                            <p class="text-gray-700 mb-4">Identifica la figura que se muestra a continuaci√≥n:</p>
                            <div class="flex justify-center mb-4">
                                <svg id="questionFigureSvg" width="300" height="200" viewBox="0 0 300 200" class="border border-gray-300 rounded">
                                    <!-- Figure will be rendered here -->
                                </svg>
                            </div>
                        </div>
                        
                        <div class="space-y-3">
                            ${question.options.map((option, index) => `
                                <button class="option-button w-full text-left p-4 bg-white hover:bg-blue-50 border-2 border-gray-200 hover:border-blue-300 rounded-lg transition-colors" 
                                        data-answer="${option.name}">
                                    <div class="font-medium text-gray-800">${String.fromCharCode(65 + index)}. ${option.label}</div>
                                    <div class="text-sm text-gray-600 mt-1">${option.description}</div>
                                </button>
                            `).join('')}
                        </div>
                        
                        <div id="questionFeedback" class="mt-4 hidden">
                            <!-- Feedback will be shown here -->
                        </div>
                        
                        <div class="mt-6 text-center">
                            <button id="nextQuestionBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg transition-colors hidden">
                                ${this.currentQuestion < this.totalQuestions - 1 ? 'Siguiente Pregunta' : 'Ver Resultados'}
                            </button>
                        </div>
                    </div>
                `;

                // Render the figure
                this.renderQuestionFigure(question.figure.name);

                // Setup event listeners
                this.setupQuestionEventListeners();
            }

            renderQuestionFigure(figureName) {
                const svg = document.getElementById('questionFigureSvg');
                if (!svg) return;

                svg.innerHTML = '';

                const centerX = 150;
                const centerY = 100;
                const radius = 60;

                // Draw base circle outline for most figures
                if (figureName !== 'circumference') {
                    const baseCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    baseCircle.setAttribute('cx', centerX);
                    baseCircle.setAttribute('cy', centerY);
                    baseCircle.setAttribute('r', radius);
                    baseCircle.setAttribute('fill', figureName === 'circle' ? 'rgba(59, 130, 246, 0.3)' : 'none');
                    baseCircle.setAttribute('stroke', '#6B7280');
                    baseCircle.setAttribute('stroke-width', '2');
                    svg.appendChild(baseCircle);
                }

                switch (figureName) {
                    case 'sector':
                        this.renderEvaluationSector(svg, centerX, centerY, radius);
                        break;
                    case 'segment':
                        this.renderEvaluationSegment(svg, centerX, centerY, radius);
                        break;
                    case 'corona':
                        this.renderEvaluationCorona(svg, centerX, centerY, radius);
                        break;
                    case 'circle':
                        // Already rendered with fill above
                        break;
                    case 'circumference':
                        this.renderEvaluationCircumference(svg, centerX, centerY, radius);
                        break;
                }
            }

            renderEvaluationSector(svg, centerX, centerY, radius) {
                const startAngle = -Math.PI / 4;
                const endAngle = Math.PI / 3;

                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);

                const largeArcFlag = (endAngle - startAngle) > Math.PI ? 1 : 0;
                const pathData = `M ${centerX} ${centerY} L ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;

                const sectorPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                sectorPath.setAttribute('d', pathData);
                sectorPath.setAttribute('fill', 'rgba(239, 68, 68, 0.6)');
                sectorPath.setAttribute('stroke', '#EF4444');
                sectorPath.setAttribute('stroke-width', '2');
                svg.appendChild(sectorPath);
            }

            renderEvaluationSegment(svg, centerX, centerY, radius) {
                const startAngle = Math.PI / 6;
                const endAngle = (5 * Math.PI) / 6;

                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);

                const largeArcFlag = (endAngle - startAngle) > Math.PI ? 1 : 0;
                const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`;

                const segmentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                segmentPath.setAttribute('d', pathData);
                segmentPath.setAttribute('fill', 'rgba(59, 130, 246, 0.6)');
                segmentPath.setAttribute('stroke', '#3B82F6');
                segmentPath.setAttribute('stroke-width', '2');
                svg.appendChild(segmentPath);
            }

            renderEvaluationCorona(svg, centerX, centerY, radius) {
                const outerRadius = radius;
                const innerRadius = radius * 0.5;

                const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                outerCircle.setAttribute('cx', centerX);
                outerCircle.setAttribute('cy', centerY);
                outerCircle.setAttribute('r', outerRadius);
                outerCircle.setAttribute('fill', 'rgba(16, 185, 129, 0.6)');
                outerCircle.setAttribute('stroke', '#10B981');
                outerCircle.setAttribute('stroke-width', '2');
                svg.appendChild(outerCircle);

                const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                innerCircle.setAttribute('cx', centerX);
                innerCircle.setAttribute('cy', centerY);
                innerCircle.setAttribute('r', innerRadius);
                innerCircle.setAttribute('fill', 'white');
                innerCircle.setAttribute('stroke', '#059669');
                innerCircle.setAttribute('stroke-width', '2');
                svg.appendChild(innerCircle);
            }

            renderEvaluationCircumference(svg, centerX, centerY, radius) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#8B5CF6');
                circle.setAttribute('stroke-width', '4');
                svg.appendChild(circle);
            }

            setupQuestionEventListeners() {
                const optionButtons = document.querySelectorAll('.option-button');
                const nextButton = document.getElementById('nextQuestionBtn');

                optionButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        if (this.questions[this.currentQuestion].answered) return;

                        const selectedAnswer = button.dataset.answer;
                        this.handleAnswer(selectedAnswer);
                    });
                });

                if (nextButton) {
                    nextButton.addEventListener('click', () => {
                        this.nextQuestion();
                    });
                }
            }

            handleAnswer(selectedAnswer) {
                const question = this.questions[this.currentQuestion];
                question.answered = true;
                question.selectedAnswer = selectedAnswer;

                const isCorrect = selectedAnswer === question.correctAnswer;
                if (isCorrect) {
                    this.score++;
                }

                // Update button styles
                const optionButtons = document.querySelectorAll('.option-button');
                optionButtons.forEach(button => {
                    button.disabled = true;
                    button.classList.remove('hover:bg-blue-50', 'hover:border-blue-300');

                    if (button.dataset.answer === question.correctAnswer) {
                        button.classList.add('bg-green-100', 'border-green-500');
                    } else if (button.dataset.answer === selectedAnswer && !isCorrect) {
                        button.classList.add('bg-red-100', 'border-red-500');
                    }
                });

                // Show feedback
                this.showQuestionFeedback(isCorrect, question.figure);

                // Show next button
                const nextButton = document.getElementById('nextQuestionBtn');
                if (nextButton) {
                    nextButton.classList.remove('hidden');
                }
            }

            showQuestionFeedback(isCorrect, correctFigure) {
                const feedbackContainer = document.getElementById('questionFeedback');
                if (!feedbackContainer) return;

                feedbackContainer.className = `mt-4 p-4 rounded-lg ${isCorrect ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'}`;
                feedbackContainer.innerHTML = `
                    <div class="flex items-center">
                        <div class="text-2xl mr-3">${isCorrect ? '‚úÖ' : '‚ùå'}</div>
                        <div>
                            <div class="font-semibold ${isCorrect ? 'text-green-800' : 'text-red-800'}">
                                ${isCorrect ? '¬°Correcto!' : 'Incorrecto'}
                            </div>
                            <div class="text-sm ${isCorrect ? 'text-green-700' : 'text-red-700'} mt-1">
                                ${isCorrect ?
                        `Has identificado correctamente: ${correctFigure.label}` :
                        `La respuesta correcta es: ${correctFigure.label} - ${correctFigure.description}`
                    }
                            </div>
                        </div>
                    </div>
                `;
                feedbackContainer.classList.remove('hidden');
            }

            nextQuestion() {
                if (this.currentQuestion < this.totalQuestions - 1) {
                    this.currentQuestion++;
                    this.renderQuestion();
                } else {
                    this.showResults();
                }
            }

            showResults() {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                const percentage = Math.round((this.score / this.totalQuestions) * 100);
                let performanceMessage = '';
                let performanceColor = '';

                if (percentage >= 80) {
                    performanceMessage = '¬°Excelente trabajo! Dominas muy bien los conceptos de figuras circulares.';
                    performanceColor = 'text-green-600';
                } else if (percentage >= 60) {
                    performanceMessage = '¬°Buen trabajo! Tienes un buen entendimiento de las figuras circulares.';
                    performanceColor = 'text-blue-600';
                } else {
                    performanceMessage = 'Sigue practicando. Revisa la teor√≠a para mejorar tu comprensi√≥n.';
                    performanceColor = 'text-orange-600';
                }

                container.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4">üéØ</div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-4">¬°Evaluaci√≥n Completada!</h3>
                        
                        <div class="bg-white p-6 rounded-lg border mb-6">
                            <div class="text-4xl font-bold text-blue-600 mb-2">${this.score}/${this.totalQuestions}</div>
                            <div class="text-xl text-gray-700 mb-2">${percentage}% de aciertos</div>
                            <div class="text-lg ${performanceColor}">${performanceMessage}</div>
                        </div>
                        
                        <div class="space-y-3">
                            <button onclick="figureEvaluationInstance = null; initFigureEvaluation();" 
                                    class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors">
                                Intentar de Nuevo
                            </button>
                            <button onclick="currentTab = 'teoria'; updateTabButtons(); loadTabContent();" 
                                    class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg transition-colors ml-4">
                                Revisar Teor√≠a
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        // Line Position Interaction Class for Posiciones de Rectas module
        class LinePositionInteraction {
            constructor(svgElement, statusElement) {
                this.svg = svgElement;
                this.statusElement = statusElement;
                this.circle = { cx: 250, cy: 200, r: 80 };
                this.line = { x1: 50, y1: 150, x2: 450, y2: 150 };
                this.isDragging = false;
                this.dragOffset = 0;
                
                this.init();
            }

            init() {
                this.render();
                this.attachEventListeners();
                this.updatePosition();
            }

            render() {
                this.svg.innerHTML = `
                    <!-- Fixed circle -->
                    <circle cx="${this.circle.cx}" cy="${this.circle.cy}" r="${this.circle.r}" 
                            fill="none" stroke="#3B82F6" stroke-width="3"/>
                    <circle cx="${this.circle.cx}" cy="${this.circle.cy}" r="3" fill="#3B82F6"/>
                    
                    <!-- Draggable line -->
                    <line id="draggableLine" x1="${this.line.x1}" y1="${this.line.y1}" 
                          x2="${this.line.x2}" y2="${this.line.y2}" 
                          stroke="#EF4444" stroke-width="3" cursor="grab"/>
                    
                    <!-- Invisible drag area for better UX -->
                    <line id="dragArea" x1="${this.line.x1}" y1="${this.line.y1}" 
                          x2="${this.line.x2}" y2="${this.line.y2}" 
                          stroke="transparent" stroke-width="20" cursor="grab"/>
                    
                    <!-- Labels -->
                    <text x="${this.circle.cx}" y="${this.circle.cy - this.circle.r - 10}" 
                          text-anchor="middle" class="text-sm font-medium fill-blue-600">Circunferencia</text>
                    <text x="20" y="${this.line.y1 - 10}" 
                          class="text-sm font-medium fill-red-600">Recta</text>
                `;
            }

            attachEventListeners() {
                const dragArea = this.svg.querySelector('#dragArea');
                const line = this.svg.querySelector('#draggableLine');
                
                // Throttled drag handler for better performance
                const throttledDrag = PerformanceUtils.throttle((constrainedY) => {
                    this.line.y1 = constrainedY;
                    this.line.y2 = constrainedY;
                    
                    // Use requestAnimationFrame for smooth updates
                    PerformanceUtils.requestAnimationFrame(() => {
                        this.updateLinePosition();
                        this.updatePosition();
                    });
                }, 16);
                
                // Mouse events
                dragArea.addEventListener('mousedown', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e, throttledDrag));
                document.addEventListener('mouseup', () => this.endDrag());
                
                // Touch events for mobile with passive listeners where possible
                dragArea.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag(e.touches[0], throttledDrag);
                });
                document.addEventListener('touchend', () => this.endDrag());
                
                // Update cursor on drag
                dragArea.addEventListener('mousedown', () => {
                    dragArea.style.cursor = 'grabbing';
                    line.style.cursor = 'grabbing';
                });
            }

            startDrag(event) {
                this.isDragging = true;
                const rect = this.svg.getBoundingClientRect();
                const y = event.clientY - rect.top;
                this.dragOffset = y - this.line.y1;
            }

            drag(event, throttledDrag) {
                if (!this.isDragging) return;
                
                const rect = this.svg.getBoundingClientRect();
                const y = event.clientY - rect.top - this.dragOffset;
                
                // Constrain line within SVG bounds
                const minY = 20;
                const maxY = 380;
                const constrainedY = Math.max(minY, Math.min(maxY, y));
                
                throttledDrag(constrainedY);
            }

            endDrag() {
                this.isDragging = false;
                const dragArea = this.svg.querySelector('#dragArea');
                const line = this.svg.querySelector('#draggableLine');
                dragArea.style.cursor = 'grab';
                line.style.cursor = 'grab';
            }

            updateLinePosition() {
                const line = this.svg.querySelector('#draggableLine');
                const dragArea = this.svg.querySelector('#dragArea');
                
                line.setAttribute('y1', this.line.y1);
                line.setAttribute('y2', this.line.y2);
                dragArea.setAttribute('y1', this.line.y1);
                dragArea.setAttribute('y2', this.line.y2);
            }

            detectPosition() {
                const distance = Math.abs(this.line.y1 - this.circle.cy);
                
                if (distance > this.circle.r + 2) {
                    return 'exterior';
                } else if (Math.abs(distance - this.circle.r) <= 2) {
                    return 'tangente';
                } else {
                    return 'secante';
                }
            }

            updatePosition() {
                const position = this.detectPosition();
                const distance = Math.abs(this.line.y1 - this.circle.cy);
                
                let statusText = '';
                let statusColor = '';
                
                switch(position) {
                    case 'exterior':
                        statusText = 'Exterior';
                        statusColor = 'text-red-600';
                        break;
                    case 'tangente':
                        statusText = 'Tangente';
                        statusColor = 'text-yellow-600';
                        break;
                    case 'secante':
                        statusText = 'Secante';
                        statusColor = 'text-green-600';
                        break;
                }
                
                if (this.statusElement) {
                    this.statusElement.innerHTML = `
                        <p class="text-xl font-bold ${statusColor}">Posici√≥n: ${statusText}</p>
                        <p class="text-sm text-gray-600 mt-2">
                            Distancia del centro a la recta: ${distance.toFixed(1)}px<br>
                            Radio de la circunferencia: ${this.circle.r}px
                        </p>
                    `;
                }
            }
        }

        // Line Position Evaluation Class for Posiciones de Rectas module
        class LinePositionEvaluation {
            constructor() {
                this.questions = [];
                this.currentQuestion = 0;
                this.score = 0;
                this.totalQuestions = 5;
                
                this.generateQuestions();
                this.renderQuestion();
            }

            generateQuestions() {
                const positions = [
                    {
                        type: 'exterior',
                        distance: 120,
                        description: 'La recta no toca la circunferencia',
                        color: '#EF4444'
                    },
                    {
                        type: 'tangente',
                        distance: 80,
                        description: 'La recta toca la circunferencia en un punto',
                        color: '#F59E0B'
                    },
                    {
                        type: 'secante',
                        distance: 50,
                        description: 'La recta cruza la circunferencia en dos puntos',
                        color: '#10B981'
                    }
                ];

                this.questions = [];
                
                for (let i = 0; i < this.totalQuestions; i++) {
                    const position = positions[Math.floor(Math.random() * positions.length)];
                    const circleY = 150;
                    const lineY = circleY + (Math.random() > 0.5 ? 1 : -1) * position.distance;
                    
                    this.questions.push({
                        id: i + 1,
                        position: position.type,
                        circleY: circleY,
                        lineY: lineY,
                        description: position.description,
                        color: position.color,
                        options: ['exterior', 'tangente', 'secante']
                    });
                }
            }

            renderQuestion() {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                const question = this.questions[this.currentQuestion];
                
                container.innerHTML = `
                    <div class="space-y-6">
                        <div class="flex justify-between items-center">
                            <h4 class="text-lg font-semibold text-gray-800">
                                Pregunta ${this.currentQuestion + 1} de ${this.totalQuestions}
                            </h4>
                            <div class="text-sm text-gray-600">
                                Puntuaci√≥n: ${this.score}/${this.totalQuestions}
                            </div>
                        </div>
                        
                        <div class="bg-white p-4 rounded-lg border">
                            <p class="text-gray-700 mb-4 text-center">
                                ¬øCu√°l es la posici√≥n de la recta respecto a la circunferencia?
                            </p>
                            
                            <svg width="100%" height="300" viewBox="0 0 400 300" class="border border-gray-200 rounded">
                                <!-- Circle -->
                                <circle cx="200" cy="${question.circleY}" r="80" 
                                        fill="none" stroke="#3B82F6" stroke-width="3"/>
                                <circle cx="200" cy="${question.circleY}" r="3" fill="#3B82F6"/>
                                
                                <!-- Line -->
                                <line x1="50" y1="${question.lineY}" x2="350" y2="${question.lineY}" 
                                      stroke="${question.color}" stroke-width="3"/>
                                
                                <!-- Labels -->
                                <text x="200" y="${question.circleY - 90}" text-anchor="middle" 
                                      class="text-sm font-medium fill-blue-600">Circunferencia</text>
                                <text x="30" y="${question.lineY - 10}" 
                                      class="text-sm font-medium" fill="${question.color}">Recta</text>
                            </svg>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            ${question.options.map(option => `
                                <button onclick="linePositionEvaluationInstance.checkAnswer('${option}')" 
                                        class="p-4 border-2 border-gray-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-colors text-center">
                                    <div class="font-semibold text-gray-800 capitalize">${option}</div>
                                    <div class="text-sm text-gray-600 mt-1">
                                        ${option === 'exterior' ? 'No toca' : 
                                          option === 'tangente' ? 'Toca en un punto' : 
                                          'Cruza en dos puntos'}
                                    </div>
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            checkAnswer(selectedAnswer) {
                const question = this.questions[this.currentQuestion];
                const isCorrect = selectedAnswer === question.position;
                
                if (isCorrect) {
                    this.score++;
                }
                
                this.showFeedback(selectedAnswer, question.position, isCorrect);
            }

            showFeedback(selectedAnswer, correctAnswer, isCorrect) {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                const question = this.questions[this.currentQuestion];
                
                container.innerHTML = `
                    <div class="space-y-6">
                        <div class="flex justify-between items-center">
                            <h4 class="text-lg font-semibold text-gray-800">
                                Pregunta ${this.currentQuestion + 1} de ${this.totalQuestions}
                            </h4>
                            <div class="text-sm text-gray-600">
                                Puntuaci√≥n: ${this.score}/${this.totalQuestions}
                            </div>
                        </div>
                        
                        <div class="text-center">
                            <div class="text-6xl mb-4">${isCorrect ? '‚úÖ' : '‚ùå'}</div>
                            <div class="text-2xl font-bold mb-2 ${isCorrect ? 'text-green-600' : 'text-red-600'}">
                                ${isCorrect ? '¬°Correcto!' : 'Incorrecto'}
                            </div>
                            
                            ${!isCorrect ? `
                                <div class="bg-red-50 p-4 rounded-lg mb-4">
                                    <p class="text-red-800">
                                        Tu respuesta: <strong class="capitalize">${selectedAnswer}</strong><br>
                                        Respuesta correcta: <strong class="capitalize">${correctAnswer}</strong>
                                    </p>
                                </div>
                            ` : ''}
                            
                            <div class="bg-blue-50 p-4 rounded-lg mb-6">
                                <p class="text-blue-800 font-medium">Explicaci√≥n:</p>
                                <p class="text-blue-700">${question.description}</p>
                            </div>
                        </div>
                        
                        <div class="text-center">
                            <button onclick="linePositionEvaluationInstance.nextQuestion()" 
                                    class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors">
                                ${this.currentQuestion < this.totalQuestions - 1 ? 'Siguiente Pregunta' : 'Ver Resultados'}
                            </button>
                        </div>
                    </div>
                `;
            }

            nextQuestion() {
                if (this.currentQuestion < this.totalQuestions - 1) {
                    this.currentQuestion++;
                    this.renderQuestion();
                } else {
                    this.showResults();
                }
            }

            showResults() {
                const container = document.getElementById('questionContainer');
                if (!container) return;

                const percentage = Math.round((this.score / this.totalQuestions) * 100);
                let performanceMessage = '';
                let performanceColor = '';

                if (percentage >= 80) {
                    performanceMessage = '¬°Excelente trabajo! Dominas muy bien las posiciones de rectas y circunferencias.';
                    performanceColor = 'text-green-600';
                } else if (percentage >= 60) {
                    performanceMessage = '¬°Buen trabajo! Tienes un buen entendimiento de las posiciones de rectas.';
                    performanceColor = 'text-blue-600';
                } else {
                    performanceMessage = 'Sigue practicando. Revisa la teor√≠a para mejorar tu comprensi√≥n.';
                    performanceColor = 'text-orange-600';
                }

                container.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4">üéØ</div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-4">¬°Evaluaci√≥n Completada!</h3>
                        
                        <div class="bg-white p-6 rounded-lg border mb-6">
                            <div class="text-4xl font-bold text-blue-600 mb-2">${this.score}/${this.totalQuestions}</div>
                            <div class="text-xl text-gray-700 mb-2">${percentage}% de aciertos</div>
                            <div class="text-lg ${performanceColor}">${performanceMessage}</div>
                        </div>
                        
                        <div class="space-y-3">
                            <button onclick="linePositionEvaluationInstance = null; initLinePositionEvaluation();" 
                                    class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors">
                                Intentar de Nuevo
                            </button>
                            <button onclick="currentTab = 'teoria'; updateTabButtons(); loadTabContent();" 
                                    class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg transition-colors ml-4">
                                Revisar Teor√≠a
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        // Initialize figure game and evaluation components
        let figureGameInstance = null;
        let figureEvaluationInstance = null;

        function initFigureGame() {
            const svg = document.getElementById('figureGameSvg');
            const optionsContainer = document.getElementById('gameOptions');
            const scoreContainer = document.getElementById('gameScore');

            if (svg && optionsContainer && scoreContainer && !figureGameInstance) {
                figureGameInstance = new FigureIdentificationGame(svg, optionsContainer, scoreContainer);
            }
        }

        function initFigureEvaluation() {
            if (!figureEvaluationInstance) {
                figureEvaluationInstance = new FigureEvaluation();
            }
        }

        // Initialize line position components
        let linePositionInstance = null;
        let linePositionEvaluationInstance = null;

        function initLinePosition() {
            const svg = document.getElementById('linePositionSvg');
            const statusElement = document.getElementById('positionStatus');

            if (svg && statusElement && !linePositionInstance) {
                linePositionInstance = new LinePositionInteraction(svg, statusElement);
            }
        }

        function initLinePositionEvaluation() {
            if (!linePositionEvaluationInstance) {
                linePositionEvaluationInstance = new LinePositionEvaluation();
            }
        }

        // Initialize and run tests when the page loads (for development)
        // Uncomment the following lines to run tests automatically:
        // window.angleTests = new AngleCalculationTests();
        // window.addEventListener('load', () => {
        //     setTimeout(() => window.angleTests.runAllTests(), 1000);
        // });

        // Expose test runner for manual execution
        window.runAngleTests = function () {
            const testRunner = new AngleCalculationTests();
            return testRunner.runAllTests();
        };

        // Unit Tests for Position Detection - Line Position Interaction
        class PositionDetectionTests {
            constructor() {
                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;
            }

            // Test helper to create a test line position instance
            createTestLinePosition() {
                const mockSvg = {
                    innerHTML: '',
                    querySelector: () => ({
                        setAttribute: () => {},
                        addEventListener: () => {},
                        style: {}
                    }),
                    getBoundingClientRect: () => ({ left: 0, top: 0, width: 500, height: 400 })
                };
                const mockStatusElement = {
                    innerHTML: ''
                };
                return new LinePositionInteraction(mockSvg, mockStatusElement);
            }

            // Assert helper
            assert(condition, testName, message) {
                this.totalTests++;
                const passed = condition;
                if (passed) {
                    this.passedTests++;
                }

                this.testResults.push({
                    status: passed ? 'PASS' : 'FAIL',
                    name: testName,
                    message: message || (passed ? 'Test passed' : 'Test failed')
                });

                console.log(`${passed ? '‚úÖ' : '‚ùå'} ${testName}: ${message || (passed ? 'PASS' : 'FAIL')}`);
                return passed;
            }

            // Test distance calculation for exterior position
            testExteriorPosition() {
                const linePosition = this.createTestLinePosition();
                
                // Set line position far from circle (distance > radius + tolerance)
                linePosition.line.y1 = 100; // Circle center is at y=200, radius=80
                linePosition.line.y2 = 100;
                
                const position = linePosition.detectPosition();
                const distance = Math.abs(linePosition.line.y1 - linePosition.circle.cy);
                
                this.assert(
                    position === 'exterior',
                    'Exterior Position Detection',
                    `Expected 'exterior', got '${position}' (distance: ${distance}, radius: ${linePosition.circle.r})`
                );

                this.assert(
                    distance > linePosition.circle.r + 2,
                    'Exterior Distance Calculation',
                    `Distance ${distance} should be > ${linePosition.circle.r + 2}`
                );
            }

            // Test distance calculation for tangent position
            testTangentPosition() {
                const linePosition = this.createTestLinePosition();
                
                // Set line position exactly at tangent distance (distance = radius ¬± tolerance)
                linePosition.line.y1 = linePosition.circle.cy - linePosition.circle.r; // Exactly at radius distance
                linePosition.line.y2 = linePosition.line.y1;
                
                const position = linePosition.detectPosition();
                const distance = Math.abs(linePosition.line.y1 - linePosition.circle.cy);
                
                this.assert(
                    position === 'tangente',
                    'Tangent Position Detection',
                    `Expected 'tangente', got '${position}' (distance: ${distance}, radius: ${linePosition.circle.r})`
                );

                this.assert(
                    Math.abs(distance - linePosition.circle.r) <= 2,
                    'Tangent Distance Calculation',
                    `Distance difference ${Math.abs(distance - linePosition.circle.r)} should be <= 2`
                );
            }

            // Test distance calculation for secant position
            testSecantPosition() {
                const linePosition = this.createTestLinePosition();
                
                // Set line position inside circle (distance < radius - tolerance)
                linePosition.line.y1 = linePosition.circle.cy - 30; // Well inside the circle
                linePosition.line.y2 = linePosition.line.y1;
                
                const position = linePosition.detectPosition();
                const distance = Math.abs(linePosition.line.y1 - linePosition.circle.cy);
                
                this.assert(
                    position === 'secante',
                    'Secant Position Detection',
                    `Expected 'secante', got '${position}' (distance: ${distance}, radius: ${linePosition.circle.r})`
                );

                this.assert(
                    distance < linePosition.circle.r - 2,
                    'Secant Distance Calculation',
                    `Distance ${distance} should be < ${linePosition.circle.r - 2}`
                );
            }

            // Test edge cases near boundaries
            testBoundaryConditions() {
                const linePosition = this.createTestLinePosition();
                
                // Test just outside tangent (should be exterior)
                linePosition.line.y1 = linePosition.circle.cy - linePosition.circle.r - 3;
                linePosition.line.y2 = linePosition.line.y1;
                
                let position = linePosition.detectPosition();
                this.assert(
                    position === 'exterior',
                    'Boundary: Just Outside Tangent',
                    `Expected 'exterior', got '${position}'`
                );

                // Test just inside tangent (should be secant)
                linePosition.line.y1 = linePosition.circle.cy - linePosition.circle.r + 3;
                linePosition.line.y2 = linePosition.line.y1;
                
                position = linePosition.detectPosition();
                this.assert(
                    position === 'secante',
                    'Boundary: Just Inside Tangent',
                    `Expected 'secante', got '${position}'`
                );
            }

            // Test tolerance handling in position detection
            testToleranceHandling() {
                const linePosition = this.createTestLinePosition();
                
                // Test within tolerance range (should be tangent)
                linePosition.line.y1 = linePosition.circle.cy - linePosition.circle.r + 1; // Within ¬±2 tolerance
                linePosition.line.y2 = linePosition.line.y1;
                
                const position = linePosition.detectPosition();
                this.assert(
                    position === 'tangente',
                    'Tolerance: Within Range',
                    `Expected 'tangente', got '${position}' (tolerance test)`
                );

                // Test at exact tolerance boundary
                linePosition.line.y1 = linePosition.circle.cy - linePosition.circle.r - 2; // Exactly at tolerance
                linePosition.line.y2 = linePosition.line.y1;
                
                const position2 = linePosition.detectPosition();
                this.assert(
                    position2 === 'tangente',
                    'Tolerance: At Boundary',
                    `Expected 'tangente', got '${position2}' (boundary tolerance test)`
                );
            }

            // Test distance calculation accuracy
            testDistanceCalculationAccuracy() {
                const linePosition = this.createTestLinePosition();
                
                // Test various positions and verify distance calculations
                const testCases = [
                    { y: 100, expectedDistance: 100 },
                    { y: 150, expectedDistance: 50 },
                    { y: 200, expectedDistance: 0 },
                    { y: 250, expectedDistance: 50 },
                    { y: 300, expectedDistance: 100 }
                ];

                testCases.forEach((testCase, index) => {
                    linePosition.line.y1 = testCase.y;
                    linePosition.line.y2 = testCase.y;
                    
                    const calculatedDistance = Math.abs(linePosition.line.y1 - linePosition.circle.cy);
                    
                    this.assert(
                        calculatedDistance === testCase.expectedDistance,
                        `Distance Accuracy Test ${index + 1}`,
                        `Expected distance ${testCase.expectedDistance}, got ${calculatedDistance} for y=${testCase.y}`
                    );
                });
            }

            // Test position classification logic consistency
            testPositionClassificationLogic() {
                const linePosition = this.createTestLinePosition();
                
                // Test multiple positions to ensure consistent classification
                const testPositions = [
                    { y: 50, expected: 'exterior' },   // Far above
                    { y: 118, expected: 'tangente' },  // At tangent (200-80-2)
                    { y: 120, expected: 'tangente' },  // Within tolerance
                    { y: 122, expected: 'tangente' },  // At tolerance boundary
                    { y: 124, expected: 'secante' },   // Just inside
                    { y: 150, expected: 'secante' },   // Inside
                    { y: 200, expected: 'secante' },   // At center
                    { y: 250, expected: 'secante' },   // Inside (other side)
                    { y: 276, expected: 'secante' },   // Just inside (other side)
                    { y: 278, expected: 'tangente' },  // At tolerance boundary
                    { y: 280, expected: 'tangente' },  // Within tolerance
                    { y: 282, expected: 'tangente' },  // At tangent (200+80+2)
                    { y: 350, expected: 'exterior' }   // Far below
                ];

                testPositions.forEach((test, index) => {
                    linePosition.line.y1 = test.y;
                    linePosition.line.y2 = test.y;
                    
                    const position = linePosition.detectPosition();
                    
                    this.assert(
                        position === test.expected,
                        `Classification Logic Test ${index + 1}`,
                        `At y=${test.y}: expected '${test.expected}', got '${position}'`
                    );
                });
            }

            // Run all position detection tests
            runAllTests() {
                console.log('üß™ Starting Position Detection Unit Tests...\n');
                
                this.testResults = [];
                this.totalTests = 0;
                this.passedTests = 0;

                try {
                    this.testExteriorPosition();
                    this.testTangentPosition();
                    this.testSecantPosition();
                    this.testBoundaryConditions();
                    this.testToleranceHandling();
                    this.testDistanceCalculationAccuracy();
                    this.testPositionClassificationLogic();
                } catch (error) {
                    console.error('‚ùå Test execution error:', error);
                    this.testResults.push({
                        status: 'ERROR',
                        name: 'Test Execution',
                        message: `Error during test execution: ${error.message}`
                    });
                }

                // Report results
                console.log(`\nüìä Position Detection Test Results:`);
                console.log(`‚úÖ Passed: ${this.passedTests}/${this.totalTests}`);
                console.log(`‚ùå Failed: ${this.totalTests - this.passedTests}`);

                if (this.passedTests < this.totalTests) {
                    console.log('\n‚ùå Failed Tests:');
                    this.testResults
                        .filter(r => r.status !== 'PASS')
                        .forEach(result => {
                            console.log(`   ${result.name}: ${result.message}`);
                        });
                }

                return this.testResults;
            }
        }

        // Global function to run position detection tests
        function runPositionDetectionTests() {
            const tester = new PositionDetectionTests();
            return tester.runAllTests();
        }

        // Comprehensive Manual Testing Framework
        class ComprehensiveTestSuite {
            constructor() {
                this.testResults = [];
                this.currentTest = 0;
                this.totalTests = 0;
            }

            // Test all interactive elements across different devices/screen sizes
            async testInteractiveElements() {
                console.log('üß™ Testing Interactive Elements...');
                
                const tests = [
                    {
                        name: 'Module Navigation',
                        test: () => this.testModuleNavigation()
                    },
                    {
                        name: 'Tab Switching',
                        test: () => this.testTabSwitching()
                    },
                    {
                        name: 'Angle Triangle Interaction',
                        test: () => this.testAngleTriangleInteraction()
                    },
                    {
                        name: 'Circle Elements Hover',
                        test: () => this.testCircleElementsHover()
                    },
                    {
                        name: 'Pi Animation Controls',
                        test: () => this.testPiAnimationControls()
                    },
                    {
                        name: 'Figure Game Interaction',
                        test: () => this.testFigureGameInteraction()
                    },
                    {
                        name: 'Line Position Dragging',
                        test: () => this.testLinePositionDragging()
                    },
                    {
                        name: 'Evaluation Systems',
                        test: () => this.testEvaluationSystems()
                    },
                    {
                        name: 'Responsive Design',
                        test: () => this.testResponsiveDesign()
                    },
                    {
                        name: 'Mathematical Accuracy',
                        test: () => this.testMathematicalAccuracy()
                    }
                ];

                for (const test of tests) {
                    try {
                        console.log(`üîç Running: ${test.name}`);
                        const result = await test.test();
                        this.testResults.push({
                            name: test.name,
                            status: result ? 'PASS' : 'FAIL',
                            details: result === true ? 'Test passed' : result
                        });
                    } catch (error) {
                        console.error(`‚ùå Error in ${test.name}:`, error);
                        this.testResults.push({
                            name: test.name,
                            status: 'ERROR',
                            details: error.message
                        });
                    }
                }

                return this.generateTestReport();
            }

            // Test module navigation functionality
            testModuleNavigation() {
                const moduleCards = document.querySelectorAll('.module-card');
                if (moduleCards.length !== 5) {
                    return `Expected 5 module cards, found ${moduleCards.length}`;
                }

                // Test that each module has required properties
                const requiredModules = ['suma-angulos', 'circunferencia', 'numero-pi', 'circulo-figuras', 'posiciones-rectas'];
                for (const moduleId of requiredModules) {
                    if (!content[moduleId]) {
                        return `Missing module: ${moduleId}`;
                    }
                    
                    const module = content[moduleId];
                    if (!module.title || !module.description || !module.teoria || !module.practica || !module.evaluacion) {
                        return `Incomplete module data for: ${moduleId}`;
                    }
                }

                return true;
            }

            // Test tab switching functionality
            testTabSwitching() {
                const tabButtons = document.querySelectorAll('.tab-button');
                if (tabButtons.length !== 3) {
                    return `Expected 3 tab buttons, found ${tabButtons.length}`;
                }

                const expectedTabs = ['teoria', 'practica', 'evaluacion'];
                for (let i = 0; i < tabButtons.length; i++) {
                    const tab = tabButtons[i].dataset.tab;
                    if (!expectedTabs.includes(tab)) {
                        return `Invalid tab found: ${tab}`;
                    }
                }

                return true;
            }

            // Test angle triangle interaction
            testAngleTriangleInteraction() {
                // Simulate loading suma-angulos module
                const mockTriangle = {
                    vertices: [
                        { x: 250, y: 100, id: 'A' },
                        { x: 150, y: 300, id: 'B' },
                        { x: 350, y: 300, id: 'C' }
                    ],
                    angles: [60, 60, 60]
                };

                // Test angle sum calculation
                const sum = mockTriangle.angles.reduce((a, b) => a + b, 0);
                if (Math.abs(sum - 180) > 1) {
                    return `Angle sum incorrect: ${sum}¬∞ (expected ~180¬∞)`;
                }

                // Test vertex constraints
                for (const vertex of mockTriangle.vertices) {
                    if (vertex.x < 0 || vertex.x > 500 || vertex.y < 0 || vertex.y > 400) {
                        return `Vertex out of bounds: ${vertex.id} at (${vertex.x}, ${vertex.y})`;
                    }
                }

                return true;
            }

            // Test circle elements hover functionality
            testCircleElementsHover() {
                const elements = ['center', 'radius', 'diameter', 'chord', 'arc', 'tangent'];
                
                // Verify all elements are defined
                for (const element of elements) {
                    // This would be tested in actual DOM interaction
                    if (!element) {
                        return `Missing circle element: ${element}`;
                    }
                }

                return true;
            }

            // Test pi animation controls
            testPiAnimationControls() {
                // Test pi calculation accuracy
                const testRadius = 10;
                const expectedCircumference = 2 * Math.PI * testRadius;
                const calculatedCircumference = 2 * 3.14 * testRadius;
                
                if (Math.abs(expectedCircumference - calculatedCircumference) > 0.1) {
                    return `Pi calculation inaccurate: expected ${expectedCircumference}, got ${calculatedCircumference}`;
                }

                return true;
            }

            // Test figure game interaction
            testFigureGameInteraction() {
                const figureTypes = ['sector', 'segment', 'corona'];
                
                // Verify all figure types are supported
                for (const figureType of figureTypes) {
                    if (!figureType) {
                        return `Missing figure type: ${figureType}`;
                    }
                }

                return true;
            }

            // Test line position dragging
            testLinePositionDragging() {
                // Test position detection logic
                const circle = { cx: 200, cy: 200, r: 80 };
                
                const testCases = [
                    { lineY: 100, expected: 'exterior' },
                    { lineY: 120, expected: 'tangente' },
                    { lineY: 150, expected: 'secante' },
                    { lineY: 200, expected: 'secante' },
                    { lineY: 250, expected: 'secante' },
                    { lineY: 280, expected: 'tangente' },
                    { lineY: 300, expected: 'exterior' }
                ];

                for (const testCase of testCases) {
                    const distance = Math.abs(testCase.lineY - circle.cy);
                    let position;
                    
                    if (distance > circle.r + 2) {
                        position = 'exterior';
                    } else if (Math.abs(distance - circle.r) <= 2) {
                        position = 'tangente';
                    } else {
                        position = 'secante';
                    }

                    if (position !== testCase.expected) {
                        return `Position detection failed for lineY=${testCase.lineY}: expected ${testCase.expected}, got ${position}`;
                    }
                }

                return true;
            }

            // Test evaluation systems
            testEvaluationSystems() {
                // Test that evaluation functions exist for all modules
                const modules = Object.keys(content);
                
                for (const moduleId of modules) {
                    const module = content[moduleId];
                    if (typeof module.evaluacion !== 'function') {
                        return `Missing evaluation function for module: ${moduleId}`;
                    }
                    
                    try {
                        const evaluationHTML = module.evaluacion();
                        if (!evaluationHTML || typeof evaluationHTML !== 'string') {
                            return `Invalid evaluation HTML for module: ${moduleId}`;
                        }
                    } catch (error) {
                        return `Error generating evaluation for module ${moduleId}: ${error.message}`;
                    }
                }

                return true;
            }

            // Test responsive design
            testResponsiveDesign() {
                const viewportWidths = [320, 768, 1024, 1920];
                
                for (const width of viewportWidths) {
                    // Simulate different viewport sizes
                    const isMobile = width <= 768;
                    const isTablet = width > 768 && width <= 1024;
                    const isDesktop = width > 1024;
                    
                    // Check that appropriate classes and styles would be applied
                    if (isMobile && !document.querySelector('meta[name="viewport"]')) {
                        return 'Missing viewport meta tag for mobile responsiveness';
                    }
                }

                return true;
            }

            // Test mathematical accuracy
            testMathematicalAccuracy() {
                const tests = [
                    {
                        name: 'Angle Sum - Triangle',
                        test: () => {
                            const angles = [60, 60, 60];
                            const sum = angles.reduce((a, b) => a + b, 0);
                            return Math.abs(sum - 180) < 0.001;
                        }
                    },
                    {
                        name: 'Angle Sum - Quadrilateral',
                        test: () => {
                            const angles = [90, 90, 90, 90];
                            const sum = angles.reduce((a, b) => a + b, 0);
                            return Math.abs(sum - 360) < 0.001;
                        }
                    },
                    {
                        name: 'Circumference Calculation',
                        test: () => {
                            const radius = 5;
                            const circumference = 2 * 3.14 * radius;
                            const expected = 31.4;
                            return Math.abs(circumference - expected) < 0.1;
                        }
                    },
                    {
                        name: 'Distance Calculation',
                        test: () => {
                            const p1 = { x: 0, y: 0 };
                            const p2 = { x: 3, y: 4 };
                            const distance = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                            return Math.abs(distance - 5) < 0.001;
                        }
                    }
                ];

                for (const test of tests) {
                    if (!test.test()) {
                        return `Mathematical accuracy test failed: ${test.name}`;
                    }
                }

                return true;
            }

            // Generate comprehensive test report
            generateTestReport() {
                const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
                const failedTests = this.testResults.filter(r => r.status === 'FAIL').length;
                const errorTests = this.testResults.filter(r => r.status === 'ERROR').length;
                const totalTests = this.testResults.length;

                const report = {
                    summary: {
                        total: totalTests,
                        passed: passedTests,
                        failed: failedTests,
                        errors: errorTests,
                        successRate: ((passedTests / totalTests) * 100).toFixed(1)
                    },
                    details: this.testResults,
                    recommendations: []
                };

                // Add recommendations based on test results
                if (failedTests > 0) {
                    report.recommendations.push('Review failed tests and fix identified issues');
                }
                
                if (errorTests > 0) {
                    report.recommendations.push('Investigate and resolve test execution errors');
                }
                
                if (report.summary.successRate < 90) {
                    report.recommendations.push('Consider additional testing and quality improvements');
                }

                console.log('üìä Comprehensive Test Report:');
                console.log(`‚úÖ Passed: ${passedTests}/${totalTests}`);
                console.log(`‚ùå Failed: ${failedTests}/${totalTests}`);
                console.log(`üö´ Errors: ${errorTests}/${totalTests}`);
                console.log(`üìà Success Rate: ${report.summary.successRate}%`);

                if (report.recommendations.length > 0) {
                    console.log('üí° Recommendations:');
                    report.recommendations.forEach(rec => console.log(`   - ${rec}`));
                }

                return report;
            }
        }

        // Global function to run comprehensive tests
        window.runComprehensiveTests = async function() {
            const testSuite = new ComprehensiveTestSuite();
            return await testSuite.testInteractiveElements();
        };

        // Device-specific testing utilities
        class DeviceTestingUtils {
            static getCurrentDeviceInfo() {
                return {
                    userAgent: navigator.userAgent,
                    screenWidth: window.screen.width,
                    screenHeight: window.screen.height,
                    viewportWidth: window.innerWidth,
                    viewportHeight: window.innerHeight,
                    devicePixelRatio: window.devicePixelRatio,
                    touchSupport: 'ontouchstart' in window,
                    orientation: window.screen.orientation ? window.screen.orientation.type : 'unknown'
                };
            }

            static isMobileDevice() {
                return window.innerWidth <= 768 || 'ontouchstart' in window;
            }

            static isTabletDevice() {
                return window.innerWidth > 768 && window.innerWidth <= 1024;
            }

            static isDesktopDevice() {
                return window.innerWidth > 1024;
            }

            static logDeviceInfo() {
                const info = this.getCurrentDeviceInfo();
                console.log('üì± Device Information:');
                console.log(`   Screen: ${info.screenWidth}x${info.screenHeight}`);
                console.log(`   Viewport: ${info.viewportWidth}x${info.viewportHeight}`);
                console.log(`   Pixel Ratio: ${info.devicePixelRatio}`);
                console.log(`   Touch Support: ${info.touchSupport}`);
                console.log(`   Orientation: ${info.orientation}`);
                console.log(`   Device Type: ${this.isMobileDevice() ? 'Mobile' : this.isTabletDevice() ? 'Tablet' : 'Desktop'}`);
            }
        }

        // Visual Design Consistency Checker
        class VisualConsistencyChecker {
            static checkDesignConsistency() {
                console.log('üé® Checking Visual Design Consistency...');
                
                const issues = [];
                
                // Check color consistency
                const colorIssues = this.checkColorConsistency();
                if (colorIssues.length > 0) {
                    issues.push(...colorIssues);
                }
                
                // Check typography consistency
                const typographyIssues = this.checkTypographyConsistency();
                if (typographyIssues.length > 0) {
                    issues.push(...typographyIssues);
                }
                
                // Check spacing consistency
                const spacingIssues = this.checkSpacingConsistency();
                if (spacingIssues.length > 0) {
                    issues.push(...spacingIssues);
                }
                
                // Check interactive element consistency
                const interactionIssues = this.checkInteractionConsistency();
                if (interactionIssues.length > 0) {
                    issues.push(...interactionIssues);
                }
                
                if (issues.length === 0) {
                    console.log('‚úÖ Visual design consistency check passed');
                    return { status: 'PASS', issues: [] };
                } else {
                    console.warn(`‚ö†Ô∏è Found ${issues.length} visual consistency issues:`);
                    issues.forEach(issue => console.warn(`   - ${issue}`));
                    return { status: 'ISSUES', issues };
                }
            }
            
            static checkColorConsistency() {
                const issues = [];
                
                // Check that all module cards use consistent color scheme
                const moduleCards = document.querySelectorAll('.module-card');
                const expectedColors = ['bg-red-500', 'bg-green-500', 'bg-purple-500', 'bg-yellow-500', 'bg-blue-500'];
                
                moduleCards.forEach((card, index) => {
                    const hasExpectedColor = expectedColors.some(color => card.classList.contains(color));
                    if (!hasExpectedColor) {
                        issues.push(`Module card ${index + 1} missing expected color class`);
                    }
                });
                
                return issues;
            }
            
            static checkTypographyConsistency() {
                const issues = [];
                
                // Check heading hierarchy
                const h1Elements = document.querySelectorAll('h1');
                const h2Elements = document.querySelectorAll('h2');
                const h3Elements = document.querySelectorAll('h3');
                
                if (h1Elements.length === 0) {
                    issues.push('No H1 elements found - missing main heading');
                }
                
                // Check that headings have consistent styling
                h1Elements.forEach((h1, index) => {
                    const computedStyle = window.getComputedStyle(h1);
                    if (!h1.classList.contains('text-4xl') && !h1.classList.contains('text-3xl') && !h1.classList.contains('text-2xl')) {
                        issues.push(`H1 element ${index + 1} missing size class`);
                    }
                });
                
                return issues;
            }
            
            static checkSpacingConsistency() {
                const issues = [];
                
                // Check that containers have consistent padding
                const containers = document.querySelectorAll('.container');
                containers.forEach((container, index) => {
                    if (!container.classList.contains('px-4') && !container.classList.contains('p-4') && !container.classList.contains('p-6')) {
                        issues.push(`Container ${index + 1} missing padding classes`);
                    }
                });
                
                return issues;
            }
            
            static checkInteractionConsistency() {
                const issues = [];
                
                // Check that all buttons have consistent styling
                const buttons = document.querySelectorAll('button');
                buttons.forEach((button, index) => {
                    if (!button.classList.contains('rounded-lg') && !button.classList.contains('rounded')) {
                        issues.push(`Button ${index + 1} missing border radius class`);
                    }
                    
                    if (!button.classList.contains('px-4') && !button.classList.contains('px-6') && !button.classList.contains('p-4')) {
                        issues.push(`Button ${index + 1} missing padding class`);
                    }
                });
                
                // Check that interactive elements have touch-target class on mobile
                const interactiveElements = document.querySelectorAll('.interactive-element');
                interactiveElements.forEach((element, index) => {
                    if (DeviceTestingUtils.isMobileDevice() && !element.classList.contains('touch-target')) {
                        issues.push(`Interactive element ${index + 1} missing touch-target class for mobile`);
                    }
                });
                
                return issues;
            }
        }

        // Performance testing utilities
        class PerformanceTestingUtils {
            static measurePageLoadTime() {
                if (performance.timing) {
                    const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                    console.log(`üìä Page Load Time: ${loadTime}ms`);
                    return loadTime;
                }
                return null;
            }
            
            static measureAnimationPerformance(animationFunction, iterations = 100) {
                const startTime = performance.now();
                
                for (let i = 0; i < iterations; i++) {
                    animationFunction();
                }
                
                const endTime = performance.now();
                const averageTime = (endTime - startTime) / iterations;
                
                console.log(`üé¨ Animation Performance: ${averageTime.toFixed(2)}ms average over ${iterations} iterations`);
                return averageTime;
            }
            
            static checkMemoryUsage() {
                if (performance.memory) {
                    const memoryInfo = {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                    
                    console.log(`üíæ Memory Usage: ${memoryInfo.used}MB / ${memoryInfo.total}MB (Limit: ${memoryInfo.limit}MB)`);
                    return memoryInfo;
                }
                return null;
            }
        }

        // Initialize comprehensive testing on load
        document.addEventListener('DOMContentLoaded', () => {
            DeviceTestingUtils.logDeviceInfo();
            
            // Run performance measurements
            setTimeout(() => {
                PerformanceTestingUtils.measurePageLoadTime();
                PerformanceTestingUtils.checkMemoryUsage();
            }, 1000);
            
            // Run visual consistency check
            setTimeout(() => {
                VisualConsistencyChecker.checkDesignConsistency();
            }, 2000);
        });

        // Automated Testing Utilities
        class MathTestingUtils {
            // Helper functions for testing mathematical calculations
            
            static validateAngleSum(angles, expectedSum = 180, tolerance = 0.001) {
                const actualSum = angles.reduce((sum, angle) => sum + angle, 0);
                return Math.abs(actualSum - expectedSum) <= tolerance;
            }
            
            static validateCircumferenceCalculation(radius, calculatedCircumference, tolerance = 0.01) {
                const expectedCircumference = 2 * Math.PI * radius;
                return Math.abs(calculatedCircumference - expectedCircumference) <= tolerance;
            }
            
            static validateDistanceCalculation(point1, point2, calculatedDistance, tolerance = 0.001) {
                const expectedDistance = Math.sqrt(
                    Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)
                );
                return Math.abs(calculatedDistance - expectedDistance) <= tolerance;
            }
            
            static validateAngleCalculation(vertex1, vertex2, vertex3, calculatedAngle, tolerance = 0.001) {
                // Calculate expected angle using vector mathematics
                const v1 = { x: vertex1.x - vertex2.x, y: vertex1.y - vertex2.y };
                const v2 = { x: vertex3.x - vertex2.x, y: vertex3.y - vertex2.y };
                
                const dot = v1.x * v2.x + v1.y * v2.y;
                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                
                if (mag1 === 0 || mag2 === 0) return false;
                
                const cosAngle = dot / (mag1 * mag2);
                const expectedAngle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
                
                return Math.abs(calculatedAngle - expectedAngle) <= tolerance;
            }
            
            static validatePositionClassification(lineY, circleCenter, circleRadius, expectedPosition) {
                const distance = Math.abs(lineY - circleCenter.y);
                let actualPosition;
                
                if (distance > circleRadius + 0.001) {
                    actualPosition = 'exterior';
                } else if (Math.abs(distance - circleRadius) <= 0.001) {
                    actualPosition = 'tangente';
                } else {
                    actualPosition = 'secante';
                }
                
                return actualPosition === expectedPosition;
            }
            
            static generateTestVertices(type = 'triangle') {
                // Generate standard test vertices for different shapes
                const testVertices = {
                    triangle: {
                        equilateral: [
                            { x: 250, y: 100 },
                            { x: 200, y: 186.6 },
                            { x: 300, y: 186.6 }
                        ],
                        right: [
                            { x: 200, y: 200 },
                            { x: 300, y: 200 },
                            { x: 200, y: 100 }
                        ],
                        obtuse: [
                            { x: 200, y: 200 },
                            { x: 350, y: 200 },
                            { x: 220, y: 150 }
                        ]
                    },
                    quadrilateral: {
                        rectangle: [
                            { x: 200, y: 150 },
                            { x: 300, y: 150 },
                            { x: 300, y: 250 },
                            { x: 200, y: 250 }
                        ],
                        square: [
                            { x: 200, y: 200 },
                            { x: 300, y: 200 },
                            { x: 300, y: 300 },
                            { x: 200, y: 300 }
                        ]
                    }
                };
                
                return testVertices[type] || testVertices.triangle;
            }
            
            static createTestCircle(centerX = 250, centerY = 200, radius = 80) {
                return {
                    center: { x: centerX, y: centerY },
                    radius: radius,
                    diameter: radius * 2,
                    circumference: 2 * Math.PI * radius
                };
            }
            
            static runMathValidationSuite() {
                const results = [];
                
                // Test angle sum validation
                const triangleAngles = [60, 60, 60];
                results.push({
                    test: 'Angle Sum Validation - Equilateral Triangle',
                    passed: this.validateAngleSum(triangleAngles, 180),
                    details: `Sum: ${triangleAngles.reduce((a, b) => a + b, 0)}¬∞`
                });
                
                // Test circumference calculation
                const testRadius = 10;
                const calculatedCircumference = 2 * 3.14159 * testRadius;
                results.push({
                    test: 'Circumference Calculation Validation',
                    passed: this.validateCircumferenceCalculation(testRadius, calculatedCircumference, 0.01),
                    details: `Radius: ${testRadius}, Circumference: ${calculatedCircumference.toFixed(2)}`
                });
                
                // Test distance calculation
                const point1 = { x: 0, y: 0 };
                const point2 = { x: 3, y: 4 };
                const calculatedDistance = 5; // 3-4-5 triangle
                results.push({
                    test: 'Distance Calculation Validation',
                    passed: this.validateDistanceCalculation(point1, point2, calculatedDistance),
                    details: `Points: (0,0) to (3,4), Distance: ${calculatedDistance}`
                });
                
                // Test position classification
                const circle = { x: 200, y: 200 };
                const radius = 80;
                results.push({
                    test: 'Position Classification - Exterior',
                    passed: this.validatePositionClassification(50, circle, radius, 'exterior'),
                    details: 'Line at y=50, circle center at y=200, radius=80'
                });
                
                return results;
            }
        }

        class MockInteractionUtils {
            // Mock interaction utilities for testing drag operations
            
            static createMockMouseEvent(type, x, y, target = null) {
                return {
                    type: type,
                    clientX: x,
                    clientY: y,
                    target: target,
                    preventDefault: () => {},
                    stopPropagation: () => {}
                };
            }
            
            static createMockTouchEvent(type, x, y, target = null) {
                return {
                    type: type,
                    touches: [{
                        clientX: x,
                        clientY: y,
                        target: target
                    }],
                    changedTouches: [{
                        clientX: x,
                        clientY: y,
                        target: target
                    }],
                    preventDefault: () => {},
                    stopPropagation: () => {}
                };
            }
            
            static simulateDragSequence(element, startX, startY, endX, endY, steps = 5) {
                const events = [];
                
                // Start drag
                events.push({
                    event: this.createMockMouseEvent('mousedown', startX, startY, element),
                    description: `Start drag at (${startX}, ${startY})`
                });
                
                // Intermediate drag steps
                for (let i = 1; i <= steps; i++) {
                    const progress = i / steps;
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY + (endY - startY) * progress;
                    
                    events.push({
                        event: this.createMockMouseEvent('mousemove', currentX, currentY, element),
                        description: `Drag step ${i} at (${currentX.toFixed(1)}, ${currentY.toFixed(1)})`
                    });
                }
                
                // End drag
                events.push({
                    event: this.createMockMouseEvent('mouseup', endX, endY, element),
                    description: `End drag at (${endX}, ${endY})`
                });
                
                return events;
            }
            
            static simulateTouchDragSequence(element, startX, startY, endX, endY, steps = 5) {
                const events = [];
                
                // Start touch
                events.push({
                    event: this.createMockTouchEvent('touchstart', startX, startY, element),
                    description: `Start touch at (${startX}, ${startY})`
                });
                
                // Touch move steps
                for (let i = 1; i <= steps; i++) {
                    const progress = i / steps;
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY + (endY - startY) * progress;
                    
                    events.push({
                        event: this.createMockTouchEvent('touchmove', currentX, currentY, element),
                        description: `Touch move step ${i} at (${currentX.toFixed(1)}, ${currentY.toFixed(1)})`
                    });
                }
                
                // End touch
                events.push({
                    event: this.createMockTouchEvent('touchend', endX, endY, element),
                    description: `End touch at (${endX}, ${endY})`
                });
                
                return events;
            }
            
            static createMockSVGElement(type, attributes = {}) {
                const element = {
                    tagName: type.toUpperCase(),
                    attributes: { ...attributes },
                    getBoundingClientRect: () => ({
                        left: attributes.cx || attributes.x || 0,
                        top: attributes.cy || attributes.y || 0,
                        width: attributes.r ? attributes.r * 2 : attributes.width || 0,
                        height: attributes.r ? attributes.r * 2 : attributes.height || 0
                    }),
                    setAttribute: (name, value) => {
                        element.attributes[name] = value;
                    },
                    getAttribute: (name) => element.attributes[name],
                    addEventListener: () => {},
                    removeEventListener: () => {}
                };
                
                return element;
            }
            
            static testDragInteraction(dragHandler, startPos, endPos) {
                // Create mock draggable element
                const mockElement = this.createMockSVGElement('circle', {
                    cx: startPos.x,
                    cy: startPos.y,
                    r: 8
                });
                
                // Simulate drag sequence
                const dragEvents = this.simulateDragSequence(
                    mockElement, 
                    startPos.x, 
                    startPos.y, 
                    endPos.x, 
                    endPos.y
                );
                
                const results = [];
                
                try {
                    // Execute drag events
                    dragEvents.forEach((eventData, index) => {
                        if (typeof dragHandler === 'function') {
                            dragHandler(eventData.event);
                        }
                        
                        results.push({
                            step: index + 1,
                            description: eventData.description,
                            success: true
                        });
                    });
                    
                    return {
                        success: true,
                        steps: results,
                        finalPosition: { x: endPos.x, y: endPos.y }
                    };
                    
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        steps: results
                    };
                }
            }
            
            static runInteractionTestSuite() {
                const results = [];
                
                // Test mouse event creation
                const mouseEvent = this.createMockMouseEvent('click', 100, 200);
                results.push({
                    test: 'Mock Mouse Event Creation',
                    passed: mouseEvent.type === 'click' && mouseEvent.clientX === 100 && mouseEvent.clientY === 200,
                    details: `Event type: ${mouseEvent.type}, Position: (${mouseEvent.clientX}, ${mouseEvent.clientY})`
                });
                
                // Test touch event creation
                const touchEvent = this.createMockTouchEvent('touchstart', 150, 250);
                results.push({
                    test: 'Mock Touch Event Creation',
                    passed: touchEvent.type === 'touchstart' && touchEvent.touches[0].clientX === 150,
                    details: `Event type: ${touchEvent.type}, Touch position: (${touchEvent.touches[0].clientX}, ${touchEvent.touches[0].clientY})`
                });
                
                // Test drag sequence generation
                const dragSequence = this.simulateDragSequence(null, 0, 0, 100, 100, 3);
                results.push({
                    test: 'Drag Sequence Generation',
                    passed: dragSequence.length === 5, // mousedown + 3 moves + mouseup
                    details: `Generated ${dragSequence.length} events for drag sequence`
                });
                
                // Test SVG element mock
                const mockSVG = this.createMockSVGElement('circle', { cx: 50, cy: 75, r: 10 });
                results.push({
                    test: 'Mock SVG Element Creation',
                    passed: mockSVG.tagName === 'CIRCLE' && mockSVG.getAttribute('cx') == 50,
                    details: `Element: ${mockSVG.tagName}, cx: ${mockSVG.getAttribute('cx')}`
                });
                
                return results;
            }
        }

        class AutomatedTestRunner {
            // Comprehensive automated testing utilities
            
            static runAllAutomatedTests() {
                console.log('üöÄ Running Automated Testing Suite...\n');
                
                const mathResults = MathTestingUtils.runMathValidationSuite();
                const interactionResults = MockInteractionUtils.runInteractionTestSuite();
                
                console.log('üìä Mathematical Calculation Tests:');
                mathResults.forEach(result => {
                    const status = result.passed ? '‚úÖ' : '‚ùå';
                    console.log(`${status} ${result.test}: ${result.details}`);
                });
                
                console.log('\nüñ±Ô∏è Mock Interaction Tests:');
                interactionResults.forEach(result => {
                    const status = result.passed ? '‚úÖ' : '‚ùå';
                    console.log(`${status} ${result.test}: ${result.details}`);
                });
                
                const totalTests = mathResults.length + interactionResults.length;
                const passedTests = mathResults.filter(r => r.passed).length + 
                                 interactionResults.filter(r => r.passed).length;
                
                console.log(`\nüìà Test Summary: ${passedTests}/${totalTests} tests passed`);
                
                return {
                    mathResults,
                    interactionResults,
                    summary: {
                        total: totalTests,
                        passed: passedTests,
                        failed: totalTests - passedTests
                    }
                };
            }
            
            static validateAngleTriangleCalculations(triangleInstance) {
                if (!triangleInstance || !triangleInstance.vertices) {
                    return { success: false, error: 'Invalid triangle instance' };
                }
                
                const results = [];
                
                // Validate angle sum
                const angleSum = triangleInstance.angles.reduce((sum, angle) => sum + angle, 0);
                const expectedSum = triangleInstance.isQuadrilateral ? 360 : 180;
                
                results.push({
                    test: 'Angle Sum Validation',
                    passed: MathTestingUtils.validateAngleSum(triangleInstance.angles, expectedSum),
                    details: `Sum: ${angleSum.toFixed(2)}¬∞, Expected: ${expectedSum}¬∞`
                });
                
                // Validate individual angle calculations
                for (let i = 0; i < triangleInstance.vertices.length; i++) {
                    const prevIndex = (i - 1 + triangleInstance.vertices.length) % triangleInstance.vertices.length;
                    const nextIndex = (i + 1) % triangleInstance.vertices.length;
                    
                    const isValid = MathTestingUtils.validateAngleCalculation(
                        triangleInstance.vertices[prevIndex],
                        triangleInstance.vertices[i],
                        triangleInstance.vertices[nextIndex],
                        triangleInstance.angles[i]
                    );
                    
                    results.push({
                        test: `Angle ${i + 1} Calculation`,
                        passed: isValid,
                        details: `Calculated: ${triangleInstance.angles[i].toFixed(2)}¬∞`
                    });
                }
                
                return { success: true, results };
            }
            
            static validateCircumferenceCalculations(radius, diameter, circumference) {
                const results = [];
                
                // Validate radius-diameter relationship
                results.push({
                    test: 'Radius-Diameter Relationship',
                    passed: Math.abs(diameter - (radius * 2)) < 0.001,
                    details: `Radius: ${radius}, Diameter: ${diameter}`
                });
                
                // Validate circumference calculation
                results.push({
                    test: 'Circumference Calculation',
                    passed: MathTestingUtils.validateCircumferenceCalculation(radius, circumference),
                    details: `Radius: ${radius}, Circumference: ${circumference.toFixed(2)}`
                });
                
                return results;
            }
        }

        // Global testing functions for manual execution
        window.testVisualConsistency = () => VisualConsistencyChecker.checkDesignConsistency();
        window.testPerformance = () => {
            PerformanceTestingUtils.measurePageLoadTime();
            PerformanceTestingUtils.checkMemoryUsage();
        };
        window.testDeviceCompatibility = () => DeviceTestingUtils.logDeviceInfo();
        
        // New automated testing utilities
        window.runAutomatedTests = () => AutomatedTestRunner.runAllAutomatedTests();
        window.testMathCalculations = () => MathTestingUtils.runMathValidationSuite();
        window.testMockInteractions = () => MockInteractionUtils.runInteractionTestSuite();
        window.MathTestingUtils = MathTestingUtils;
        window.MockInteractionUtils = MockInteractionUtils;
        window.AutomatedTestRunner = AutomatedTestRunner;

        // Demonstration function for testing utilities integration
        window.demonstrateTestingUtilities = () => {
            console.log('üß™ Demonstrating Automated Testing Utilities Integration\n');
            
            // Test mathematical calculations
            console.log('üìä Testing Mathematical Calculations:');
            const mathResults = MathTestingUtils.runMathValidationSuite();
            mathResults.forEach(result => {
                const status = result.passed ? '‚úÖ' : '‚ùå';
                console.log(`${status} ${result.test}: ${result.details}`);
            });
            
            // Test mock interactions
            console.log('\nüñ±Ô∏è Testing Mock Interactions:');
            const interactionResults = MockInteractionUtils.runInteractionTestSuite();
            interactionResults.forEach(result => {
                const status = result.passed ? '‚úÖ' : '‚ùå';
                console.log(`${status} ${result.test}: ${result.details}`);
            });
            
            // Test integration with existing classes (if available)
            if (typeof angleTriangleInstance !== 'undefined' && angleTriangleInstance) {
                console.log('\nüî∫ Testing AngleTriangle Integration:');
                const triangleValidation = angleTriangleInstance.validateCalculations();
                if (triangleValidation.success) {
                    triangleValidation.results.forEach(result => {
                        const status = result.passed ? '‚úÖ' : '‚ùå';
                        console.log(`${status} ${result.test}: ${result.details}`);
                    });
                }
                
                // Test drag operation simulation
                const dragTest = angleTriangleInstance.testDragOperation(0, { x: 300, y: 150 });
                if (dragTest.success) {
                    console.log('‚úÖ Drag operation simulation completed successfully');
                } else {
                    console.log('‚ùå Drag operation simulation failed:', dragTest.error);
                }
            }
            
            if (typeof circleElementsInstance !== 'undefined' && circleElementsInstance) {
                console.log('\n‚≠ï Testing CircleElements Integration:');
                const circleValidation = circleElementsInstance.validateCircleCalculations();
                circleValidation.forEach(result => {
                    const status = result.passed ? '‚úÖ' : '‚ùå';
                    console.log(`${status} ${result.test}: ${result.details}`);
                });
                
                // Test hover interaction simulation
                const hoverTest = circleElementsInstance.testHoverInteraction('center');
                if (hoverTest.success) {
                    console.log('‚úÖ Hover interaction simulation completed successfully');
                } else {
                    console.log('‚ùå Hover interaction simulation failed:', hoverTest.error);
                }
            }
            
            console.log('\nüéØ Testing utilities demonstration complete!');
            console.log('üí° Use these utilities in your own tests by calling the exposed functions.');
        };

        document.addEventListener('DOMContentLoaded', initApp);

        // Register service worker for PWA functionality with offline verification
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('‚úÖ Service Worker registered successfully:', registration);
                        
                        // Verify offline functionality
                        verifyOfflineFunctionality();
                        
                        // Listen for service worker updates
                        registration.addEventListener('updatefound', () => {
                            console.log('üîÑ Service Worker update found');
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('‚úÖ New Service Worker installed');
                                    showNotification('Aplicaci√≥n actualizada. Recarga para obtener la nueva versi√≥n.', 'info', 5000);
                                }
                            });
                        });
                    })
                    .catch(registrationError => {
                        console.error('‚ùå Service Worker registration failed:', registrationError);
                        showNotification('Advertencia: La funcionalidad offline puede no estar disponible', 'error', 4000);
                    });
            });
        }

        // Verify offline functionality
        function verifyOfflineFunctionality() {
            // Test if all interactive elements work offline
            const offlineTests = [
                {
                    name: 'SVG Rendering',
                    test: () => {
                        const testSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        testSvg.setAttribute('width', '100');
                        testSvg.setAttribute('height', '100');
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', '50');
                        circle.setAttribute('cy', '50');
                        circle.setAttribute('r', '25');
                        testSvg.appendChild(circle);
                        return testSvg.children.length > 0;
                    }
                },
                {
                    name: 'Mathematical Calculations',
                    test: () => {
                        // Test angle calculations
                        const testAngle = Math.atan2(1, 1) * (180 / Math.PI);
                        return Math.abs(testAngle - 45) < 0.001;
                    }
                },
                {
                    name: 'Local Storage',
                    test: () => {
                        try {
                            localStorage.setItem('offline-test', 'working');
                            const result = localStorage.getItem('offline-test');
                            localStorage.removeItem('offline-test');
                            return result === 'working';
                        } catch (e) {
                            return false;
                        }
                    }
                },
                {
                    name: 'Animation Support',
                    test: () => {
                        return typeof requestAnimationFrame !== 'undefined' && 
                               typeof cancelAnimationFrame !== 'undefined';
                    }
                },
                {
                    name: 'Touch Events',
                    test: () => {
                        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                    }
                }
            ];

            console.log('üß™ Running offline functionality tests...');
            
            let passedTests = 0;
            const totalTests = offlineTests.length;
            
            offlineTests.forEach(test => {
                try {
                    const result = test.test();
                    if (result) {
                        passedTests++;
                        console.log(`‚úÖ ${test.name}: PASS`);
                    } else {
                        console.warn(`‚ö†Ô∏è ${test.name}: FAIL`);
                    }
                } catch (error) {
                    console.error(`‚ùå ${test.name}: ERROR -`, error);
                }
            });

            const successRate = (passedTests / totalTests) * 100;
            console.log(`üìä Offline functionality test results: ${passedTests}/${totalTests} (${successRate.toFixed(1)}%)`);
            
            if (successRate >= 80) {
                console.log('‚úÖ Offline functionality verified successfully');
            } else {
                console.warn('‚ö†Ô∏è Some offline features may not work properly');
                showNotification('Advertencia: Algunas funciones pueden no trabajar correctamente offline', 'error', 4000);
            }
        }

        // Monitor online/offline status
        function setupOfflineMonitoring() {
            function updateOnlineStatus() {
                const isOnline = navigator.onLine;
                console.log(`üåê Connection status: ${isOnline ? 'Online' : 'Offline'}`);
                
                if (!isOnline) {
                    showNotification('Modo offline activado. Todas las funciones siguen disponibles.', 'info', 3000);
                } else {
                    // When coming back online, update service worker cache
                    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                        navigator.serviceWorker.controller.postMessage({ command: 'UPDATE_CACHE' });
                    }
                }
                
                // Update UI to reflect connection status
                document.body.classList.toggle('offline', !isOnline);
            }

            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            
            // Initial status check
            updateOnlineStatus();
        }

        // Initialize offline monitoring
        document.addEventListener('DOMContentLoaded', () => {
            setupOfflineMonitoring();
        });
    </script>
</body>

</html>