<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Integration - Evaluation Flow</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-result { padding: 10px; margin: 5px 0; border-radius: 5px; }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <h1>Integration Tests for Evaluation Flow</h1>
    <p>This page tests the integration test functionality for the evaluation system.</p>
    
    <button onclick="runIntegrationTests()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
        Run Integration Tests
    </button>
    
    <div id="results" style="margin-top: 20px;"></div>

    <script>
        // Mock evaluation classes for testing
        class MockAngleEvaluation {
            constructor() {
                this.questions = [
                    { correctAnswer: '60', options: ['60', '90', '120'] },
                    { correctAnswer: '90', options: ['60', '90', '120'] }
                ];
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            init() {
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            checkAnswer(answer, question) {
                if (answer === question.correctAnswer) {
                    this.score++;
                }
            }
            
            nextQuestion() {
                this.currentQuestion++;
            }
        }

        class MockCircleEvaluation {
            constructor() {
                this.questions = [
                    { correctAnswer: 'radio', options: ['radio', 'diametro', 'cuerda'] },
                    { correctAnswer: 'centro', options: ['centro', 'arco', 'tangente'] }
                ];
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            init() {
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            checkAnswer(answer) {
                const question = this.questions[this.currentQuestion];
                if (answer === question.correctAnswer) {
                    this.score++;
                }
            }
            
            nextQuestion() {
                this.currentQuestion++;
            }
        }

        class MockPiEvaluation {
            constructor() {
                this.questions = [
                    { correctAnswer: '31.4' },
                    { correctAnswer: '62.8' }
                ];
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            start() {
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            checkAnswer() {
                const answerInput = document.getElementById('answerInput');
                if (answerInput && answerInput.value === this.questions[this.currentQuestion].correctAnswer) {
                    this.score++;
                }
            }
        }

        class MockFeedbackSystem {
            constructor() {
                this.currentSession = { questionStartTime: Date.now() };
            }
            
            startQuestionTimer() {
                this.currentSession.questionStartTime = Date.now();
            }
            
            validateResponse(userAnswer, correctAnswer, question) {
                return {
                    isCorrect: userAnswer === correctAnswer,
                    responseTime: Date.now() - this.currentSession.questionStartTime,
                    feedback: userAnswer === correctAnswer ? 'Correct!' : 'Incorrect, try again.'
                };
            }
            
            displayFeedback(result) {
                // Mock display feedback
            }
        }

        class MockQuestionGenerator {
            generateQuestionSet(moduleId, count, difficulty) {
                const questions = [];
                for (let i = 0; i < count; i++) {
                    questions.push({
                        id: `${moduleId}-${i}`,
                        type: 'multiple-choice',
                        question: `Test question ${i + 1}`,
                        correctAnswer: 'test_answer',
                        options: ['test_answer', 'wrong1', 'wrong2']
                    });
                }
                return questions;
            }
        }

        class MockFigureIdentificationGame {
            constructor(container) {
                this.container = container;
                this.score = 0;
                this.questionsAnswered = 0;
                this.currentFigure = { name: 'sector' };
            }
            
            init() {
                this.score = 0;
                this.questionsAnswered = 0;
                this.currentFigure = { name: 'sector' };
            }
            
            checkAnswer(answer) {
                if (answer === this.currentFigure.name) {
                    this.score++;
                }
            }
            
            nextQuestion() {
                this.questionsAnswered++;
                this.currentFigure = { name: ['sector', 'segment', 'corona'][this.questionsAnswered % 3] };
            }
        }

        class MockLinePositionEvaluation {
            constructor() {
                this.questions = [
                    { position: 'exterior', options: ['exterior', 'tangente', 'secante'] },
                    { position: 'tangente', options: ['exterior', 'tangente', 'secante'] }
                ];
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            init() {
                this.currentQuestion = 0;
                this.score = 0;
            }
            
            checkAnswer(answer) {
                const question = this.questions[this.currentQuestion];
                if (answer === question.position) {
                    this.score++;
                }
            }
            
            nextQuestion() {
                this.currentQuestion++;
            }
        }

        // Initialize mock instances
        const feedbackSystem = new MockFeedbackSystem();
        const questionGenerator = new MockQuestionGenerator();
        const AngleEvaluation = MockAngleEvaluation;
        const CircleEvaluation = MockCircleEvaluation;
        const PiEvaluation = MockPiEvaluation;
        const FigureIdentificationGame = MockFigureIdentificationGame;
        const LinePositionEvaluation = MockLinePositionEvaluation;

        // Integration test class (simplified version)
        class EvaluationFlowTests {
            constructor() {
                this.testResults = [];
            }

            assert(condition, message) {
                if (condition) {
                    this.testResults.push({ status: 'PASS', message });
                    return true;
                } else {
                    this.testResults.push({ status: 'FAIL', message });
                    return false;
                }
            }

            testAngleEvaluationFlow() {
                try {
                    const evaluation = new AngleEvaluation();
                    evaluation.init();
                    this.assert(evaluation.questions.length > 0, 'Angle evaluation generates questions');
                    this.assert(evaluation.currentQuestion === 0, 'Starts at first question');
                    this.assert(evaluation.score === 0, 'Initial score is zero');

                    const initialScore = evaluation.score;
                    const firstQuestion = evaluation.questions[0];
                    evaluation.checkAnswer(firstQuestion.correctAnswer, firstQuestion);
                    this.assert(evaluation.score === initialScore + 1, 'Correct answer increases score');
                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Angle evaluation flow test error: ${error.message}` });
                }
            }

            testFeedbackSystemIntegration() {
                try {
                    this.assert(typeof feedbackSystem !== 'undefined', 'Feedback system is available');
                    this.assert(typeof feedbackSystem.validateResponse === 'function', 'Feedback system has validateResponse method');

                    const testQuestion = {
                        id: 'test-1',
                        type: 'multiple-choice',
                        correctAnswer: 'correct_option',
                        explanation: 'Test explanation'
                    };

                    feedbackSystem.startQuestionTimer();
                    const correctResult = feedbackSystem.validateResponse('correct_option', 'correct_option', testQuestion);
                    this.assert(correctResult.isCorrect === true, 'Feedback system correctly validates correct answers');
                    this.assert(correctResult.responseTime > 0, 'Feedback system tracks response time');
                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Feedback system integration test error: ${error.message}` });
                }
            }

            testScoreCalculationAndProgress() {
                try {
                    this.assert(typeof questionGenerator !== 'undefined', 'Question generator is available');
                    
                    const angleQuestions = questionGenerator.generateQuestionSet('suma-angulos', 3, 'medium');
                    this.assert(angleQuestions.length === 3, 'Question generator creates correct number of angle questions');
                    
                    if (angleQuestions.length > 0) {
                        const question = angleQuestions[0];
                        this.assert(question.hasOwnProperty('id'), 'Generated questions have ID');
                        this.assert(question.hasOwnProperty('type'), 'Generated questions have type');
                        this.assert(question.hasOwnProperty('question'), 'Generated questions have question text');
                        this.assert(question.hasOwnProperty('correctAnswer'), 'Generated questions have correct answer');
                    }
                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Score calculation and progress test error: ${error.message}` });
                }
            }

            runAllTests() {
                console.log('üß™ Starting Evaluation Flow Integration Tests...');
                this.testResults = [];

                try {
                    this.testAngleEvaluationFlow();
                    this.testFeedbackSystemIntegration();
                    this.testScoreCalculationAndProgress();
                } catch (error) {
                    this.testResults.push({ status: 'ERROR', message: `Test execution error: ${error.message}` });
                }

                this.reportResults();
                return this.testResults;
            }

            reportResults() {
                const passed = this.testResults.filter(r => r.status === 'PASS').length;
                const failed = this.testResults.filter(r => r.status === 'FAIL').length;
                const errors = this.testResults.filter(r => r.status === 'ERROR').length;

                console.log(`\nüìä Evaluation Flow Integration Test Results:`);
                console.log(`‚úÖ Passed: ${passed}`);
                console.log(`‚ùå Failed: ${failed}`);
                console.log(`üö® Errors: ${errors}`);
                console.log(`üìà Total: ${this.testResults.length}`);
            }
        }

        function runIntegrationTests() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="info">Running integration tests...</div>';

            setTimeout(() => {
                const tester = new EvaluationFlowTests();
                const results = tester.runAllTests();
                
                const passed = results.filter(r => r.status === 'PASS').length;
                const failed = results.filter(r => r.status === 'FAIL').length;
                const errors = results.filter(r => r.status === 'ERROR').length;

                let html = `
                    <div class="info">
                        <h3>Test Results Summary</h3>
                        <p>‚úÖ Passed: ${passed} | ‚ùå Failed: ${failed} | üö® Errors: ${errors} | üìà Total: ${results.length}</p>
                    </div>
                `;

                results.forEach(result => {
                    const className = result.status === 'PASS' ? 'success' : 'error';
                    html += `<div class="test-result ${className}">${result.status}: ${result.message}</div>`;
                });

                resultsDiv.innerHTML = html;
            }, 100);
        }
    </script>
</body>
</html>